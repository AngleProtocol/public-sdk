{
  "language": "Solidity",
  "sources": {
    "contracts/agToken/AgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/// @title AgToken\n/// @author Angle Core Team\n/// @notice Base contract for agToken, that is to say Angle's stablecoins\n/// @dev This contract is used to create and handle the stablecoins of Angle protocol\n/// @dev Only the `StableMaster` contract can mint or burn agTokens\n/// @dev It is still possible for any address to burn its agTokens without redeeming collateral in exchange\ncontract AgToken is IAgToken, ERC20PermitUpgradeable {\n    // ========================= References to other contracts =====================\n\n    /// @notice Reference to the `StableMaster` contract associated to this `AgToken`\n    address public override stableMaster;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializes the `AgToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param stableMaster_ Reference to the `StableMaster` contract associated to this agToken\n    /// @dev By default, agTokens are ERC-20 tokens with 18 decimals\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address stableMaster_\n    ) external initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        require(stableMaster_ != address(0), \"0\");\n        stableMaster = stableMaster_;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Checks to see if it is the `StableMaster` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through this modifier\n    modifier onlyStableMaster() {\n        require(msg.sender == stableMaster, \"1\");\n        _;\n    }\n\n    // ========================= External Functions ================================\n    // The following functions allow anyone to burn stablecoins without redeeming collateral\n    // in exchange for that\n\n    /// @notice Destroys `amount` token from the caller without giving collateral back\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will\n    /// need to be updated\n    /// @dev When calling this function, people should specify the `poolManager` for which they want to decrease\n    /// the `stocksUsers`: this a way for the protocol to maintain healthy accounting variables\n    /// @dev This function is for instance to be used by governance to burn the tokens accumulated by the `BondingCurve`\n    /// contract\n    function burnNoRedeem(uint256 amount, address poolManager) external {\n        _burn(msg.sender, amount);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    /// @notice Burns `amount` of agToken on behalf of another account without redeeming collateral back\n    /// @param account Account to burn on behalf of\n    /// @param amount Amount to burn\n    /// @param poolManager Reference to the `PoolManager` contract for which the `stocksUsers` will need to be updated\n    function burnFromNoRedeem(\n        address account,\n        uint256 amount,\n        address poolManager\n    ) external {\n        _burnFromNoRedeem(amount, account, msg.sender);\n        IStableMaster(stableMaster).updateStocksUsers(amount, poolManager);\n    }\n\n    // ========================= `StableMaster` Functions ==========================\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by the `StableMaster` contract after being requested to do so\n    /// by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external override onlyStableMaster {\n        _burn(burner, amount);\n    }\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by the `StableMaster` contract after being requested to do so\n    /// by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external override onlyStableMaster {\n        _burnFromNoRedeem(amount, burner, sender);\n    }\n\n    /// @notice Lets the `StableMaster` contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev Only the `StableMaster` contract can issue agTokens\n    function mint(address account, uint256 amount) external override onlyStableMaster {\n        _mint(account, amount);\n    }\n\n    // ============================ Internal Function ==============================\n\n    /// @notice Internal version of the function `burnFromNoRedeem`\n    /// @param amount Amount to burn\n    /// @dev It is at the level of this function that allowance checks are performed\n    function _burnFromNoRedeem(\n        uint256 amount,\n        address burner,\n        address sender\n    ) internal {\n        uint256 currentAllowance = allowance(burner, sender);\n        require(currentAllowance >= amount, \"23\");\n        _approve(burner, sender, currentAllowance - amount);\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Core Team\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev The only functions that are left in the interface are the functions which are used\n/// at another point in the protocol by a different contract\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= `StableMaster` functions ============================\n    function mint(address account, uint256 amount) external;\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= External function =================================\n\n    function stableMaster() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Normally just importing `IPoolManager` should be sufficient, but for clarity here\n// we prefer to import all concerned interfaces\nimport \"./IPoolManager.sol\";\nimport \"./IOracle.sol\";\nimport \"./IPerpetualManager.sol\";\nimport \"./ISanToken.sol\";\n\n// Struct to handle all the parameters to manage the fees\n// related to a given collateral pool (associated to the stablecoin)\nstruct MintBurnData {\n    // Values of the thresholds to compute the minting fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeMint;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeMint;\n    // Values of the thresholds to compute the burning fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeBurn;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeBurn;\n    // Max proportion of collateral from users that can be covered by HAs\n    // It is exactly the same as the parameter of the same name in `PerpetualManager`, whenever one is updated\n    // the other changes accordingly\n    uint64 targetHAHedge;\n    // Minting fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusMint;\n    // Burning fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusBurn;\n    // Parameter used to limit the number of stablecoins that can be issued using the concerned collateral\n    uint256 capOnStableMinted;\n}\n\n// Struct to handle all the variables and parameters to handle SLPs in the protocol\n// including the fraction of interests they receive or the fees to be distributed to\n// them\nstruct SLPData {\n    // Last timestamp at which the `sanRate` has been updated for SLPs\n    uint256 lastBlockUpdated;\n    // Fees accumulated from previous blocks and to be distributed to SLPs\n    uint256 lockedInterests;\n    // Max interests used to update the `sanRate` in a single block\n    // Should be in collateral token base\n    uint256 maxInterestsDistributed;\n    // Amount of fees left aside for SLPs and that will be distributed\n    // when the protocol is collateralized back again\n    uint256 feesAside;\n    // Part of the fees normally going to SLPs that is left aside\n    // before the protocol is collateralized back again (depends on collateral ratio)\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippageFee;\n    // Portion of the fees from users minting and burning\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 feesForSLPs;\n    // Slippage factor that's applied to SLPs exiting (depends on collateral ratio)\n    // If `slippage = BASE_PARAMS`, SLPs can get nothing, if `slippage = 0` they get their full claim\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippage;\n    // Portion of the interests from lending\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 interestsForSLPs;\n}\n\n/// @title IStableMasterFunctions\n/// @author Angle Core Team\n/// @notice Interface for the `StableMaster` contract\ninterface IStableMasterFunctions {\n    function deploy(\n        address[] memory _governorList,\n        address _guardian,\n        address _agToken\n    ) external;\n\n    // ============================== Lending ======================================\n\n    function accumulateInterest(uint256 gain) external;\n\n    function signalLoss(uint256 loss) external;\n\n    // ============================== HAs ==========================================\n\n    function getStocksUsers() external view returns (uint256 maxCAmountInStable);\n\n    function convertToSLP(uint256 amount, address user) external;\n\n    // ============================== Keepers ======================================\n\n    function getCollateralRatio() external returns (uint256);\n\n    function setFeeKeeper(\n        uint64 feeMint,\n        uint64 feeBurn,\n        uint64 _slippage,\n        uint64 _slippageFee\n    ) external;\n\n    // ============================== AgToken ======================================\n\n    function updateStocksUsers(uint256 amount, address poolManager) external;\n\n    // ============================= Governance ====================================\n\n    function setCore(address newCore) external;\n\n    function addGovernor(address _governor) external;\n\n    function removeGovernor(address _governor) external;\n\n    function setGuardian(address newGuardian, address oldGuardian) external;\n\n    function revokeGuardian(address oldGuardian) external;\n\n    function setCapOnStableAndMaxInterests(\n        uint256 _capOnStableMinted,\n        uint256 _maxInterestsDistributed,\n        IPoolManager poolManager\n    ) external;\n\n    function setIncentivesForSLPs(\n        uint64 _feesForSLPs,\n        uint64 _interestsForSLPs,\n        IPoolManager poolManager\n    ) external;\n\n    function setUserFees(\n        IPoolManager poolManager,\n        uint64[] memory _xFee,\n        uint64[] memory _yFee,\n        uint8 _mint\n    ) external;\n\n    function setTargetHAHedge(uint64 _targetHAHedge) external;\n\n    function pause(bytes32 agent, IPoolManager poolManager) external;\n\n    function unpause(bytes32 agent, IPoolManager poolManager) external;\n}\n\n/// @title IStableMaster\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\ninterface IStableMaster is IStableMasterFunctions {\n    function agToken() external view returns (address);\n\n    function collateralMap(IPoolManager poolManager)\n        external\n        view\n        returns (\n            IERC20 token,\n            ISanToken sanToken,\n            IPerpetualManager perpetualManager,\n            IOracle oracle,\n            uint256 stocksUsers,\n            uint256 sanRate,\n            uint256 collatBase,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IFeeManager.sol\";\nimport \"./IPerpetualManager.sol\";\nimport \"./IOracle.sol\";\n\n// Struct for the parameters associated to a strategy interacting with a collateral `PoolManager`\n// contract\nstruct StrategyParams {\n    // Timestamp of last report made by this strategy\n    // It is also used to check if a strategy has been initialized\n    uint256 lastReport;\n    // Total amount the strategy is expected to have\n    uint256 totalStrategyDebt;\n    // The share of the total assets in the `PoolManager` contract that the `strategy` can access to.\n    uint256 debtRatio;\n}\n\n/// @title IPoolManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the collateral poolManager contracts handling each one type of collateral for\n/// a given stablecoin\n/// @dev Only the functions used in other contracts of the protocol are left here\ninterface IPoolManagerFunctions {\n    // ============================ Constructor ====================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IPerpetualManager _perpetualManager,\n        IFeeManager feeManager,\n        IOracle oracle\n    ) external;\n\n    // ============================ Yield Farming ==================================\n\n    function creditAvailable() external view returns (uint256);\n\n    function debtOutstanding() external view returns (uint256);\n\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external;\n\n    // ============================ Governance =====================================\n\n    function addGovernor(address _governor) external;\n\n    function removeGovernor(address _governor) external;\n\n    function setGuardian(address _guardian, address guardian) external;\n\n    function revokeGuardian(address guardian) external;\n\n    function setFeeManager(IFeeManager _feeManager) external;\n\n    // ============================= Getters =======================================\n\n    function getBalance() external view returns (uint256);\n\n    function getTotalAsset() external view returns (uint256);\n}\n\n/// @title IPoolManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\n/// @dev Used in other contracts of the protocol\ninterface IPoolManager is IPoolManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n\n    function token() external view returns (address);\n\n    function feeManager() external view returns (address);\n\n    function totalDebt() external view returns (uint256);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title IOracle\n/// @author Angle Core Team\n/// @notice Interface for Angle's oracle contracts reading oracle rates from both UniswapV3 and Chainlink\n/// from just UniswapV3 or from just Chainlink\ninterface IOracle {\n    function read() external view returns (uint256);\n\n    function readAll() external view returns (uint256 lowerRate, uint256 upperRate);\n\n    function readLower() external view returns (uint256);\n\n    function readUpper() external view returns (uint256);\n\n    function readQuote(uint256 baseAmount) external view returns (uint256);\n\n    function readQuoteLower(uint256 baseAmount) external view returns (uint256);\n\n    function inBase() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPerpetualManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IERC721.sol\";\nimport \"./IFeeManager.sol\";\nimport \"./IOracle.sol\";\nimport \"./IAccessControl.sol\";\n\n/// @title Interface of the contract managing perpetuals\n/// @author Angle Core Team\n/// @dev Front interface, meaning only user-facing functions\ninterface IPerpetualManagerFront is IERC721Metadata {\n    function openPerpetual(\n        address owner,\n        uint256 amountBrought,\n        uint256 amountCommitted,\n        uint256 maxOracleRate,\n        uint256 minNetMargin\n    ) external returns (uint256 perpetualID);\n\n    function closePerpetual(\n        uint256 perpetualID,\n        address to,\n        uint256 minCashOutAmount\n    ) external;\n\n    function addToPerpetual(uint256 perpetualID, uint256 amount) external;\n\n    function removeFromPerpetual(\n        uint256 perpetualID,\n        uint256 amount,\n        address to\n    ) external;\n\n    function liquidatePerpetuals(uint256[] memory perpetualIDs) external;\n\n    function forceClosePerpetuals(uint256[] memory perpetualIDs) external;\n\n    // ========================= External View Functions =============================\n\n    function getCashOutAmount(uint256 perpetualID, uint256 rate) external view returns (uint256, uint256);\n\n    function isApprovedOrOwner(address spender, uint256 perpetualID) external view returns (bool);\n}\n\n/// @title Interface of the contract managing perpetuals\n/// @author Angle Core Team\n/// @dev This interface does not contain user facing functions, it just has functions that are\n/// interacted with in other parts of the protocol\ninterface IPerpetualManagerFunctions is IAccessControl {\n    // ================================= Governance ================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IFeeManager feeManager,\n        IOracle oracle_\n    ) external;\n\n    function setFeeManager(IFeeManager feeManager_) external;\n\n    function setHAFees(\n        uint64[] memory _xHAFees,\n        uint64[] memory _yHAFees,\n        uint8 deposit\n    ) external;\n\n    function setTargetAndLimitHAHedge(uint64 _targetHAHedge, uint64 _limitHAHedge) external;\n\n    function setKeeperFeesLiquidationRatio(uint64 _keeperFeesLiquidationRatio) external;\n\n    function setKeeperFeesCap(uint256 _keeperFeesLiquidationCap, uint256 _keeperFeesClosingCap) external;\n\n    function setKeeperFeesClosing(uint64[] memory _xKeeperFeesClosing, uint64[] memory _yKeeperFeesClosing) external;\n\n    function setLockTime(uint64 _lockTime) external;\n\n    function setBoundsPerpetual(uint64 _maxLeverage, uint64 _maintenanceMargin) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    // ==================================== Keepers ================================\n\n    function setFeeKeeper(uint64 feeDeposit, uint64 feesWithdraw) external;\n\n    // =============================== StableMaster ================================\n\n    function setOracle(IOracle _oracle) external;\n}\n\n/// @title IPerpetualManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables\ninterface IPerpetualManager is IPerpetualManagerFunctions {\n    function poolManager() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function targetHAHedge() external view returns (uint64);\n\n    function totalHedgeAmount() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISanToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title ISanToken\n/// @author Angle Core Team\n/// @notice Interface for Angle's `SanToken` contract that handles sanTokens, tokens that are given to SLPs\n/// contributing to a collateral for a given stablecoin\ninterface ISanToken is IERC20Upgradeable {\n    // ================================== StableMaster =============================\n\n    function mint(address account, uint256 amount) external;\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    function stableMaster() external view returns (address);\n\n    function poolManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IFeeManagerFunctions\n/// @author Angle Core Team\n/// @dev Interface for the `FeeManager` contract\ninterface IFeeManagerFunctions is IAccessControl {\n    // ================================= Keepers ===================================\n\n    function updateUsersSLP() external;\n\n    function updateHA() external;\n\n    // ================================= Governance ================================\n\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        address _perpetualManager\n    ) external;\n\n    function setFees(\n        uint256[] memory xArray,\n        uint64[] memory yArray,\n        uint8 typeChange\n    ) external;\n\n    function setHAFees(uint64 _haFeeDeposit, uint64 _haFeeWithdraw) external;\n}\n\n/// @title IFeeManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\n/// @dev We need these getters as they are used in other contracts of the protocol\ninterface IFeeManager is IFeeManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title IAccessControl\n/// @author Forked from OpenZeppelin\n/// @notice Interface for `AccessControl` contracts\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/sanToken/SanToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n// OpenZeppelin may update its version of the ERC20PermitUpgradeable token\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/ISanToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\n\n/// @title SanToken\n/// @author Angle Core Team\n/// @notice Base contract for sanTokens, these tokens are used to mark the debt the contract has to SLPs\n/// @dev The exchange rate between sanTokens and collateral will automatically change as interests and transaction fees accrue to SLPs\n/// @dev There is one `SanToken` contract per pair stablecoin/collateral\ncontract SanToken is ISanToken, ERC20PermitUpgradeable {\n    /// @notice Number of decimals used for this ERC20\n    uint8 public decimal;\n\n    // ========================= References to other contracts =====================\n\n    /// @notice Address of the corresponding `StableMaster` contract\n    /// This address cannot be modified\n    address public override stableMaster;\n\n    /// @notice Address of the corresponding `PoolManager` contract\n    /// This address cannot be modified\n    /// Although it is not used in the functions of the contract, this address is stored in\n    /// order to make sure that there cannot be a shared sanToken for multiple `PoolManager` contracts\n    address public override poolManager;\n\n    // =============================== Constructor =================================\n\n    /// @notice Initializes the `SanToken` contract\n    /// @param name_ Name of the token\n    /// @param symbol_ Symbol of the token\n    /// @param _poolManager Reference to the `PoolManager` contract associated to this `SanToken`\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address _poolManager\n    ) public initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n\n        poolManager = _poolManager;\n        stableMaster = IPoolManager(poolManager).stableMaster();\n\n        // It is possible that some ERC20 tokens do not implement this interface, in which case\n        // we will have to change the constructor\n        // The number of decimals of a sanToken is the number of decimals of the collateral that\n        // corresponds to it\n        decimal = IERC20MetadataUpgradeable(IPoolManager(poolManager).token()).decimals();\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Checks to see if it is the `StableMaster` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through these modifiers\n    modifier onlyStableMaster() {\n        require(msg.sender == stableMaster, \"1\");\n        _;\n    }\n\n    // ========================= External Functions ================================\n\n    /// @notice Returns the number of decimals used to get its user representation.\n    /// @dev For example, if `decimals` equals `2`, a balance of `505` tokens should\n    /// be displayed to a user as `5,05` (`505 / 10 ** 2`)\n    /// @dev Tokens usually opt for a value of 18, imitating the relationship between\n    /// Ether and Wei. This is the value {ERC20} uses, unless this function is overridden\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /// @notice Destroys `amount` token for the caller without giving collateral back\n    /// @param amount Amount to burn\n    function burnNoRedeem(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // ===================== `StableMaster` Functions ==============================\n\n    /// @notice Lets the `StableMaster` contract mint sanTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev Only the `StableMaster` contract can issue sanTokens\n    /// @dev There is no need to make this function pausable (as well as the `StableMaster` functions below)\n    /// as the corresponding function can directly be paused from the `StableMaster`\n    function mint(address account, uint256 amount) external override onlyStableMaster {\n        _mint(account, amount);\n    }\n\n    /// @notice Lets an address burn sanTokens\n    /// @param amount Amount of sanTokens to burn from caller\n    /// @dev This can only be called by the `StableMaster` which performs all the security checks\n    /// to see for instance if the `burner` was the initial `msg.sender`\n    function burnSelf(uint256 amount, address burner) external override onlyStableMaster {\n        _burn(burner, amount);\n    }\n\n    /// @notice Lets a `sender` address burn sanTokens from another `burner` address\n    /// @param burner Address to burn from and to redeem collateral to\n    /// @param amount Amount of sanTokens to burn\n    /// @dev Only the `StableMaster` can call this function\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external override onlyStableMaster {\n        uint256 currentAllowance = allowance(burner, sender);\n        require(currentAllowance >= amount, \"23\");\n        _approve(burner, sender, currentAllowance - amount);\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/surplus/SurplusConverterSanTokens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/ISanToken.sol\";\nimport \"./BaseSurplusConverter.sol\";\n\ninterface IStableMasterFront {\n    function deposit(\n        uint256 amount,\n        address to,\n        address poolManager\n    ) external;\n}\n\n/// @title SurplusConverterSanTokens\n/// @author Angle Core Team\n/// @notice A contract to swap tokens from the surplus of the protocol to a reward token\n/// (could be ANGLE tokens, or another type of token)\n/// @dev This contract gets sanTokens from a token of the Angle protocol\ncontract SurplusConverterSanTokens is BaseSurplusConverter {\n    using SafeERC20 for IERC20;\n\n    event PathUpdated(address indexed token, bytes newPath, bytes oldPath);\n    event TokenRevoked(address indexed token);\n\n    IStableMasterFront public immutable stableMaster;\n    address public immutable poolManager;\n    address public immutable supportedToken;\n\n    /// @notice Constructor of the `SurplusConverterSanTokens`\n    /// @param _rewardToken Reward token that this contract tries to buy\n    /// @param _feeDistributor Reference to the contract handling fee distribution\n    /// @param _stableMaster Reference to the `stableMaster` contract\n    /// @param whitelisted Reference to the first whitelisted address that will have the right\n    /// @param governor Governor of the protocol\n    /// @param guardians List of guardians of the protocol\n    constructor(\n        address _rewardToken,\n        address _feeDistributor,\n        address _stableMaster,\n        address whitelisted,\n        address governor,\n        address[] memory guardians\n    ) BaseSurplusConverter(_rewardToken, _feeDistributor, whitelisted, governor, guardians) {\n        require(_stableMaster != address(0), \"0\");\n        stableMaster = IStableMasterFront(_stableMaster);\n        // This will revert if the rewardToken of this contract is not a sanToken\n        address poolManagerInt = ISanToken(_rewardToken).poolManager();\n        poolManager = poolManagerInt;\n        address supportedTokenInt = IPoolManager(poolManagerInt).token();\n        supportedToken = supportedTokenInt;\n        IERC20(supportedTokenInt).safeApprove(_stableMaster, type(uint256).max);\n    }\n\n    /// @notice Mints `rewardToken` from the protocol itself using the accumulated `token` and distributes\n    /// the results of the swaps to the `FeeDistributor` or some other `SurplusConverter` contract\n    /// @param token Token to use for buybacks of `rewardToken`\n    /// @param amount Amount of tokens to use for the buyback\n    /// @param transfer Whether the function should transfer the bought back `rewardToken` directly to the `FeeDistributor`\n    /// contract or to the associated `SurplusConverter` contract\n    /// @dev In this contract the `rewardToken` is a sanToken, so this function essentially deposits collateral\n    /// in the Angle Protocol\n    /// @dev There is no need to put slippage protection here as there is no slippage for SLPs deposits in the Angle\n    /// Protocol\n    function buyback(\n        address token,\n        uint256 amount,\n        uint256,\n        bool transfer\n    ) external override whenNotPaused onlyRole(WHITELISTED_ROLE) {\n        require(token == supportedToken, \"20\");\n        stableMaster.deposit(amount, address(this), poolManager);\n        if (transfer) {\n            // This call will automatically transfer all the `rewardToken` balance of this contract to the `FeeDistributor`\n            feeDistributor.burn(address(rewardToken));\n        }\n    }\n}\n"
    },
    "contracts/surplus/BaseSurplusConverter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"../external/AccessControl.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title BaseSurplusConverter\n/// @author Angle Core Team\n/// @notice A base contract for the swap tokens from the surplus of the protocol to a reward token\n/// (could be ANGLE tokens, or another type of token like sanTokens)\n/// @dev All contracts implementing such swap features in Angle should implement this base contract\nabstract contract BaseSurplusConverter is AccessControl, Pausable, IFeeDistributor {\n    using SafeERC20 for IERC20;\n\n    event FeeDistributorUpdated(address indexed newFeeDistributor, address indexed oldFeeDistributor);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    /// @notice Role for governor of this contract\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n    /// @notice Role for guardians of this contract\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Role for addresses allowed to redistribute the protocol's surplus\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n\n    /// @notice Address responsible for distributing bought back reward tokens to veANGLE holders or for swapping\n    /// the reward token of this contract to another token\n    IFeeDistributor public feeDistributor;\n\n    /// @notice Reward Token obtained by this contract\n    IERC20 public immutable rewardToken;\n\n    /// @notice Constructor of the `BaseSurplusConverter`\n    /// @param _rewardToken Reward token that this contract tries to buy or otain\n    /// @param _feeDistributor Reference to the contract handling fee distribution\n    /// @param whitelisted Reference to the first whitelisted address that will have the right to perform buybacks\n    /// @param governor Governor of the protocol\n    /// @param guardians List of guardians of the protocol\n    /// @dev Having a list of guardians as a parameter facilitates deployment of the contract\n    constructor(\n        address _rewardToken,\n        address _feeDistributor,\n        address whitelisted,\n        address governor,\n        address[] memory guardians\n    ) {\n        require(_feeDistributor != address(0) && whitelisted != address(0) && governor != address(0), \"0\");\n        feeDistributor = IFeeDistributor(_feeDistributor);\n        rewardToken = IERC20(_rewardToken);\n        // The function is going to revert because of the following call if the `_rewardToken` parameter is the\n        // zero address\n        IERC20(_rewardToken).safeApprove(_feeDistributor, type(uint256).max);\n        require(guardians.length > 0, \"101\");\n        for (uint256 i = 0; i < guardians.length; i++) {\n            require(guardians[i] != address(0), \"0\");\n            _setupRole(GUARDIAN_ROLE, guardians[i]);\n        }\n        _setupRole(WHITELISTED_ROLE, whitelisted);\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(WHITELISTED_ROLE, GUARDIAN_ROLE);\n        // Contract is paused after deployment\n        _pause();\n    }\n\n    /// @notice Changes the reference to the `FeeDistributor` allowed to distribute rewards to veANGLE holders\n    /// or to swap the reward token to another token\n    /// @param _feeDistributor Reference to the new `FeeDistributor`\n    /// @dev This function is a governor only function as it could technically be used to withdraw funds from the protocol\n    function setFeeDistributor(address _feeDistributor) external onlyRole(GOVERNOR_ROLE) {\n        require(_feeDistributor != address(0), \"0\");\n        address oldFeeDistributor = address(feeDistributor);\n        feeDistributor = IFeeDistributor(_feeDistributor);\n        IERC20 rewardTokenMem = rewardToken;\n        rewardTokenMem.safeApprove(_feeDistributor, type(uint256).max);\n        rewardTokenMem.safeApprove(oldFeeDistributor, 0);\n        emit FeeDistributorUpdated(_feeDistributor, oldFeeDistributor);\n    }\n\n    /// @notice Withdraws ERC20 tokens that could accrue on this contract\n    /// @param tokenAddress Address of the ERC20 token to withdraw\n    /// @param to Address to transfer to\n    /// @param amount Amount to transfer\n    /// @dev Added to support recovering rewardToken in case of impossible buybacks\n    /// and other tokens mistakenly sent to this contract\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external onlyRole(GOVERNOR_ROLE) {\n        IERC20(tokenAddress).safeTransfer(to, amount);\n        emit Recovered(tokenAddress, to, amount);\n    }\n\n    /// @notice Pauses the `buyback`, `sendToFeeDistributor` and `burn` methods\n    /// @dev After calling this function, it is going to be impossible for whitelisted addresses to buyback\n    /// reward tokens or to send the bought back tokens to the `FeeDistributor`\n    function pause() external onlyRole(GUARDIAN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses the `buyback` and `sendToFeeDistributor` methods\n    function unpause() external onlyRole(GUARDIAN_ROLE) {\n        _unpause();\n    }\n\n    /// @notice Buys back `rewardToken` using the accumulated `token` and distributes the results of the\n    /// swaps to the `feeDistributor` contract (which can be another `SurplusConverter`)\n    /// @param token Token to use for buybacks of `rewardToken`\n    /// @param amount Amount of tokens to use for the buyback\n    /// @param minAmount Specify the minimum amount to receive - slippage protection\n    /// @param transfer Whether the function should transfer the bought back `rewardToken` directly to the `FeeDistributor`\n    /// contract\n    /// @dev This function should revert if `amount` is inferior to the amount of `token` owned by this contract\n    /// @dev The reason for the variable `amount` instead of simply using the whole contract's balance for buybacks\n    /// is that it gives more flexibility to the addresses handling buyback to optimize for the swap prices\n    /// @dev This function should be whitelisted because arbitrageurs could take advantage of it to do sandwich attacks\n    /// by just calling this function. Calls to this function could be sandwiched too but it's going harder for miners to\n    /// setup sandwich attacks\n    function buyback(\n        address token,\n        uint256 amount,\n        uint256 minAmount,\n        bool transfer\n    ) external virtual;\n\n    /// @notice Pulls tokens from another `SurplusConverter` contract\n    /// @param token Address of the token to pull\n    /// @dev This function is what allows for composability between different `SurplusConverter` contracts: a surplus converter\n    /// having swapped tokens can send its output token to another surplus converter, responsible for doing another type\n    /// of conversion, by calling this contract\n    function burn(address token) external override whenNotPaused {\n        IERC20(token).safeTransferFrom(msg.sender, address(this), IERC20(token).balanceOf(msg.sender));\n    }\n\n    /// @notice This function transfers all the accumulated `rewardToken` to the `FeeDistributor` contract\n    /// @dev The reason for having this function rather than doing such transfers directly in the `buyback` function is that\n    /// it can allow to batch transfers and thus optimizes for gas\n    function sendToFeeDistributor() external whenNotPaused {\n        feeDistributor.burn(address(rewardToken));\n    }\n}\n"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title IFeeDistributor\n/// @author Interface of the `FeeDistributor` contract\n/// @dev This interface is used by the `SurplusConverter` contract to send funds to the `FeeDistributor`\ninterface IFeeDistributor {\n    function burn(address token) external;\n}\n"
    },
    "contracts/external/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/IAccessControl.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControl`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == _msgSender(), \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/surplus/SurplusConverterUniV3.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"./BaseSurplusConverter.sol\";\n\n/// @title SurplusConverterUniV3\n/// @author Angle Core Team\n/// @notice A contract to swap tokens from the surplus of the protocol to a reward token\n/// (could be ANGLE tokens, or another type of token)\n/// @dev This contract swaps tokens on UniV3\ncontract SurplusConverterUniV3 is BaseSurplusConverter {\n    using SafeERC20 for IERC20;\n\n    event PathUpdated(address indexed token, bytes newPath, bytes oldPath);\n    event TokenRevoked(address indexed token);\n\n    /// @notice Address of the uniswapV2Router for swaps\n    IUniswapV3Router public immutable uniswapV3Router;\n\n    /// @notice Maps a token to the related path on Uniswap to do the swap to the reward token\n    mapping(address => bytes) public uniswapPaths;\n\n    /// @notice Constructor of the `SurplusConverterUniV3`\n    /// @param _rewardToken Reward token that this contract tries to buy\n    /// @param _feeDistributor Reference to the contract handling fee distribution\n    /// @param _uniswapV3Router Reference to the `UniswapV2Router`\n    /// @param whitelisted Reference to the first whitelisted address that will have the right\n    /// @param governor Governor of the protocol\n    /// @param guardians List of guardians of the protocol\n    constructor(\n        address _rewardToken,\n        address _feeDistributor,\n        address _uniswapV3Router,\n        address whitelisted,\n        address governor,\n        address[] memory guardians\n    ) BaseSurplusConverter(_rewardToken, _feeDistributor, whitelisted, governor, guardians) {\n        require(_uniswapV3Router != address(0), \"0\");\n        uniswapV3Router = IUniswapV3Router(_uniswapV3Router);\n    }\n\n    /// @notice Adds a token to support with this contract\n    /// @param token Token to add to this contract\n    /// @param pathAddresses Addresses used (in order) for the swap\n    /// @param pathFees Fees used (in order) to get the path for the pool to use for the swap\n    /// @dev This function can be called to change the path for a token or to add a new supported\n    /// token\n    function addToken(\n        address token,\n        address[] memory pathAddresses,\n        uint24[] memory pathFees\n    ) external onlyRole(GUARDIAN_ROLE) {\n        require(token != address(0), \"0\");\n        require(pathAddresses.length >= 2, \"5\");\n        require(pathAddresses.length == (pathFees.length + 1), \"104\");\n        require(pathAddresses[0] == token && pathAddresses[pathAddresses.length - 1] == address(rewardToken), \"111\");\n\n        bytes memory path;\n        for (uint256 i = 0; i < pathFees.length; i++) {\n            require(pathAddresses[i] != address(0) && pathAddresses[i + 1] != address(0), \"0\");\n            path = abi.encodePacked(path, pathAddresses[i], pathFees[i]);\n        }\n        path = abi.encodePacked(path, pathAddresses[pathFees.length]);\n\n        // As this function can be sued to change the path for an existing token,\n        // we're checking if a path already exists for this token before giving it\n        // approval\n        bytes memory oldPath = uniswapPaths[token];\n        if (oldPath.length == 0) {\n            IERC20(token).safeApprove(address(uniswapV3Router), type(uint256).max);\n        }\n        uniswapPaths[token] = path;\n        emit PathUpdated(token, path, oldPath);\n    }\n\n    /// @notice Revokes a token supported by this contract\n    /// @param token Token to add to this contract\n    function revokeToken(address token) external onlyRole(GUARDIAN_ROLE) {\n        delete uniswapPaths[token];\n        IERC20(token).safeApprove(address(uniswapV3Router), 0);\n        emit TokenRevoked(token);\n    }\n\n    /// @notice Buys back `rewardToken` from UniswapV3 using the accumulated `token` and distributes\n    /// the results of the swaps to the `FeeDistributor` or some other `SurplusConverter` contract\n    /// @param token Token to use for buybacks of `rewardToken`\n    /// @param amount Amount of tokens to use for the buyback\n    /// @param minAmount Specify the minimum amount to receive out of the swap as a slippage protection\n    /// @param transfer Whether the function should transfer the bought back `rewardToken` directly to the `FeeDistributor`\n    /// contract or to the associated `SurplusConverter`\n    /// @dev This function always chooses the same path\n    function buyback(\n        address token,\n        uint256 amount,\n        uint256 minAmount,\n        bool transfer\n    ) external override whenNotPaused onlyRole(WHITELISTED_ROLE) {\n        bytes memory path = uniswapPaths[token];\n        require(path.length != 0, \"111\");\n        uniswapV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, amount, minAmount));\n        if (transfer) {\n            // This call will automatically transfer all the `rewardToken` balance of this contract to the `FeeDistributor`\n            feeDistributor.burn(address(rewardToken));\n        }\n    }\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\n/// @title Router for price estimation functionality\n/// @notice Functions for getting the price of one token with respect to another using Uniswap V2\n/// @dev This interface is only used for non critical elements of the protocol\ninterface IUniswapV2Router {\n    /// @notice Given an input asset amount, returns the maximum output amount of the\n    /// other asset (accounting for fees) given reserves.\n    /// @param path Addresses of the pools used to get prices\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 swapAmount,\n        uint256 minExpected,\n        address[] calldata path,\n        address receiver,\n        uint256 swapDeadline\n    ) external;\n}\n"
    },
    "contracts/surplus/SurplusConverterUniV2Sushi.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"./BaseSurplusConverter.sol\";\n\n/// @title SurplusConverterUniV2Sushi\n/// @author Angle Core Team\n/// @notice A contract to swap tokens from the surplus of the protocol to a reward token\n/// (could be ANGLE tokens, or another type of token)\n/// @dev This contract for each swap compares swaps using UniswapV2 with swaps using Sushiswap and does the swap with the\n/// exchange with the best price\ncontract SurplusConverterUniV2Sushi is BaseSurplusConverter {\n    using SafeERC20 for IERC20;\n\n    event PathAdded(address indexed token, address[] path, uint8 typePath);\n    event PathRevoked(address indexed token, uint8 _type);\n\n    /// @notice Address of the uniswapV2Router for swaps\n    IUniswapV2Router public immutable uniswapV2Router;\n\n    /// @notice Address of the sushiswapV2Router for swaps\n    IUniswapV2Router public immutable sushiswapRouter;\n\n    /// @notice Maps a token to the related path on Uniswap to do the swap to the reward token\n    mapping(address => address[]) public uniswapPaths;\n\n    /// @notice Maps a token to the related path on Sushiswap to do the swap to the reward token\n    mapping(address => address[]) public sushiswapPaths;\n\n    /// @notice Constructor of the `SurplusConverterUniV2Sushi`\n    /// @param _rewardToken Reward token that this contract tries to buy\n    /// @param _feeDistributor Reference to the contract handling fee distribution\n    /// @param _uniswapV2Router Reference to the `UniswapV2Router`\n    /// @param _sushiswapRouter Reference to the `SushiswapRouter`\n    /// @param whitelisted Reference to the first whitelisted address that will have the right\n    /// @param governor Governor of the protocol\n    /// @param guardians List of guardians of the protocol\n    constructor(\n        address _rewardToken,\n        address _feeDistributor,\n        address _uniswapV2Router,\n        address _sushiswapRouter,\n        address whitelisted,\n        address governor,\n        address[] memory guardians\n    ) BaseSurplusConverter(_rewardToken, _feeDistributor, whitelisted, governor, guardians) {\n        require(_uniswapV2Router != address(0) && _sushiswapRouter != address(0), \"0\");\n        sushiswapRouter = IUniswapV2Router(_sushiswapRouter);\n        uniswapV2Router = IUniswapV2Router(_uniswapV2Router);\n    }\n\n    /// @notice Adds a token to support with this contract\n    /// @param token Token to add to this contract\n    /// @param path Path used for the swap\n    /// @param typePath Type of path specified, i.e is it a path for Sushiswap or for Uniswap\n    /// @dev `typePath = 0` corresponds to a Sushiswap path\n    /// @dev `typePath = 1` corresponds to a Uniswap path\n    /// @dev This function can be called to change the path for a token or to add support\n    /// for Uniswap or for Sushiswap\n    function addToken(\n        address token,\n        address[] memory path,\n        uint8 typePath\n    ) external onlyRole(GUARDIAN_ROLE) {\n        require(token != address(0), \"0\");\n        uint256 pathLength = path.length;\n        require(pathLength >= 2 && path[pathLength - 1] == address(rewardToken) && path[0] == token, \"111\");\n        if (typePath == 0) {\n            if (sushiswapPaths[token].length == 0) {\n                // If this path is for a brand new token, then we need to approve the Sushiswap Router contract\n                IERC20(token).safeApprove(address(sushiswapRouter), type(uint256).max);\n            }\n            sushiswapPaths[token] = path;\n        } else {\n            if (uniswapPaths[token].length == 0) {\n                // If this path is a brand new path, then we need to approve the Uniswap Router contract\n                IERC20(token).safeApprove(address(uniswapV2Router), type(uint256).max);\n            }\n            uniswapPaths[token] = path;\n        }\n        emit PathAdded(token, path, typePath);\n    }\n\n    /// @notice Getter defined to easily get access to the array of addresses corresponding to a token\n    /// @param token Token to query\n    /// @param typePath Type of path to fetch (= 0 if Sushiswap, > 0 if Uniswap)\n    function getPath(address token, uint8 typePath) external view returns (address[] memory) {\n        if (typePath == 0) {\n            return sushiswapPaths[token];\n        } else {\n            return uniswapPaths[token];\n        }\n    }\n\n    /// @notice Revokes a supported token by this contract or just a path for this token\n    /// @param token Token to revoke\n    /// @param _type Type of revokation to make\n    /// @dev `type = 0` means that just the Sushiswap path needs to be revoked\n    /// @dev `type = 1` means that just the Uniswap path should be revoked\n    /// @dev Other types mean that both Uniswap and Sushiswap paths should be revoked: the token is no longer handled\n    function revokeToken(address token, uint8 _type) external onlyRole(GUARDIAN_ROLE) {\n        if (_type == 0) {\n            delete sushiswapPaths[token];\n            IERC20(token).safeApprove(address(sushiswapRouter), 0);\n        } else if (_type == 1) {\n            delete uniswapPaths[token];\n            IERC20(token).safeApprove(address(uniswapV2Router), 0);\n        } else {\n            delete sushiswapPaths[token];\n            delete uniswapPaths[token];\n            IERC20(token).safeApprove(address(uniswapV2Router), 0);\n            IERC20(token).safeApprove(address(sushiswapRouter), 0);\n        }\n        emit PathRevoked(token, _type);\n    }\n\n    /// @notice Buys back `rewardToken` from Uniswap or Sushiswap using the accumulated `token` and distributes\n    /// the results of the swaps to the `FeeDistributor` or some other `SurplusConverter` contract\n    /// @param token Token to use for buybacks of `rewardToken`\n    /// @param amount Amount of tokens to use for the buyback\n    /// @param minAmount Specify the minimum amount to receive out of the swap as a slippage protection\n    /// @param transfer Whether the function should transfer the bought back `rewardToken` directly to the `FeeDistributor`\n    /// contract or to the associated other `SurplusConverter`\n    /// @dev If a `token` has two paths associated to it (one from Uniswap, one from Sushiswap), this function optimizes\n    /// and chooses the best path\n    function buyback(\n        address token,\n        uint256 amount,\n        uint256 minAmount,\n        bool transfer\n    ) external override whenNotPaused onlyRole(WHITELISTED_ROLE) {\n        // Storing the values in memory to avoid multiple storage reads\n        address[] memory sushiswapPath = sushiswapPaths[token];\n        address[] memory uniswapPath = uniswapPaths[token];\n        require(sushiswapPath.length > 0 || uniswapPath.length > 0, \"20\");\n        if (sushiswapPath.length > 0 && uniswapPath.length > 0) {\n            // Storing the router addresses in memory to avoid duplicate storage reads for one of the two\n            // addresses\n            IUniswapV2Router uniswapV2RouterMem = uniswapV2Router;\n            IUniswapV2Router sushiswapRouterMem = sushiswapRouter;\n            uint256[] memory amountsUni = uniswapV2RouterMem.getAmountsOut(amount, uniswapPath);\n            uint256[] memory amountsSushi = sushiswapRouterMem.getAmountsOut(amount, sushiswapPath);\n            if (amountsUni[amountsUni.length - 1] >= amountsSushi[amountsSushi.length - 1]) {\n                uniswapV2RouterMem.swapExactTokensForTokens(\n                    amount,\n                    minAmount,\n                    uniswapPath,\n                    address(this),\n                    block.timestamp\n                );\n            } else {\n                sushiswapRouterMem.swapExactTokensForTokens(\n                    amount,\n                    minAmount,\n                    sushiswapPath,\n                    address(this),\n                    block.timestamp\n                );\n            }\n        } else if (sushiswapPath.length > 0) {\n            sushiswapRouter.swapExactTokensForTokens(amount, minAmount, sushiswapPath, address(this), block.timestamp);\n        } else {\n            uniswapV2Router.swapExactTokensForTokens(amount, minAmount, uniswapPath, address(this), block.timestamp);\n        }\n        if (transfer) {\n            // This call will automatically transfer all the `rewardToken` balance of this contract to the `FeeDistributor`\n            feeDistributor.burn(address(rewardToken));\n        }\n    }\n}\n"
    },
    "contracts/mock/MockUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"../interfaces/mock/IERC20MINT.sol\";\n\n// @notice mock contract to swap token\ncontract MockUniswapV3Router is IUniswapV3Router {\n    uint256 public exchangeRate = 1 ether;\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n\n    constructor(IERC20 _tokenA, IERC20 _tokenB) {\n        tokenA = _tokenA;\n        tokenB = _tokenB;\n        IERC20MINT(address(tokenB)).mint(address(this), type(uint256).max / 1000);\n    }\n\n    function exactInput(ExactInputParams calldata params) external payable override returns (uint256 amountOut) {\n        tokenA.transferFrom(msg.sender, address(this), params.amountIn);\n        amountOut = (params.amountIn * exchangeRate) / 1 ether;\n        tokenB.transfer(msg.sender, amountOut);\n    }\n\n    function updateExchangeRate(uint256 newExchangeRate) external {\n        exchangeRate = newExchangeRate;\n    }\n}\n"
    },
    "contracts/interfaces/mock/IERC20MINT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IERC20MINT is IERC20 {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mock/MockCompound.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/external/compound/InterestRateModel.sol\";\nimport \"../interfaces/mock/IERC20MINT.sol\";\n\n// @notice mock contract to lend ERC20 tokens to Compound\ncontract MockCompound is ERC20 {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_300_000;\n\n    IERC20 public token; // Interface for the token\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    // ==================== Parameters =============================\n\n    uint256 public exchangeRate = 1 ether;\n    uint256 public supplyRate = 0.04 ether;\n\n    // ==================== Constructor =============================\n\n    /// @notice stablecoin constructor\n    /// @param name_ of the token lent\n    /// @param symbol_ of the token lent\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address token_\n    ) ERC20(name_, symbol_) {\n        token = IERC20(token_);\n        IERC20MINT(address(token)).mint(address(this), type(uint256).max / 1000);\n    }\n\n    // ==================== Functions =============================\n\n    function mint(uint256 amount) external returns (uint256) {\n        if (amount == 0) {\n            return 1;\n        }\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 amount_ctoken = (amount * 1 ether) / exchangeRate;\n        _mint(msg.sender, amount_ctoken);\n        emit Minting(msg.sender, msg.sender, amount_ctoken);\n        // you need to transfer first between the person and the other the token involved\n        return 0;\n        //emit Minting(account, msg.sender, amount);\n    }\n\n    function redeem(uint256 amount) external returns (uint256) {\n        burn(msg.sender, amount);\n        uint256 amount_token = (amount * exchangeRate) / 1 ether;\n        token.safeTransfer(msg.sender, amount_token);\n        return (amount_token);\n        //emit Minting(account, msg.sender, amount);\n    }\n\n    function redeemUnderlying(uint256 amount) external returns (uint256) {\n        if (amount == 0) {\n            return 1;\n        }\n        uint256 amount_cToken = (amount * 1 ether) / exchangeRate;\n        burn(msg.sender, amount_cToken);\n        uint256 amount_token = (amount_cToken * exchangeRate) / 1 ether;\n        token.safeTransfer(msg.sender, amount_token);\n        return 0;\n    }\n\n    function balanceOfUnderlying(address owner) external view returns (uint256) {\n        return (this.balanceOf(owner) * exchangeRate) / 1 ether;\n    }\n\n    function underlying() external view returns (address) {\n        return address(token);\n    }\n\n    function getSupplyRate(\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) external view returns (uint256) {\n        return supplyRate / BLOCKS_PER_YEAR;\n    }\n\n    function supplyRatePerBlock() external view returns (uint256) {\n        return supplyRate / BLOCKS_PER_YEAR;\n    }\n\n    function exchangeRateCurrent() external returns (uint256) {\n        return exchangeRate;\n    }\n\n    function exchangeRateStored() external view returns (uint256) {\n        return exchangeRate;\n    }\n\n    function interestRateModel() external view returns (InterestRateModel) {\n        return InterestRateModel(address(this));\n    }\n\n    function totalReserves() external view returns (uint256) {\n        return totalSupply();\n    }\n\n    function reserveFactorMantissa() external view returns (uint256) {\n        return uint256(0);\n    }\n\n    function totalBorrows() external view returns (uint256) {\n        return uint256(0);\n    }\n\n    function updateSupplyRate(uint256 newSupplyRate) external {\n        supplyRate = newSupplyRate;\n    }\n\n    function updateExchangeRate(uint256 newExchangeRate) external {\n        exchangeRate = newExchangeRate;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface InterestRateModel {\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n\n    // Rinkeby function\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 _reserves\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/genericLender/GenericCompoundRinkebyETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/compound/CEtherI.sol\";\nimport \"../interfaces/external/compound/InterestRateModel.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\ninterface IWETH is IERC20 {\n    function withdraw(uint256 wad) external;\n\n    function deposit() external payable;\n}\n\n/// @title GenericCompound\n/// @author Forked from https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n/// @notice A contract to lend any ERC20 to Compound\n/// @dev This contract is the Rinkeby version of `GenericCompound`, it differs in the `apr` function\ncontract GenericCompoundRinkebyETH is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_300_000;\n\n    // ==================== References to contracts =============================\n\n    address public uniswapRouter;\n    address public comp;\n    CEtherI public cToken;\n\n    // ==================== Parameters =============================\n\n    bytes public path;\n    uint256 public minCompToSell = 0.5 ether;\n\n    // ============================= Constructor =============================\n\n    /// @notice Constructor of the GenericLenderBase\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _uniswapRouter Uniswap router interface to swap reward tokens\n    /// @param _comp Address of the comp token\n    /// @param _path Bytes to encode the swap from comp to want\n    /// @param _cToken Address of the cToken\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    constructor(\n        address _strategy,\n        string memory name,\n        address _uniswapRouter,\n        address _comp,\n        bytes memory _path,\n        address _cToken,\n        address[] memory governorList,\n        address guardian\n    ) GenericLenderBase(_strategy, name, governorList, guardian) {\n        require(address(_comp) != address(0) && address(_strategy) != address(0), \"0\");\n        uniswapRouter = _uniswapRouter;\n        comp = _comp;\n        path = _path;\n        cToken = CEtherI(_cToken);\n        IERC20(comp).safeApprove(address(_uniswapRouter), type(uint256).max);\n    }\n\n    // ===================== External Strategy Functions ===========================\n\n    /// @notice Deposits the current balance to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = IWETH(address(want)).balanceOf(address(this));\n        IWETH(address(want)).withdraw(balance);\n        cToken.mint{ value: balance }();\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount The amount the caller wants to withdraw\n    /// @return The amounts actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible\n    /// @return Whether everything was withdrawn or not\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ============================= External View Functions =============================\n\n    /// @notice Helper function to get the current total of assets managed by the lender.\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @notice Helper function the current balance of cTokens\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = (currentCr * cToken.exchangeRateStored()) / 1e18;\n        }\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by a factor\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// @param amount The amount to add to the lending platform\n    // solhint-disable-next-line no-unused-vars\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        // Rinkeby version\n        return _apr();\n    }\n\n    /// @notice Check if any assets is currently managed by this contract\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0 || IWETH(address(want)).balanceOf(address(this)) > 0;\n    }\n\n    // ============================= Governance =============================\n\n    /// @notice Sets the path for the swap of COMP tokens\n    /// @param _path New path\n    function setPath(bytes memory _path) external onlyRole(GUARDIAN_ROLE) {\n        path = _path;\n    }\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the poolManager\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or the amount withdrawn\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        // Don't care about errors here. we want to exit what we can\n        cToken.redeemUnderlying(amount);\n        IWETH(address(want)).withdraw(address(this).balance);\n        want.safeTransfer(address(poolManager), IWETH(address(want)).balanceOf(address(this)));\n    }\n\n    // ============================= Internal Functions =============================\n\n    /// @notice See 'apr'\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock() * BLOCKS_PER_YEAR;\n    }\n\n    /// @notice See 'nav'\n    function _nav() internal view returns (uint256) {\n        return IWETH(address(want)).balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See 'withdraw'\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = IWETH(address(want)).balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                require(cToken.redeemUnderlying(toWithdraw) == 0, \"redeemUnderlying fail\");\n                IWETH(address(want)).deposit{ value: address(this).balance }();\n            } else {\n                //take all we can\n                require(cToken.redeemUnderlying(liquidity) == 0, \"redeemUnderlying fail\");\n                IWETH(address(want)).deposit{ value: address(this).balance }();\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Claims and swaps to Uniswap the Comp earned\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            IUniswapV3Router(uniswapRouter).exactInput(\n                ExactInputParams(path, address(this), block.timestamp, _comp, uint256(0))\n            );\n        }\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n\n    /// @notice In case ETH is required for some transactions\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/external/compound/CEtherI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CEtherI is CTokenI {\n    function mint() external payable;\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n}\n"
    },
    "contracts/genericLender/GenericLenderBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IGenericLender.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\n/// @title GenericLenderBase\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/tree/master/contracts/GenericLender\n/// @notice A base contract to build contracts to lend assets\nabstract contract GenericLenderBase is IGenericLender, AccessControl {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    string public override lenderName;\n\n    // ============================= References to contracts =============================\n\n    /// @notice Reference to the protocol's collateral poolManager\n    IPoolManager public poolManager;\n\n    /// @notice Reference to the `Strategy`\n    address public override strategy;\n\n    /// @notice Reference to the token lent\n    IERC20 public want;\n\n    // ============================= Constructor =============================\n\n    /// @notice Constructor of the `GenericLenderBase`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    constructor(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian\n    ) {\n        strategy = _strategy;\n        // The corresponding `PoolManager` is inferred from the `Strategy`\n        poolManager = IPoolManager(IStrategy(strategy).poolManager());\n        want = IERC20(poolManager.token());\n        lenderName = _name;\n\n        _setupRole(GUARDIAN_ROLE, address(poolManager));\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(STRATEGY_ROLE, _strategy);\n        _setRoleAdmin(GUARDIAN_ROLE, STRATEGY_ROLE);\n        _setRoleAdmin(STRATEGY_ROLE, GUARDIAN_ROLE);\n\n        want.safeApprove(_strategy, type(uint256).max);\n    }\n\n    // ============================= Governance =============================\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    /// @notice\n    /// Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this poolManager.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external override onlyRole(GUARDIAN_ROLE) {\n        address[] memory __protectedTokens = _protectedTokens();\n        for (uint256 i = 0; i < __protectedTokens.length; i++) require(_token != __protectedTokens[i], \"93\");\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/CTokenI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\nimport \"./InterestRateModel.sol\";\n\ninterface CTokenI {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function interestRateModel() external view returns (InterestRateModel);\n\n    function totalReserves() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGenericLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IGenericLender\n/// @author Yearn with slight modifications from Angle Core Team\n/// @dev Interface for the `GenericLender` contract, the base interface for contracts interacting\n/// with lending and yield farming platforms\ninterface IGenericLender is IAccessControl {\n    function lenderName() external view returns (string memory);\n\n    function nav() external view returns (uint256);\n\n    function strategy() external view returns (address);\n\n    function apr() external view returns (uint256);\n\n    function weightedApr() external view returns (uint256);\n\n    function withdraw(uint256 amount) external returns (uint256);\n\n    function emergencyWithdraw(uint256 amount) external;\n\n    function deposit() external;\n\n    function withdrawAll() external returns (bool);\n\n    function hasAssets() external view returns (bool);\n\n    function aprAfterDeposit(uint256 amount) external view returns (uint256);\n\n    function sweep(address _token, address to) external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IStrategy\n/// @author Inspired by Yearn with slight changes from Angle Core Team\n/// @notice Interface for yield farming strategies\ninterface IStrategy is IAccessControl {\n    function estimatedAPR() external view returns (uint256);\n\n    function poolManager() external view returns (address);\n\n    function want() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function estimatedTotalAssets() external view returns (uint256);\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    function withdraw(uint256 _amountNeeded) external returns (uint256 amountFreed, uint256 _loss);\n\n    function setEmergencyExit() external;\n\n    function addGuardian(address _guardian) external;\n\n    function revokeGuardian(address _guardian) external;\n}\n"
    },
    "contracts/genericLender/GenericCompoundRinkeby.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/compound/CErc20I.sol\";\nimport \"../interfaces/external/compound/InterestRateModel.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/// @title GenericCompound\n/// @author Forked from https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n/// @notice A contract to lend any ERC20 to Compound\n/// @dev This contract is the Rinkeby version of `GenericCompound`, it differs in the `apr` function\ncontract GenericCompoundRinkeby is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_300_000;\n\n    // ==================== References to contracts =============================\n\n    address public uniswapRouter;\n    address public comp;\n    CErc20I public cToken;\n\n    // ==================== Parameters =============================\n\n    bytes public path;\n    uint256 public minCompToSell = 0.5 ether;\n\n    // ============================= Constructor =============================\n\n    /// @notice Constructor of the GenericLenderBase\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _uniswapRouter Uniswap router interface to swap reward tokens\n    /// @param _comp Address of the comp token\n    /// @param _path Bytes to encode the swap from comp to want\n    /// @param _cToken Address of the cToken\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    constructor(\n        address _strategy,\n        string memory name,\n        address _uniswapRouter,\n        address _comp,\n        bytes memory _path,\n        address _cToken,\n        address[] memory governorList,\n        address guardian\n    ) GenericLenderBase(_strategy, name, governorList, guardian) {\n        require(address(_comp) != address(0) && address(_strategy) != address(0), \"0\");\n        uniswapRouter = _uniswapRouter;\n        comp = _comp;\n        path = _path;\n        cToken = CErc20I(_cToken);\n        require(cToken.underlying() == address(want), \"wrong cToken\");\n        want.safeApprove(_cToken, type(uint256).max);\n        IERC20(comp).safeApprove(address(_uniswapRouter), type(uint256).max);\n    }\n\n    // ===================== External Strategy Functions ===========================\n\n    /// @notice Deposits the current balance to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        require(cToken.mint(balance) == 0, \"mint fail\");\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount The amount the caller wants to withdraw\n    /// @return The amounts actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible\n    /// @return Whether everything was withdrawn or not\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ============================= External View Functions =============================\n\n    /// @notice Helper function to get the current total of assets managed by the lender.\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @notice Helper function the current balance of cTokens\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = (currentCr * cToken.exchangeRateStored()) / 1e18;\n        }\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by a factor\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// @param amount The amount to add to the lending platform\n    // solhint-disable-next-line no-unused-vars\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        // Rinkeby version\n        return _apr();\n    }\n\n    /// @notice Check if any assets is currently managed by this contract\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    // ============================= Governance =============================\n\n    /// @notice Sets the path for the swap of COMP tokens\n    /// @param _path New path\n    function setPath(bytes memory _path) external onlyRole(GUARDIAN_ROLE) {\n        path = _path;\n    }\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the poolManager\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or the amount withdrawn\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        // Don't care about errors here. we want to exit what we can\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    // ============================= Internal Functions =============================\n\n    /// @notice See 'apr'\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock() * BLOCKS_PER_YEAR;\n    }\n\n    /// @notice See 'nav'\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See 'withdraw'\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                require(cToken.redeemUnderlying(toWithdraw) == 0, \"redeemUnderlying fail\");\n            } else {\n                //take all we can\n                require(cToken.redeemUnderlying(liquidity) == 0, \"redeemUnderlying fail\");\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Claims and swaps to Uniswap the Comp earned\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            IUniswapV3Router(uniswapRouter).exactInput(\n                ExactInputParams(path, address(this), block.timestamp, _comp, uint256(0))\n            );\n        }\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}\n"
    },
    "contracts/interfaces/external/compound/CErc20I.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CErc20I is CTokenI {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./CTokenI.sol\";\n\ninterface IComptroller {\n    function compSupplySpeeds(address cToken) external view returns (uint256);\n\n    function claimComp(\n        address[] memory holders,\n        CTokenI[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n}\n"
    },
    "contracts/mock/MockComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/compound/IComptroller.sol\";\n\n/// @notice Mock contract to get access to the supply speed\ncontract MockComptroller is IComptroller {\n    uint256 public price;\n\n    constructor(uint256 _price) {\n        price = _price;\n    }\n\n    function compSupplySpeeds(address) external view override returns (uint256) {\n        return price;\n    }\n\n    function claimComp(\n        address[] memory,\n        CTokenI[] memory,\n        bool,\n        bool\n    ) external override {\n        return;\n    }\n\n    function setPrice(uint256 _price) external {\n        price = _price;\n    }\n}\n"
    },
    "contracts/genericLender/GenericCompound.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/compound/CErc20I.sol\";\nimport \"../interfaces/external/compound/IComptroller.sol\";\nimport \"../interfaces/external/compound/InterestRateModel.sol\";\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/// @title GenericCompound\n/// @author Forker from here: https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericCompound.sol\n/// @notice A contract to lend any ERC20 to Compound\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event PathUpdated(bytes _path);\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_350_000;\n\n    // ==================== References to contracts =============================\n\n    CErc20I public immutable cToken;\n    address public immutable comp;\n    IComptroller public immutable comptroller;\n    IUniswapV3Router public immutable uniswapV3Router;\n    // Used to get the `want` price of the AAVE token\n    IUniswapV2Router public immutable uniswapV2Router;\n\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    // ==================== Parameters =============================\n\n    bytes public path;\n    uint256 public minCompToSell = 0.5 ether;\n\n    // ============================= Constructor =============================\n\n    /// @notice Constructor of the `GenericCompound`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _path Bytes to encode the swap from `comp` to `want`\n    /// @param _cToken Address of the cToken\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    constructor(\n        address _strategy,\n        string memory name,\n        IUniswapV3Router _uniswapV3Router,\n        IUniswapV2Router _uniswapV2Router,\n        IComptroller _comptroller,\n        address _comp,\n        bytes memory _path,\n        address _cToken,\n        address[] memory governorList,\n        address guardian\n    ) GenericLenderBase(_strategy, name, governorList, guardian) {\n        // This transaction is going to revert if `_strategy`, `_comp` or `_cToken` are equal to the zero address\n        require(\n            address(_uniswapV2Router) != address(0) &&\n                address(_uniswapV3Router) != address(0) &&\n                address(_comptroller) != address(0),\n            \"0\"\n        );\n        path = _path;\n        uniswapV3Router = _uniswapV3Router;\n        uniswapV2Router = _uniswapV2Router;\n        comptroller = _comptroller;\n        comp = _comp;\n        cToken = CErc20I(_cToken);\n        require(CErc20I(_cToken).underlying() == address(want), \"wrong cToken\");\n        want.safeApprove(_cToken, type(uint256).max);\n        IERC20(_comp).safeApprove(address(_uniswapV3Router), type(uint256).max);\n    }\n\n    // ===================== External Strategy Functions ===========================\n\n    /// @notice Deposits the current balance of the contract to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        require(cToken.mint(balance) == 0, \"mint fail\");\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount The amount the caller wants to withdraw\n    /// @return Amount actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible from the lending platform\n    /// @return Whether everything was withdrawn or not\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ============================= External View Functions =============================\n\n    /// @notice Helper function to get the current total of assets managed by the lender.\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @notice Helper function the current balance of cTokens\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = (currentCr * cToken.exchangeRateStored()) / 1e18;\n        }\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by a factor\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// of `amount`\n    /// @param amount Amount to add to the lending platform, and that we want to take into account\n    /// in the apr computation\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        // The supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior + amount, borrows, reserves, reserverFactor);\n        // Adding the yield from comp\n        return supplyRate * BLOCKS_PER_YEAR + _incentivesRate(amount);\n    }\n\n    /// @notice Check if assets are currently managed by this contract\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    // ============================= Governance =============================\n\n    /// @notice Sets the path for the swap of `comp` tokens\n    /// @param _path New path\n    function setPath(bytes memory _path) external onlyRole(GUARDIAN_ROLE) {\n        path = _path;\n        emit PathUpdated(_path);\n    }\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the `PoolManager`\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or if the amount withdrawn is correct\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        // Do not care about errors here, what is important is to withdraw what is possible\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    // ============================= Internal Functions =============================\n\n    /// @notice See `apr`\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock() * BLOCKS_PER_YEAR + _incentivesRate(0);\n    }\n\n    /// @notice See `nav`\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            // Can't withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n\n            if (toWithdraw <= liquidity) {\n                // We can take all\n                require(cToken.redeemUnderlying(toWithdraw) == 0, \"redeemUnderlying fail\");\n            } else {\n                // Take all we can\n                require(cToken.redeemUnderlying(liquidity) == 0, \"redeemUnderlying fail\");\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Claims and swaps from Uniswap the `comp` earned\n    function _disposeOfComp() internal {\n        address[] memory holders = new address[](1);\n        CTokenI[] memory cTokens = new CTokenI[](1);\n        holders[0] = address(this);\n        cTokens[0] = CTokenI(address(cToken));\n        comptroller.claimComp(holders, cTokens, false, true);\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            uniswapV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, _comp, uint256(0)));\n        }\n    }\n\n    /// @notice Calculates APR from Compound's Liquidity Mining Program\n    /// @param amountToAdd Amount to add to the `totalSupplyInWant` (for the `aprAfterDeposit` function)\n    function _incentivesRate(uint256 amountToAdd) internal view returns (uint256) {\n        uint256 supplySpeed = comptroller.compSupplySpeeds(address(cToken));\n        uint256 totalSupplyInWant = (cToken.totalSupply() * cToken.exchangeRateStored()) / 1e18 + amountToAdd;\n        // `supplySpeed` is in `COMP` unit -> the following operation is going to put it in `want` unit\n        supplySpeed = _comptoWant(supplySpeed);\n        uint256 incentivesRate;\n        // Added for testing purposes and to handle the edge case where there is nothing left in a market\n        if (totalSupplyInWant == 0) {\n            incentivesRate = supplySpeed * BLOCKS_PER_YEAR;\n        } else {\n            // `incentivesRate` is expressed in base 18 like all APR\n            incentivesRate = (supplySpeed * BLOCKS_PER_YEAR * 1e18) / totalSupplyInWant;\n        }\n        return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n    }\n\n    /// @notice Estimates the value of `_amount` AAVE tokens\n    /// @param _amount Amount of comp to compute the `want` price of\n    /// @dev This function uses a UniswapV2 oracle to easily compute the price (which is not feasible\n    /// with UniswapV3)\n    function _comptoWant(uint256 _amount) internal view returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n        // We use a different path when trying to get the price of the AAVE in `want`\n        address[] memory pathPrice;\n\n        if (address(want) == address(WETH)) {\n            pathPrice = new address[](2);\n            pathPrice[0] = address(comp);\n            pathPrice[1] = address(want);\n        } else {\n            pathPrice = new address[](3);\n            pathPrice[0] = address(comp);\n            pathPrice[1] = address(WETH);\n            pathPrice[2] = address(want);\n        }\n\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(_amount, pathPrice); // APRs are in 1e18\n        return amounts[amounts.length - 1];\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}\n"
    },
    "contracts/strategies/BaseStrategyEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IPoolManager.sol\";\n\n/// @title BaseStrategyEvents\n/// @author Angle Core Team\n/// @notice Events used in the abstract `BaseStrategy` contract\ncontract BaseStrategyEvents {\n    // So indexers can keep track of this\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n\n    event UpdatedMinReportDelayed(uint256 delay);\n\n    event UpdatedMaxReportDelayed(uint256 delay);\n\n    event UpdatedDebtThreshold(uint256 debtThreshold);\n\n    event UpdatedRewards(address rewards);\n\n    event UpdatedIsRewardActivated(bool activated);\n\n    event UpdatedRewardAmountAndMinimumAmountMoved(uint256 _rewardAmount, uint256 _minimumAmountMoved);\n\n    event EmergencyExitActivated();\n}\n"
    },
    "contracts/stableMaster/StableMasterEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICollateralSettler.sol\";\nimport \"../interfaces/ICore.sol\";\nimport \"../interfaces/IFeeManager.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IPerpetualManager.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/ISanToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\n\nimport \"../utils/FunctionUtils.sol\";\nimport \"../utils/PausableMapUpgradeable.sol\";\n\n/// @title StableMasterEvents\n/// @author Angle Core Team\n/// @notice `StableMaster` is the contract handling all the collateral types accepted for a given stablecoin\n/// It does all the accounting and is the point of entry in the protocol for stable holders and seekers as well as SLPs\n/// @dev This file contains all the events of the `StableMaster` contract\ncontract StableMasterEvents {\n    event SanRateUpdated(address indexed _token, uint256 _newSanRate);\n\n    event StocksUsersUpdated(address indexed _poolManager, uint256 _stocksUsers);\n\n    event MintedStablecoins(address indexed _poolManager, uint256 amount, uint256 amountForUserInStable);\n\n    event BurntStablecoins(address indexed _poolManager, uint256 amount, uint256 redeemInC);\n\n    // ============================= Governors =====================================\n\n    event CollateralDeployed(\n        address indexed _poolManager,\n        address indexed _perpetualManager,\n        address indexed _sanToken,\n        address _oracle\n    );\n\n    event CollateralRevoked(address indexed _poolManager);\n\n    // ========================= Parameters update =================================\n\n    event OracleUpdated(address indexed _poolManager, address indexed _oracle);\n\n    event FeeManagerUpdated(address indexed _poolManager, address indexed newFeeManager);\n\n    event CapOnStableAndMaxInterestsUpdated(\n        address indexed _poolManager,\n        uint256 _capOnStableMinted,\n        uint256 _maxInterestsDistributed\n    );\n\n    event SLPsIncentivesUpdated(address indexed _poolManager, uint64 _feesForSLPs, uint64 _interestsForSLPs);\n\n    event FeeArrayUpdated(address indexed _poolManager, uint64[] _xFee, uint64[] _yFee, uint8 _type);\n}\n"
    },
    "contracts/external/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IAccessControl.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControlUpgradeable`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, IAccessControl {\n    function __AccessControl_init() internal initializer {\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {}\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == msg.sender, \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/ICollateralSettler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title ICollateralSettler\n/// @author Angle Core Team\n/// @notice Interface for the collateral settlement contracts\ninterface ICollateralSettler {\n    function triggerSettlement(\n        uint256 _oracleValue,\n        uint256 _sanRate,\n        uint256 _stocksUsers\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IStableMaster.sol\";\n\n/// @title ICore\n/// @author Angle Core Team\n/// @dev Interface for the functions of the `Core` contract\ninterface ICore {\n    function revokeStableMaster(address stableMaster) external;\n\n    function addGovernor(address _governor) external;\n\n    function removeGovernor(address _governor) external;\n\n    function setGuardian(address _guardian) external;\n\n    function revokeGuardian() external;\n\n    function governorList() external view returns (address[] memory);\n\n    function stablecoinList() external view returns (address[] memory);\n\n    function guardian() external view returns (address);\n}\n"
    },
    "contracts/utils/FunctionUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title FunctionUtils\n/// @author Angle Core Team\n/// @notice Contains all the utility functions that are needed in different places of the protocol\n/// @dev Functions in this contract should typically be pure functions\n/// @dev This contract is voluntarily a contract and not a library to save some gas cost every time it is used\ncontract FunctionUtils {\n    /// @notice Base that is used to compute ratios and floating numbers\n    uint256 public constant BASE_TOKENS = 10**18;\n    /// @notice Base that is used to define parameters that need to have a floating value (for instance parameters\n    /// that are defined as ratios)\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    /// @notice Computes the value of a linear by part function at a given point\n    /// @param x Point of the function we want to compute\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev The evolution of the linear by part function between two breaking points is linear\n    /// @dev Before the first breaking point and after the last one, the function is constant with a value\n    /// equal to the first or last value of the yArray\n    /// @dev This function is relevant if `x` is between O and `BASE_PARAMS`. If `x` is greater than that, then\n    /// everything will be as if `x` is equal to the greater element of the `xArray`\n    function _piecewiseLinear(\n        uint64 x,\n        uint64[] memory xArray,\n        uint64[] memory yArray\n    ) internal pure returns (uint64) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            if (yArray[upper] > yArray[lower]) {\n                // There is no risk of overflow here as in the product of the difference of `y`\n                // with the difference of `x`, the product is inferior to `BASE_PARAMS**2` which does not\n                // overflow for `uint64`\n                return\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                return\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n        }\n    }\n\n    /// @notice Checks if the input arrays given by governance to update the fee structure is valid\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev This function is a way to avoid some governance attacks or errors\n    /// @dev The modifier checks if the arrays have a non null length, if their length is the same, if the values\n    /// in the `xArray` are in ascending order and if the values in the `xArray` and in the `yArray` are not superior\n    /// to `BASE_PARAMS`\n    modifier onlyCompatibleInputArrays(uint64[] memory xArray, uint64[] memory yArray) {\n        require(xArray.length == yArray.length && xArray.length > 0, \"5\");\n        for (uint256 i = 0; i <= yArray.length - 1; i++) {\n            require(yArray[i] <= uint64(BASE_PARAMS) && xArray[i] <= uint64(BASE_PARAMS), \"6\");\n            if (i > 0) {\n                require(xArray[i] > xArray[i - 1], \"7\");\n            }\n        }\n        _;\n    }\n\n    /// @notice Checks if the new value given for the parameter is consistent (it should be inferior to 1\n    /// if it corresponds to a ratio)\n    /// @param fees Value of the new parameter to check\n    modifier onlyCompatibleFees(uint64 fees) {\n        require(fees <= BASE_PARAMS, \"4\");\n        _;\n    }\n\n    /// @notice Checks if the new address given is not null\n    /// @param newAddress Address to check\n    /// @dev Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation\n    modifier zeroCheck(address newAddress) {\n        require(newAddress != address(0), \"0\");\n        _;\n    }\n}\n"
    },
    "contracts/utils/PausableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title PausableMap\n/// @author Angle Core Team after a fork from OpenZeppelin's similar Pausable Contracts\n/// @notice Contract module which allows children to implement an emergency stop\n/// mechanism that can be triggered by an authorized account.\n/// @notice It generalizes Pausable from OpenZeppelin by allowing to specify a bytes32 that\n/// should be stopped\n/// @dev This module is used through inheritance\n/// @dev In Angle's protocol, this contract is mainly used in `StableMasterFront`\n/// to prevent SLPs and new stable holders from coming in\n/// @dev The modifiers `whenNotPaused` and `whenPaused` from the original OpenZeppelin contracts were removed\n/// to save some space and because they are not used in the `StableMaster` contract where this contract\n/// is imported\ncontract PausableMapUpgradeable {\n    /// @dev Emitted when the pause is triggered for `name`\n    event Paused(bytes32 name);\n\n    /// @dev Emitted when the pause is lifted for `name`\n    event Unpaused(bytes32 name);\n\n    /// @dev Mapping between a name and a boolean representing the paused state\n    mapping(bytes32 => bool) public paused;\n\n    /// @notice Triggers stopped state for `name`\n    /// @param name Name for which to pause the contract\n    /// @dev The contract must not be paused for `name`\n    function _pause(bytes32 name) internal {\n        require(!paused[name], \"18\");\n        paused[name] = true;\n        emit Paused(name);\n    }\n\n    /// @notice Returns to normal state for `name`\n    /// @param name Name for which to unpause the contract\n    /// @dev The contract must be paused for `name`\n    function _unpause(bytes32 name) internal {\n        require(paused[name], \"19\");\n        paused[name] = false;\n        emit Unpaused(name);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/sigp/PausableMapUpgradeableWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/PausableMapUpgradeable.sol\";\n\n/// @title PausableMapUpgradeableWrapper\n/// @author Sigma Prime\n/// @notice Wrapper contract used for testing developed by Sigma Prime\ncontract PausableMapUpgradeableWrapper is PausableMapUpgradeable {\n    function pause(bytes32 name) public {\n        _pause(name);\n    }\n\n    function unpause(bytes32 name) public {\n        _unpause(name);\n    }\n}\n"
    },
    "contracts/sigp/FunctionUtilsWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/FunctionUtils.sol\";\n\n/// @title FunctionUtilsWrapper\n/// @author Sigma Prime\n/// @notice Wrapper contract used for testing developed by Sigma Prime\ncontract FunctionUtilsWrapper is FunctionUtils {\n    function piecewiseLinear(\n        uint64 x,\n        uint64[] memory xArray,\n        uint64[] memory yArray\n    ) public pure returns (uint64 y) {\n        y = _piecewiseLinear(x, xArray, yArray);\n    }\n\n    function checkCompatibleInputArrays(uint64[] memory xArray, uint64[] memory yArray)\n        public\n        view\n        onlyCompatibleInputArrays(xArray, yArray)\n        returns (bool)\n    {\n        return true;\n    }\n\n    function checkCompatibleFees(uint64 fees) public view onlyCompatibleFees(fees) returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/poolManager/PoolManagerEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IFeeManager.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/ISanToken.sol\";\nimport \"../interfaces/IPerpetualManager.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\nimport \"../utils/FunctionUtils.sol\";\n\n/// @title PoolManagerEvents\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This contract contains all the events of the `PoolManager` Contract\ncontract PoolManagerEvents {\n    event FeesDistributed(uint256 amountDistributed);\n\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    event StrategyAdded(address indexed strategy, uint256 debtRatio);\n\n    event InterestsForSurplusUpdated(uint64 _interestsForSurplus);\n\n    event SurplusConverterUpdated(address indexed newSurplusConverter, address indexed oldSurplusConverter);\n\n    event StrategyRevoked(address indexed strategy);\n\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 totalDebt\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/perpetualManager/PerpetualManagerEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IFeeManager.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IPerpetualManager.sol\";\nimport \"../interfaces/IRewardsDistributor.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\nimport \"../utils/FunctionUtils.sol\";\n\n// Used in the `forceCashOutPerpetuals` function to store owners of perpetuals which have been force cashed\n// out, along with the amount associated to it\nstruct Pairs {\n    address owner;\n    uint256 netCashOutAmount;\n}\n\n/// @title PerpetualManagerEvents\n/// @author Angle Core Team\n/// @notice `PerpetualManager` is the contract handling all the Hedging Agents perpetuals\n/// @dev There is one `PerpetualManager` contract per pair stablecoin/collateral in the protocol\n/// @dev This file contains all the events of the `PerpetualManager` contract\ncontract PerpetualManagerEvents {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event PerpetualUpdated(uint256 _perpetualID, uint256 _margin);\n\n    event PerpetualOpened(uint256 _perpetualID, uint256 _entryRate, uint256 _margin, uint256 _committedAmount);\n\n    event PerpetualClosed(uint256 _perpetualID, uint256 _closeAmount);\n\n    event PerpetualsForceClosed(uint256[] perpetualIDs, Pairs[] ownerAndCashOut, address keeper, uint256 reward);\n\n    event KeeperTransferred(address keeperAddress, uint256 liquidationFees);\n\n    // ============================== Parameters ===================================\n\n    event BaseURIUpdated(string _baseURI);\n\n    event LockTimeUpdated(uint64 _lockTime);\n\n    event KeeperFeesCapUpdated(uint256 _keeperFeesLiquidationCap, uint256 _keeperFeesClosingCap);\n\n    event TargetAndLimitHAHedgeUpdated(uint64 _targetHAHedge, uint64 _limitHAHedge);\n\n    event BoundsPerpetualUpdated(uint64 _maxLeverage, uint64 _maintenanceMargin);\n\n    event HAFeesUpdated(uint64[] _xHAFees, uint64[] _yHAFees, uint8 deposit);\n\n    event KeeperFeesLiquidationRatioUpdated(uint64 _keeperFeesLiquidationRatio);\n\n    event KeeperFeesClosingUpdated(uint64[] xKeeperFeesClosing, uint64[] yKeeperFeesClosing);\n\n    // =============================== Reward ======================================\n\n    event RewardAdded(uint256 _reward);\n\n    event RewardPaid(address indexed _user, uint256 _reward);\n\n    event RewardsDistributionUpdated(address indexed _rewardsDistributor);\n\n    event RewardsDistributionDurationUpdated(uint256 _rewardsDuration, address indexed _rewardsDistributor);\n\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IStakingRewards.sol\";\n\n/// @title IRewardsDistributor\n/// @author Angle Core Team, inspired from Fei protocol\n/// (https://github.com/fei-protocol/fei-protocol-core/blob/master/contracts/staking/IRewardsDistributor.sol)\n/// @notice Rewards Distributor interface\ninterface IRewardsDistributor {\n    // ========================= Public Parameter Getter ===========================\n\n    function rewardToken() external view returns (IERC20);\n\n    // ======================== External User Available Function ===================\n\n    function drip(IStakingRewards stakingContract) external returns (uint256);\n\n    // ========================= Governor Functions ================================\n\n    function governorWithdrawRewardToken(uint256 amount, address governance) external;\n\n    function governorRecover(\n        address tokenAddress,\n        address to,\n        uint256 amount,\n        IStakingRewards stakingContract\n    ) external;\n\n    function setUpdateFrequency(uint256 _frequency, IStakingRewards stakingContract) external;\n\n    function setIncentiveAmount(uint256 _incentiveAmount, IStakingRewards stakingContract) external;\n\n    function setAmountToDistribute(uint256 _amountToDistribute, IStakingRewards stakingContract) external;\n\n    function setDuration(uint256 _duration, IStakingRewards stakingContract) external;\n\n    function setStakingContract(\n        address _stakingContract,\n        uint256 _duration,\n        uint256 _incentiveAmount,\n        uint256 _dripFrequency,\n        uint256 _amountToDistribute\n    ) external;\n\n    function setNewRewardsDistributor(address newRewardsDistributor) external;\n\n    function removeStakingContract(IStakingRewards stakingContract) external;\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IStakingRewardsFunctions\n/// @author Angle Core Team\n/// @notice Interface for the staking rewards contract that interact with the `RewardsDistributor` contract\ninterface IStakingRewardsFunctions {\n    function notifyRewardAmount(uint256 reward) external;\n\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 tokenAmount\n    ) external;\n\n    function setNewRewardsDistribution(address newRewardsDistribution) external;\n}\n\n/// @title IStakingRewards\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables\ninterface IStakingRewards is IStakingRewardsFunctions {\n    function rewardToken() external view returns (IERC20);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/staking/StakingRewardsEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IRewardsDistributor.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n/// @title StakingRewardsEvents\n/// @author Angle Core Team\n/// @notice All the events used in `StakingRewards` contract\ncontract StakingRewardsEvents {\n    event RewardAdded(uint256 reward);\n\n    event Staked(address indexed user, uint256 amount);\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    event RewardPaid(address indexed user, uint256 reward);\n\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n\n    event RewardsDistributionUpdated(address indexed _rewardsDistribution);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/RewardsDistributorEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IRewardsDistributor.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\n/// @title RewardsDistributorEvents\n/// @author Angle Core Team\n/// @notice All the events used in `RewardsDistributor` contract\ncontract RewardsDistributorEvents {\n    event Dripped(address indexed _caller, uint256 _amount, address _stakingContract);\n\n    event RewardTokenWithdrawn(uint256 _amount);\n\n    event FrequencyUpdated(uint256 _frequency, address indexed _stakingContract);\n\n    event IncentiveUpdated(uint256 _incentiveAmount, address indexed _stakingContract);\n\n    event AmountToDistributeUpdated(uint256 _amountToDistribute, address indexed _stakingContract);\n\n    event DurationUpdated(uint256 _duration, address indexed _stakingContract);\n\n    event NewStakingContract(address indexed _stakingContract);\n\n    event DeletedStakingContract(address indexed stakingContract);\n\n    event NewRewardsDistributor(address indexed newRewardsDistributor);\n}\n"
    },
    "contracts/oracle/utils/UniswapUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"../../external/AccessControl.sol\";\n\nimport \"../../utils/OracleMath.sol\";\n\n/// @title UniswapUtils\n/// @author Angle Core Team\n/// @notice Utility contract that is used in the Uniswap module contract\nabstract contract UniswapUtils is AccessControl, OracleMath {\n    // The parameters below are common among the different Uniswap modules contracts\n\n    /// @notice Time weigthed average window that should be used for each Uniswap rate\n    /// It is mainly going to be 5 minutes in the protocol\n    uint32 public twapPeriod;\n\n    // Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE_UNISWAP = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Gets a quote for an amount of in-currency using UniswapV3 TWAP and converts this\n    /// amount to out-currency\n    /// @param quoteAmount The amount to convert in the out-currency\n    /// @param pool UniswapV3 pool to query\n    /// @param isUniMultiplied Whether the rate corresponding to the Uniswap pool should be multiplied or divided\n    /// @return The value of the `quoteAmount` expressed in out-currency\n    function _readUniswapPool(\n        uint256 quoteAmount,\n        IUniswapV3Pool pool,\n        uint8 isUniMultiplied\n    ) internal view returns (uint256) {\n        uint32[] memory secondAgos = new uint32[](2);\n\n        secondAgos[0] = twapPeriod;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = pool.observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        int24 timeWeightedAverageTick = int24(tickCumulativesDelta / int32(twapPeriod));\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(twapPeriod)) != 0))\n            timeWeightedAverageTick--;\n\n        // Computing the `quoteAmount` from the ticks obtained from Uniswap\n        return _getQuoteAtTick(timeWeightedAverageTick, quoteAmount, isUniMultiplied);\n    }\n\n    /// @notice Changes the TWAP period\n    /// @param _twapPeriod New window to compute the TWAP\n    function changeTwapPeriod(uint32 _twapPeriod) external onlyRole(GUARDIAN_ROLE_UNISWAP) {\n        require(int32(_twapPeriod) > 0, \"99\");\n        twapPeriod = _twapPeriod;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/utils/OracleMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../external/FullMath.sol\";\n\n/// @title OracleMath\n/// @author Forked and adapted by Angle Core Team from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol\n/// @notice Math library for computing prices from ticks\n/// @dev Computes price for ticks of size 1.0001, i.e. sqrt(1.0001^tick). Supports\n/// prices between 2**-128 and 2**128\ncontract OracleMath is FullMath {\n    /// @dev Maximum tick that may be passed to `_getSqrtRatioAtTick` computed from log base 1.0001 of 2**128\n    int24 internal constant _MAX_TICK = 887272;\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param multiply Boolean representing whether the `baseToken` has a lower address than the `quoteToken`\n    /// @return quoteAmount Amount of `quoteToken` received for `baseAmount` of `baseToken`\n    function _getQuoteAtTick(\n        int24 tick,\n        uint256 baseAmount,\n        uint256 multiply\n    ) internal pure returns (uint256 quoteAmount) {\n        uint256 ratio = _getRatioAtTick(tick);\n\n        quoteAmount = (multiply == 1) ? _mulDiv(ratio, baseAmount, 1e18) : _mulDiv(1e18, baseAmount, ratio);\n    }\n\n    /// @notice Calculates 1.0001^tick * in out ERC20 decimals\n    /// @dev Adapted from Uniswap `_getSqrtRatioAtTick` but we don't consider the square root\n    /// anymore but directly the full rate\n    /// @dev Throws if `|tick| > max tick`\n    /// @param tick The input tick for the above formula\n    /// @return rate uint256 representing the ratio of the two assets `(token1/token0) * 10**decimals(token1)`\n    /// at the given tick\n    function _getRatioAtTick(int24 tick) internal pure returns (uint256 rate) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(_MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfff97272373d413259a46990580e213a : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x149b34ee7ac262) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // We need to modify the 96 decimal to be able to convert it to a D256\n        // 2**59 ~ 10**18 (thus we guarantee the same precision) and 128-59 = 69\n        // We retrieve a Q128.59 decimal. --> we have 69 bits free to reach the uint256 limit.\n        // Now, 2**69 >> 10**18 so we are safe in the Decimal conversion.\n\n        uint256 price = uint256((ratio >> 69) + (ratio % (1 << 69) == 0 ? 0 : 1));\n        rate = ((price * 1e18) >> 59);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/external/FullMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev This contract was forked from Uniswap V3's contract `FullMath.sol` available here\n/// https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol\nabstract contract FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function _mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n}\n"
    },
    "contracts/sigp/OracleMathWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/OracleMath.sol\";\n\n/// @title OracleMathWrapper\n/// @author Sigma Prime\n/// @notice Wrapper contract used for testing developed by Sigma Prime\ncontract OracleMathWrapper is OracleMath {\n    function getQuoteAtTick(\n        int24 tick,\n        uint256 baseAmount,\n        uint256 multiply\n    ) public pure returns (uint256) {\n        return _getQuoteAtTick(tick, baseAmount, multiply);\n    }\n\n    function getRatioAtTick(int24 tick) public pure returns (uint256) {\n        return _getRatioAtTick(tick);\n    }\n}\n"
    },
    "contracts/mock/MockOracleMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"../external/FullMath.sol\";\n\n/// @title OracleMath\n/// @notice Math library for computing sqrt prices from ticks and vice versa\n/// @dev Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\n/// @dev Q64.96 numbers mean that the first 64 bits make up the integer part and the 96 remaining make up the\n/// decimal part\ncontract MockOracleMath is FullMath {\n    /// @dev Maximum tick that may be passed to #_getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant _MAX_TICK = 887272;\n\n    /// @notice Calculates 1.0001^tick * in out ERC20 decimals\n    /// @dev Adapted from Uniswap _getSqrtRatioAtTick but we don't consider the square root\n    /// anymore but directly the full rate\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return rate uint256 representing the ratio of the two assets (token1/token0) * decimals(token1)\n    /// at the given tick\n    function _getRatioAtTick(int24 tick) internal pure returns (uint256 rate) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(_MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfff97272373d413259a46990580e213a : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x149b34ee7ac262) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        //We need to modify the 96 decimal to be able to convert it to a D256\n        //2**59 ~ 10**18 (thus we guarantee the same precision) and 128-59 = 69\n        // We retreive a Q128.59 decimal. --> we have 69 bits free to reach the uint256 limit.\n        //Now, 2**69 >> 10**18 so we are safe in the Decimal conversion.\n\n        uint256 price = uint256((ratio >> 69) + (ratio % (1 << 69) == 0 ? 0 : 1));\n        rate = ((price * 1e18) / (1 << 59));\n    }\n\n    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @param period Number of seconds in the past to start calculating time-weighted average\n    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp\n    function _consult(IUniswapV3Pool pool, uint32 period) public view returns (int24 timeWeightedAverageTick) {\n        uint32[] memory secondAgos = new uint32[](2);\n\n        secondAgos[0] = period;\n        secondAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, ) = pool.observe(secondAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\n        assert(int32(period) >= 0);\n        timeWeightedAverageTick = int24(tickCumulativesDelta / int32(period));\n\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) timeWeightedAverageTick--;\n    }\n\n    // ==================== Original function from Uniswap libraries =======================\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param multiply Boolean representing whether the baseToken has a lower address than the quoteToken\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function _getQuoteAtTickAngle(\n        int24 tick,\n        uint256 baseAmount,\n        uint256 multiply\n    ) internal view returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = _getSqrtRatioAtTick(tick);\n\n        // check for a possible overflows when multiplying the square root by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\n            quoteAmount = (multiply == 1)\n                ? _mulDiv(ratioX192, baseAmount, 1 << 192)\n                : _mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = _mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = (multiply == 1)\n                ? _mulDiv(ratioX128, baseAmount, 1 << 128)\n                : _mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function _getQuoteAtTickUniswap(\n        int24 tick,\n        uint256 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal view returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = _getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? _mulDiv(ratioX192, baseAmount, 1 << 192)\n                : _mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = _mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? _mulDiv(ratioX128, baseAmount, 1 << 128)\n                : _mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    /// @dev Throws if |tick| > max tick\n    /// @dev This function has been copied from Uniswap original version\n    function _getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(_MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param multiply Boolean representing whether the baseToken has a lower address than the quoteToken\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function _getQuoteAtTick(\n        int24 tick,\n        uint256 baseAmount,\n        uint256 multiply\n    ) public view returns (uint256 quoteAmount) {\n        uint256 ratio = _getRatioAtTick(tick);\n\n        quoteAmount = (multiply == 1) ? _mulDiv(ratio, baseAmount, 1e18) : _mulDiv(1e18, baseAmount, ratio);\n    }\n}\n"
    },
    "contracts/strategies/StrategyEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./BaseStrategy.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"../interfaces/IGenericLender.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n/// @title StrategyEvents\n/// @author Angle Core Team\n/// @notice Events used in `Strategy` contracts\ncontract StrategyEvents {\n    event AddLender(address indexed lender);\n\n    event RemoveLender(address indexed lender);\n}\n"
    },
    "contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./BaseStrategyEvents.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title BaseStrategy\n/// @author Forked from https://github.com/yearn/yearn-managers/blob/master/contracts/BaseStrategy.sol\n/// @notice `BaseStrategy` implements all of the required functionalities to interoperate\n/// with the `PoolManager` Contract.\n/// @dev This contract should be inherited and the abstract methods implemented to adapt the `Strategy`\n/// to the particular needs it has to create a return.\nabstract contract BaseStrategy is BaseStrategyEvents, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**18;\n    uint256 public constant SECONDSPERYEAR = 31556952;\n\n    /// @notice Role for `PoolManager` only\n    bytes32 public constant POOLMANAGER_ROLE = keccak256(\"POOLMANAGER_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    // ======================== References to contracts ============================\n\n    /// @notice Reference to the protocol's collateral `PoolManager`\n    IPoolManager public poolManager;\n\n    /// @notice Reference to the ERC20 farmed by this strategy\n    IERC20 public want;\n\n    /// @notice Base of the ERC20 token farmed by this strategy\n    uint256 public wantBase;\n\n    //@notice Reference to the ERC20 distributed as a reward by the strategy\n    IERC20 public rewards;\n\n    // ============================ Parameters =====================================\n\n    /// @notice The minimum number of seconds between harvest calls. See\n    /// `setMinReportDelay()` for more details\n    uint256 public minReportDelay;\n\n    /// @notice The maximum number of seconds between harvest calls. See\n    /// `setMaxReportDelay()` for more details\n    uint256 public maxReportDelay;\n\n    /// @notice Use this to adjust the threshold at which running a debt causes a\n    /// harvest trigger. See `setDebtThreshold()` for more details\n    uint256 public debtThreshold;\n\n    /// @notice See note on `setEmergencyExit()`\n    bool public emergencyExit;\n\n    /// @notice The minimum amount moved for a call to `havest` to\n    /// be \"justifiable\". See `setRewardAmountAndMinimumAmountMoved()` for more details\n    uint256 public minimumAmountMoved;\n\n    /// @notice Reward obtained by calling harvest\n    /// @dev If this is null rewards are not currently being distributed\n    uint256 public rewardAmount;\n\n    // ============================ Constructor ====================================\n\n    /// @notice Constructor of the `BaseStrategy`\n    /// @param _poolManager Address of the `PoolManager` lending collateral to this strategy\n    /// @param _rewards  The token given to reward keepers\n    /// @param governorList List of the governor addresses of the protocol\n    /// @param guardian Address of the guardian\n    constructor(\n        address _poolManager,\n        IERC20 _rewards,\n        address[] memory governorList,\n        address guardian\n    ) {\n        poolManager = IPoolManager(_poolManager);\n        want = IERC20(poolManager.token());\n        wantBase = 10**(IERC20Metadata(address(want)).decimals());\n        require(guardian != address(0) && address(_rewards) != address(0), \"0\");\n        // The token given as a reward to keepers should be different from the token handled by the\n        // strategy\n        require(address(_rewards) != address(want), \"92\");\n        rewards = _rewards;\n\n        // Initializing variables\n        minReportDelay = 0;\n        maxReportDelay = 86400;\n        debtThreshold = 100 * BASE;\n        minimumAmountMoved = 0;\n        rewardAmount = 0;\n        emergencyExit = false;\n\n        // AccessControl\n        // Governor is guardian so no need for a governor role\n        // `PoolManager` is guardian as well to allow for more flexibility\n        _setupRole(POOLMANAGER_ROLE, address(_poolManager));\n        for (uint256 i = 0; i < governorList.length; i++) {\n            require(governorList[i] != address(0), \"0\");\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setRoleAdmin(POOLMANAGER_ROLE, POOLMANAGER_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, POOLMANAGER_ROLE);\n\n        // Give `PoolManager` unlimited access (might save gas)\n        want.safeIncreaseAllowance(address(poolManager), type(uint256).max);\n    }\n\n    // ========================== Core functions ===================================\n\n    /// @notice Harvests the Strategy, recognizing any profits or losses and adjusting\n    /// the Strategy's position.\n    /// @dev In the rare case the Strategy is in emergency shutdown, this will exit\n    /// the Strategy's position.\n    /// @dev  When `harvest()` is called, the Strategy reports to the Manager (via\n    /// `poolManager.report()`), so in some cases `harvest()` must be called in order\n    /// to take in profits, to borrow newly available funds from the Manager, or\n    /// otherwise adjust its position. In other cases `harvest()` must be\n    /// called to report to the Manager on the Strategy's position, especially if\n    /// any losses have occurred.\n    /// @dev As keepers may directly profit from this function, there may be front-running problems with miners bots,\n    /// we may have to put an access control logic for this function to only allow white-listed addresses to act\n    /// as keepers for the protocol\n    function harvest() external {\n        uint256 profit = 0;\n        uint256 loss = 0;\n        uint256 debtOutstanding = poolManager.debtOutstanding();\n        uint256 debtPayment = 0;\n        if (emergencyExit) {\n            // Free up as much capital as possible\n            uint256 amountFreed = _liquidateAllPositions();\n            if (amountFreed < debtOutstanding) {\n                loss = debtOutstanding - amountFreed;\n            } else if (amountFreed > debtOutstanding) {\n                profit = amountFreed - debtOutstanding;\n            }\n            debtPayment = debtOutstanding - loss;\n        } else {\n            // Free up returns for Manager to pull\n            (profit, loss, debtPayment) = _prepareReturn(debtOutstanding);\n        }\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\n\n        // Taking into account the rewards to distribute\n        // This should be done before reporting to the `PoolManager`\n        // because the `PoolManager` will update the params.lastReport of the strategy\n        if (rewardAmount > 0) {\n            uint256 lastReport = poolManager.strategies(address(this)).lastReport;\n            if (\n                (block.timestamp - lastReport >= minReportDelay) && // Should not trigger if we haven't waited long enough since previous harvest\n                ((block.timestamp - lastReport >= maxReportDelay) || // If hasn't been called in a while\n                    (debtPayment > debtThreshold) || // If the debt was too high\n                    (loss > 0) || // If some loss occured\n                    (minimumAmountMoved < want.balanceOf(address(this)) + profit)) // If the amount moved was significant\n            ) {\n                rewards.safeTransfer(msg.sender, rewardAmount);\n            }\n        }\n\n        // Allows Manager to take up to the \"harvested\" balance of this contract,\n        // which is the amount it has earned since the last time it reported to\n        // the Manager.\n        poolManager.report(profit, loss, debtPayment);\n\n        // Check if free returns are left, and re-invest them\n        _adjustPosition();\n    }\n\n    /// @notice Withdraws `_amountNeeded` to `poolManager`.\n    /// @param _amountNeeded How much `want` to withdraw.\n    /// @return amountFreed How much `want` withdrawn.\n    /// @return _loss Any realized losses\n    /// @dev This may only be called by the `PoolManager`\n    function withdraw(uint256 _amountNeeded)\n        external\n        onlyRole(POOLMANAGER_ROLE)\n        returns (uint256 amountFreed, uint256 _loss)\n    {\n        // Liquidate as much as possible `want` (up to `_amountNeeded`)\n        (amountFreed, _loss) = _liquidatePosition(_amountNeeded);\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n        want.safeTransfer(msg.sender, amountFreed);\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\n    }\n\n    // ============================ View functions =================================\n\n    /// @notice Provides an accurate estimate for the total amount of assets\n    /// (principle + return) that this Strategy is currently managing,\n    /// denominated in terms of `want` tokens.\n    /// This total should be \"realizable\" e.g. the total value that could\n    /// *actually* be obtained from this Strategy if it were to divest its\n    /// entire position based on current on-chain conditions.\n    /// @return The estimated total assets in this Strategy.\n    /// @dev Care must be taken in using this function, since it relies on external\n    /// systems, which could be manipulated by the attacker to give an inflated\n    /// (or reduced) value produced by this function, based on current on-chain\n    /// conditions (e.g. this function is possible to influence through\n    /// flashloan attacks, oracle manipulations, or other DeFi attack\n    /// mechanisms).\n    function estimatedTotalAssets() public view virtual returns (uint256);\n\n    /// @notice Provides an indication of whether this strategy is currently \"active\"\n    /// in that it is managing an active position, or will manage a position in\n    /// the future. This should correlate to `harvest()` activity, so that Harvest\n    /// events can be tracked externally by indexing agents.\n    /// @return True if the strategy is actively managing a position.\n    function isActive() public view returns (bool) {\n        return estimatedTotalAssets() > 0;\n    }\n\n    /// @notice Provides a signal to the keeper that `harvest()` should be called. The\n    /// keeper will provide the estimated gas cost that they would pay to call\n    /// `harvest()`, and this function should use that estimate to make a\n    /// determination if calling it is \"worth it\" for the keeper. This is not\n    /// the only consideration into issuing this trigger, for example if the\n    /// position would be negatively affected if `harvest()` is not called\n    /// shortly, then this can return `true` even if the keeper might be \"at a\n    /// loss\"\n    /// @return `true` if `harvest()` should be called, `false` otherwise.\n    /// @dev `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\n    /// @dev See `min/maxReportDelay`, `debtThreshold` to adjust the\n    /// strategist-controlled parameters that will influence whether this call\n    /// returns `true` or not. These parameters will be used in conjunction\n    /// with the parameters reported to the Manager (see `params`) to determine\n    /// if calling `harvest()` is merited.\n    /// @dev This function has been tested in a branch different from the main branch\n    function harvestTrigger() external view virtual returns (bool) {\n        StrategyParams memory params = poolManager.strategies(address(this));\n\n        // Should not trigger if we haven't waited long enough since previous harvest\n        if (block.timestamp - params.lastReport < minReportDelay) return false;\n\n        // Should trigger if hasn't been called in a while\n        if (block.timestamp - params.lastReport >= maxReportDelay) return true;\n\n        // If some amount is owed, pay it back\n        // NOTE: Since debt is based on deposits, it makes sense to guard against large\n        //       changes to the value from triggering a harvest directly through user\n        //       behavior. This should ensure reasonable resistance to manipulation\n        //       from user-initiated withdrawals as the outstanding debt fluctuates.\n        uint256 outstanding = poolManager.debtOutstanding();\n\n        if (outstanding > debtThreshold) return true;\n\n        // Check for profits and losses\n        uint256 total = estimatedTotalAssets();\n        // Trigger if we have a loss to report\n\n        if (total + debtThreshold < params.totalStrategyDebt) return true;\n\n        uint256 profit = 0;\n        if (total > params.totalStrategyDebt) profit = total - params.totalStrategyDebt; // We've earned a profit!\n\n        // Otherwise, only trigger if it \"makes sense\" economically (gas cost\n        // is <N% of value moved)\n        uint256 credit = poolManager.creditAvailable();\n\n        return (minimumAmountMoved < credit + profit);\n    }\n\n    // ============================ Internal Functions =============================\n\n    /// @notice Performs any Strategy unwinding or other calls necessary to capture the\n    /// \"free return\" this Strategy has generated since the last time its core\n    /// position(s) were adjusted. Examples include unwrapping extra rewards.\n    /// This call is only used during \"normal operation\" of a Strategy, and\n    /// should be optimized to minimize losses as much as possible.\n    ///\n    /// This method returns any realized profits and/or realized losses\n    /// incurred, and should return the total amounts of profits/losses/debt\n    /// payments (in `want` tokens) for the Manager's accounting (e.g.\n    /// `want.balanceOf(this) >= _debtPayment + _profit`).\n    ///\n    /// `_debtOutstanding` will be 0 if the Strategy is not past the configured\n    /// debt limit, otherwise its value will be how far past the debt limit\n    /// the Strategy is. The Strategy's debt limit is configured in the Manager.\n    ///\n    /// NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\n    ///       It is okay for it to be less than `_debtOutstanding`, as that\n    ///       should only used as a guide for how much is left to pay back.\n    ///       Payments should be made to minimize loss from slippage, debt,\n    ///       withdrawal fees, etc.\n    ///\n    /// See `poolManager.debtOutstanding()`.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        );\n\n    /// @notice Performs any adjustments to the core position(s) of this Strategy given\n    /// what change the Manager made in the \"investable capital\" available to the\n    /// Strategy. Note that all \"free capital\" in the Strategy after the report\n    /// was made is available for reinvestment. Also note that this number\n    /// could be 0, and you should handle that scenario accordingly.\n    function _adjustPosition() internal virtual;\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        virtual\n        returns (uint256 _liquidatedAmount, uint256 _loss);\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// NOTE: Do *not* include `want`, already included in `sweep` below.\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    // ============================== Governance ===================================\n\n    /// @notice Activates emergency exit. Once activated, the Strategy will exit its\n    /// position upon the next harvest, depositing all funds into the Manager as\n    /// quickly as is reasonable given on-chain conditions.\n    /// @dev This may only be called by the `PoolManager`, because when calling this the `PoolManager` should at the same\n    /// time update the debt ratio\n    /// @dev This function can only be called once by the `PoolManager` contract\n    /// @dev See `poolManager.setEmergencyExit()` and `harvest()` for further details.\n    function setEmergencyExit() external onlyRole(POOLMANAGER_ROLE) {\n        emergencyExit = true;\n        emit EmergencyExitActivated();\n    }\n\n    /// @notice Used to change `rewards`.\n    /// @param _rewards The address to use for pulling rewards.\n    function setRewards(IERC20 _rewards) external onlyRole(GUARDIAN_ROLE) {\n        require(address(_rewards) != address(0) && address(_rewards) != address(want), \"92\");\n        rewards = _rewards;\n        emit UpdatedRewards(address(_rewards));\n    }\n\n    /// @notice Used to change the reward amount and the `minimumAmountMoved` parameter\n    /// @param _rewardAmount The new amount of reward given to keepers\n    /// @param _minimumAmountMoved The new minimum amount of collateral moved for a call to `harvest` to be\n    /// considered profitable and justifying a reward given to the keeper calling the function\n    /// @dev A null reward amount corresponds to reward distribution being deactivated\n    function setRewardAmountAndMinimumAmountMoved(uint256 _rewardAmount, uint256 _minimumAmountMoved)\n        external\n        onlyRole(GUARDIAN_ROLE)\n    {\n        rewardAmount = _rewardAmount;\n        minimumAmountMoved = _minimumAmountMoved;\n        emit UpdatedRewardAmountAndMinimumAmountMoved(_rewardAmount, _minimumAmountMoved);\n    }\n\n    /// @notice Used to change `minReportDelay`. `minReportDelay` is the minimum number\n    /// of blocks that should pass for `harvest()` to be called.\n    /// @param _delay The minimum number of seconds to wait between harvests.\n    /// @dev  For external keepers (such as the Keep3r network), this is the minimum\n    /// time between jobs to wait. (see `harvestTrigger()`\n    /// for more details.)\n    function setMinReportDelay(uint256 _delay) external onlyRole(GUARDIAN_ROLE) {\n        minReportDelay = _delay;\n        emit UpdatedMinReportDelayed(_delay);\n    }\n\n    /// @notice Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\n    /// of blocks that should pass for `harvest()` to be called.\n    /// @param _delay The maximum number of seconds to wait between harvests.\n    /// @dev  For external keepers (such as the Keep3r network), this is the maximum\n    /// time between jobs to wait. (see `harvestTrigger()`\n    /// for more details.)\n    function setMaxReportDelay(uint256 _delay) external onlyRole(GUARDIAN_ROLE) {\n        maxReportDelay = _delay;\n        emit UpdatedMaxReportDelayed(_delay);\n    }\n\n    /// @notice Sets how far the Strategy can go into loss without a harvest and report\n    /// being required.\n    /// @param _debtThreshold How big of a loss this Strategy may carry without\n    /// @dev By default this is 0, meaning any losses would cause a harvest which\n    /// will subsequently report the loss to the Manager for tracking. (See\n    /// `harvestTrigger()` for more details.)\n    function setDebtThreshold(uint256 _debtThreshold) external onlyRole(GUARDIAN_ROLE) {\n        debtThreshold = _debtThreshold;\n        emit UpdatedDebtThreshold(_debtThreshold);\n    }\n\n    /// @notice Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this `PoolManager`.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external onlyRole(GUARDIAN_ROLE) {\n        require(_token != address(want), \"93\");\n\n        address[] memory __protectedTokens = _protectedTokens();\n        for (uint256 i = 0; i < __protectedTokens.length; i++)\n            // In the strategy we use so far, the only protectedToken is the want token\n            // and this has been checked above\n            require(_token != __protectedTokens[i], \"93\");\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n\n    // ============================ Manager functions ==============================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because Access Control is not defined\n    /// in PoolManagerInternal\n    function addGuardian(address _guardian) external virtual;\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external virtual;\n}\n"
    },
    "contracts/oracle/OracleAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOracle.sol\";\n\n/// @title OracleAbstract\n/// @author Angle Core Team\n/// @notice Abstract Oracle contract that contains some of the functions that are used across all oracle contracts\n/// @dev This is the most generic form of oracle contract\n/// @dev A rate gives the price of the out-currency with respect to the in-currency in base `BASE`. For instance\n/// if the out-currency is ETH worth 1000 USD, then the rate ETH-USD is 10**21\nabstract contract OracleAbstract is IOracle {\n    /// @notice Base used for computation\n    uint256 public constant BASE = 10**18;\n    /// @notice Unit of the in-currency\n    uint256 public override inBase;\n    /// @notice Description of the assets concerned by the oracle and the price outputted\n    bytes32 public description;\n\n    /// @notice Reads one of the rates from the circuits given\n    /// @return rate The current rate between the in-currency and out-currency\n    /// @dev By default if the oracle involves a Uniswap price and a Chainlink price\n    /// this function will return the Uniswap price\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function read() external view virtual override returns (uint256 rate);\n\n    /// @notice Read rates from the circuit of both Uniswap and Chainlink if there are both circuits\n    /// else returns twice the same price\n    /// @return Return all available rates (Chainlink and Uniswap) with the lowest rate returned first.\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readAll() external view override returns (uint256, uint256) {\n        return _readAll(inBase);\n    }\n\n    /// @notice Reads rates from the circuit of both Uniswap and Chainlink if there are both circuits\n    /// and returns either the highest of both rates or the lowest\n    /// @return rate The lower rate between Chainlink and Uniswap\n    /// @dev If there is only one rate computed in an oracle contract, then the only rate is returned\n    /// regardless of the value of the `lower` parameter\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readLower() external view override returns (uint256 rate) {\n        (rate, ) = _readAll(inBase);\n    }\n\n    /// @notice Reads rates from the circuit of both Uniswap and Chainlink if there are both circuits\n    /// and returns either the highest of both rates or the lowest\n    /// @return rate The upper rate between Chainlink and Uniswap\n    /// @dev If there is only one rate computed in an oracle contract, then the only rate is returned\n    /// regardless of the value of the `lower` parameter\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readUpper() external view override returns (uint256 rate) {\n        (, rate) = _readAll(inBase);\n    }\n\n    /// @notice Converts an in-currency quote amount to out-currency using one of the rates available in the oracle\n    /// contract\n    /// @param quoteAmount Amount (in the input collateral) to be converted to be converted in out-currency\n    /// @return Quote amount in out-currency from the base amount in in-currency\n    /// @dev Like in the read function, if the oracle involves a Uniswap and a Chainlink price, this function\n    /// will use the Uniswap price to compute the out quoteAmount\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuote(uint256 quoteAmount) external view virtual override returns (uint256);\n\n    /// @notice Returns the lowest quote amount between Uniswap and Chainlink circuits (if possible). If the oracle\n    /// contract only involves a single feed, then this returns the value of this feed\n    /// @param quoteAmount Amount (in the input collateral) to be converted\n    /// @return The lowest quote amount from the quote amount in in-currency\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuoteLower(uint256 quoteAmount) external view override returns (uint256) {\n        (uint256 quoteSmall, ) = _readAll(quoteAmount);\n        return quoteSmall;\n    }\n\n    /// @notice Returns Uniswap and Chainlink values (with the first one being the smallest one) or twice the same value\n    /// if just Uniswap or just Chainlink is used\n    /// @param quoteAmount Amount expressed in the in-currency base.\n    /// @dev If `quoteAmount` is `inBase`, rates are returned\n    /// @return The first return value is the lowest value and the second parameter is the highest\n    /// @dev The rate returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readAll(uint256 quoteAmount) internal view virtual returns (uint256, uint256) {}\n}\n"
    },
    "contracts/oracle/OracleMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./OracleAbstract.sol\";\n\nimport \"./modules/ModuleChainlinkMulti.sol\";\nimport \"./modules/ModuleUniswapMulti.sol\";\n\n/// @title OracleMulti\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that only uses both Chainlink and Uniswap for multiple pools\n/// @dev This is going to be used for like ETH/EUR oracles\n/// @dev Like all oracle contracts, this contract is an instance of `OracleAstract` that contains some\n/// base functions\ncontract OracleMulti is OracleAbstract, ModuleChainlinkMulti, ModuleUniswapMulti {\n    /// @notice Whether the final rate obtained with Uniswap should be multiplied to last rate from Chainlink\n    uint8 public immutable uniFinalCurrency;\n\n    /// @notice Unit out Uniswap currency\n    uint256 public immutable outBase;\n\n    /// @notice Constructor for an oracle using both Uniswap and Chainlink with multiple pools to read from\n    /// @param addressInAndOutUni List of 2 addresses representing the in-currency address and the out-currency address\n    /// @param _circuitUniswap Path of the Uniswap pools\n    /// @param _circuitUniIsMultiplied Whether we should multiply or divide by this rate in the path\n    /// @param _twapPeriod Time weighted average window for all Uniswap pools\n    /// @param observationLength Number of observations that each pool should have stored\n    /// @param _uniFinalCurrency Whether we need to use the last Chainlink oracle to convert to another\n    /// currency / asset (Forex for instance)\n    /// @param _circuitChainlink Chainlink pool addresses put in order\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param guardians List of governor or guardian addresses\n    /// @param _description Description of the assets concerned by the oracle\n    /// @dev When deploying this contract, it is important to check in the case where Uniswap circuit is not final whether\n    /// Chainlink and Uniswap circuits are compatible. If Chainlink is UNI-WBTC and WBTC-USD and Uniswap is just UNI-WETH,\n    /// then Chainlink cannot be the final circuit\n    constructor(\n        address[] memory addressInAndOutUni,\n        IUniswapV3Pool[] memory _circuitUniswap,\n        uint8[] memory _circuitUniIsMultiplied,\n        uint32 _twapPeriod,\n        uint16 observationLength,\n        uint8 _uniFinalCurrency,\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint32 stalePeriod,\n        address[] memory guardians,\n        bytes32 _description\n    )\n        ModuleUniswapMulti(_circuitUniswap, _circuitUniIsMultiplied, _twapPeriod, observationLength, guardians)\n        ModuleChainlinkMulti(_circuitChainlink, _circuitChainIsMultiplied, stalePeriod, guardians)\n    {\n        require(addressInAndOutUni.length == 2, \"107\");\n        // Using the tokens' metadata to get the in and out currencies decimals\n        IERC20Metadata inCur = IERC20Metadata(addressInAndOutUni[0]);\n        IERC20Metadata outCur = IERC20Metadata(addressInAndOutUni[1]);\n        inBase = 10**(inCur.decimals());\n        outBase = 10**(outCur.decimals());\n\n        uniFinalCurrency = _uniFinalCurrency;\n        description = _description;\n    }\n\n    /// @notice Reads the Uniswap rate using the circuit given\n    /// @return The current rate between the in-currency and out-currency\n    /// @dev By default even if there is a Chainlink rate, this function returns the Uniswap rate\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function read() external view override returns (uint256) {\n        return _readUniswapQuote(inBase);\n    }\n\n    /// @notice Converts an in-currency quote amount to out-currency using the Uniswap rate\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency\n    /// @return Quote amount in out-currency from the base amount in in-currency\n    /// @dev Like in the `read` function, this function returns the Uniswap quote\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuote(uint256 quoteAmount) external view override returns (uint256) {\n        return _readUniswapQuote(quoteAmount);\n    }\n\n    /// @notice Returns Uniswap and Chainlink values (with the first one being the smallest one)\n    /// @param quoteAmount Amount expressed in the in-currency base.\n    /// @dev If quoteAmount is `inBase`, rates are returned\n    /// @return The first parameter is the lowest value and the second parameter is the highest\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readAll(uint256 quoteAmount) internal view override returns (uint256, uint256) {\n        uint256 quoteAmountUni = _quoteUniswap(quoteAmount);\n\n        // The current uni rate is in `outBase` we want our rate to all be in base `BASE`\n        quoteAmountUni = (quoteAmountUni * BASE) / outBase;\n        // The current amount is in `inBase` we want our rate to all be in base `BASE`\n        uint256 quoteAmountCL = (quoteAmount * BASE) / inBase;\n        uint256 ratio;\n\n        (quoteAmountCL, ratio) = _quoteChainlink(quoteAmountCL);\n\n        if (uniFinalCurrency > 0) {\n            quoteAmountUni = _changeUniswapNotFinal(ratio, quoteAmountUni);\n        }\n\n        if (quoteAmountCL <= quoteAmountUni) {\n            return (quoteAmountCL, quoteAmountUni);\n        } else return (quoteAmountUni, quoteAmountCL);\n    }\n\n    /// @notice Uses Chainlink's value to change Uniswap's rate\n    /// @param ratio Value of the last oracle rate of Chainlink\n    /// @param quoteAmountUni End quote computed from Uniswap's circuit\n    /// @dev We use the last Chainlink rate to correct the value obtained with Uniswap. It may for instance be used\n    /// to get a Uniswap price in EUR (ex: ETH -> USDC and we use this to do USDC -> EUR)\n    function _changeUniswapNotFinal(uint256 ratio, uint256 quoteAmountUni) internal view returns (uint256) {\n        uint256 idxLastPoolCL = circuitChainlink.length - 1;\n        (quoteAmountUni, ) = _readChainlinkFeed(\n            quoteAmountUni,\n            circuitChainlink[idxLastPoolCL],\n            circuitChainIsMultiplied[idxLastPoolCL],\n            chainlinkDecimals[idxLastPoolCL],\n            ratio\n        );\n        return quoteAmountUni;\n    }\n\n    /// @notice Internal function to convert an in-currency quote amount to out-currency using only the Uniswap rate\n    /// and by correcting it if needed from Chainlink last rate\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency using Uniswap (and Chainlink)\n    /// at the end of the funnel\n    /// @return uniAmount Quote amount in out-currency from the base amount in in-currency\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readUniswapQuote(uint256 quoteAmount) internal view returns (uint256 uniAmount) {\n        uniAmount = _quoteUniswap(quoteAmount);\n        // The current uni rate is in outBase we want our rate to all be in base\n        uniAmount = (uniAmount * BASE) / outBase;\n        if (uniFinalCurrency > 0) {\n            uniAmount = _changeUniswapNotFinal(0, uniAmount);\n        }\n    }\n}\n"
    },
    "contracts/oracle/modules/ModuleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/ChainlinkUtils.sol\";\n\n/// @title ModuleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Module Contract that is going to be used to help compute Chainlink prices\n/// @dev This contract helps for an oracle using a Chainlink circuit composed of multiple pools\n/// @dev An oracle using Chainlink is either going to be a `ModuleChainlinkSingle` or a `ModuleChainlinkMulti`\nabstract contract ModuleChainlinkMulti is ChainlinkUtils {\n    /// @notice Chanlink pools, the order of the pools has to be the order in which they are read for the computation\n    /// of the price\n    AggregatorV3Interface[] public circuitChainlink;\n    /// @notice Whether each rate for the pairs in `circuitChainlink` should be multiplied or divided\n    uint8[] public circuitChainIsMultiplied;\n    /// @notice Decimals for each Chainlink pairs\n    uint8[] public chainlinkDecimals;\n\n    /// @notice Constructor for an oracle using only Chainlink with multiple pools to read from\n    /// @param _circuitChainlink Chainlink pool addresses (in order)\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate when computing Chainlink price\n    constructor(\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint32 _stalePeriod,\n        address[] memory guardians\n    ) {\n        uint256 circuitLength = _circuitChainlink.length;\n        require(circuitLength > 0, \"106\");\n        require(circuitLength == _circuitChainIsMultiplied.length, \"104\");\n        // There is no `GOVERNOR_ROLE` in this contract, governor has `GUARDIAN_ROLE`\n        require(guardians.length > 0, \"101\");\n        for (uint256 i = 0; i < guardians.length; i++) {\n            require(guardians[i] != address(0), \"0\");\n            _setupRole(GUARDIAN_ROLE_CHAINLINK, guardians[i]);\n        }\n        _setRoleAdmin(GUARDIAN_ROLE_CHAINLINK, GUARDIAN_ROLE_CHAINLINK);\n\n        for (uint256 i = 0; i < circuitLength; i++) {\n            AggregatorV3Interface _pool = AggregatorV3Interface(_circuitChainlink[i]);\n            circuitChainlink.push(_pool);\n            chainlinkDecimals.push(_pool.decimals());\n        }\n\n        stalePeriod = _stalePeriod;\n        circuitChainIsMultiplied = _circuitChainIsMultiplied;\n    }\n\n    /// @notice Reads oracle price using Chainlink circuit\n    /// @param quoteAmount The amount for which to compute the price expressed with base decimal\n    /// @return The `quoteAmount` converted in `out-currency`\n    /// @return The value obtained with the last Chainlink feed queried casted to uint\n    /// @dev If `quoteAmount` is `BASE_TOKENS`, the output is the oracle rate\n    function _quoteChainlink(uint256 quoteAmount) internal view returns (uint256, uint256) {\n        uint256 castedRatio;\n        // An invariant should be that `circuitChainlink.length > 0` otherwise `castedRatio = 0`\n        for (uint256 i = 0; i < circuitChainlink.length; i++) {\n            (quoteAmount, castedRatio) = _readChainlinkFeed(\n                quoteAmount,\n                circuitChainlink[i],\n                circuitChainIsMultiplied[i],\n                chainlinkDecimals[i],\n                0\n            );\n        }\n        return (quoteAmount, castedRatio);\n    }\n}\n"
    },
    "contracts/oracle/modules/ModuleUniswapMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/UniswapUtils.sol\";\n\n/// @title ModuleUniswapMulti\n/// @author Angle Core Team\n/// @notice Module Contract that is going to be used to help compute Uniswap prices\n/// @dev This contract will help for an oracle using multiple UniswapV3 pools\n/// @dev An oracle using Uniswap is either going to be a `ModuleUniswapSingle` or a `ModuleUniswapMulti`\nabstract contract ModuleUniswapMulti is UniswapUtils {\n    /// @notice Uniswap pools, the order of the pools to arrive to the final price should be respected\n    IUniswapV3Pool[] public circuitUniswap;\n    /// @notice Whether the rate obtained with each pool should be multiplied or divided to the current amount\n    uint8[] public circuitUniIsMultiplied;\n\n    /// @notice Constructor for an oracle using multiple Uniswap pool\n    /// @param _circuitUniswap Path of the Uniswap pools\n    /// @param _circuitUniIsMultiplied Whether we should multiply or divide by this rate in the path\n    /// @param _twapPeriod Time weighted average window, it is common for all Uniswap pools\n    /// @param observationLength Number of observations that each pool should have stored\n    /// @param guardians List of governor or guardian addresses\n    constructor(\n        IUniswapV3Pool[] memory _circuitUniswap,\n        uint8[] memory _circuitUniIsMultiplied,\n        uint32 _twapPeriod,\n        uint16 observationLength,\n        address[] memory guardians\n    ) {\n        // There is no `GOVERNOR_ROLE` in this contract, governor has `GUARDIAN_ROLE`\n        require(guardians.length > 0, \"101\");\n        for (uint256 i = 0; i < guardians.length; i++) {\n            require(guardians[i] != address(0), \"0\");\n            _setupRole(GUARDIAN_ROLE_UNISWAP, guardians[i]);\n        }\n        _setRoleAdmin(GUARDIAN_ROLE_UNISWAP, GUARDIAN_ROLE_UNISWAP);\n\n        require(int32(_twapPeriod) > 0, \"102\");\n        uint256 circuitUniLength = _circuitUniswap.length;\n        require(circuitUniLength > 0, \"103\");\n        require(circuitUniLength == _circuitUniIsMultiplied.length, \"104\");\n\n        twapPeriod = _twapPeriod;\n\n        circuitUniswap = _circuitUniswap;\n        circuitUniIsMultiplied = _circuitUniIsMultiplied;\n\n        for (uint256 i = 0; i < circuitUniLength; i++) {\n            circuitUniswap[i].increaseObservationCardinalityNext(observationLength);\n        }\n    }\n\n    /// @notice Reads Uniswap current block oracle rate\n    /// @param quoteAmount The amount in the in-currency base to convert using the Uniswap oracle\n    /// @return The value of the oracle of the initial amount is then expressed in the decimal from\n    /// the end currency\n    function _quoteUniswap(uint256 quoteAmount) internal view returns (uint256) {\n        for (uint256 i = 0; i < circuitUniswap.length; i++) {\n            quoteAmount = _readUniswapPool(quoteAmount, circuitUniswap[i], circuitUniIsMultiplied[i]);\n        }\n        // The decimal here is the one from the end currency\n        return quoteAmount;\n    }\n\n    /// @notice Increases the number of observations for each Uniswap pools\n    /// @param newLengthStored Size asked for\n    /// @dev newLengthStored should be larger than all previous pools observations length\n    function increaseTWAPStore(uint16 newLengthStored) external {\n        for (uint256 i = 0; i < circuitUniswap.length; i++) {\n            circuitUniswap[i].increaseObservationCardinalityNext(newLengthStored);\n        }\n    }\n}\n"
    },
    "contracts/oracle/utils/ChainlinkUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../external/AccessControl.sol\";\n\n/// @title ChainlinkUtils\n/// @author Angle Core Team\n/// @notice Utility contract that is used across the different module contracts using Chainlink\nabstract contract ChainlinkUtils is AccessControl {\n    /// @notice Represent the maximum amount of time (in seconds) between each Chainlink update before the price feed is considered stale\n    uint32 public stalePeriod;\n\n    // Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE_CHAINLINK = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param quoteAmount The amount for which to compute the price expressed with base decimal\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @param castedRatio Whether a previous rate has already been computed for this feed\n    /// This is mostly used in the `_changeUniswapNotFinal` function of the oracles\n    /// @return The `quoteAmount` converted in out-currency (computed using the second return value)\n    /// @return The value obtained with the Chainlink feed queried casted to uint\n    function _readChainlinkFeed(\n        uint256 quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals,\n        uint256 castedRatio\n    ) internal view returns (uint256, uint256) {\n        if (castedRatio == 0) {\n            (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound) = feed.latestRoundData();\n            require(ratio > 0 && roundId <= answeredInRound && block.timestamp - updatedAt <= stalePeriod, \"100\");\n            castedRatio = uint256(ratio);\n        }\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) quoteAmount = (quoteAmount * castedRatio) / (10**decimals);\n        else quoteAmount = (quoteAmount * (10**decimals)) / castedRatio;\n        return (quoteAmount, castedRatio);\n    }\n\n    /// @notice Changes the Stale Period\n    /// @param _stalePeriod New stale period (in seconds)\n    function changeStalePeriod(uint32 _stalePeriod) external onlyRole(GUARDIAN_ROLE_CHAINLINK) {\n        stalePeriod = _stalePeriod;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/oracle/OracleDAI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./OracleAbstract.sol\";\n\nimport \"./modules/ModuleChainlinkMulti.sol\";\nimport \"./modules/ModuleUniswapMulti.sol\";\n\n/// @title OracleDAI\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that only uses both Chainlink and Uniswap for multiple pools\n/// @dev This is going to be used for like ETH/EUR oracles\n/// @dev Like all oracle contracts, this contract is an instance of `OracleAstract` that contains some\n/// base functions\ncontract OracleDAI is OracleAbstract, ModuleChainlinkMulti, ModuleUniswapMulti {\n    /// @notice Whether the final rate obtained with Uniswap should be multiplied to last rate from Chainlink\n    uint8 public immutable uniFinalCurrency;\n\n    /// @notice Unit out Uniswap currency\n    uint256 public immutable outBase;\n\n    /// @notice Constructor for an oracle using both Uniswap and Chainlink with multiple pools to read from\n    /// @param addressInAndOutUni List of 2 addresses representing the in-currency address and the out-currency address\n    /// @param _circuitUniswap Path of the Uniswap pools\n    /// @param _circuitUniIsMultiplied Whether we should multiply or divide by this rate in the path\n    /// @param _twapPeriod Time weighted average window for all Uniswap pools\n    /// @param observationLength Number of observations that each pool should have stored\n    /// @param _uniFinalCurrency Whether we need to use the last Chainlink oracle to convert to another\n    /// currency / asset (Forex for instance)\n    /// @param _circuitChainlink Chainlink pool addresses put in order\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param guardians List of governor or guardian addresses\n    /// @param _description Description of the assets concerned by the oracle\n    /// @dev When deploying this contract, it is important to check in the case where Uniswap circuit is not final whether\n    /// Chainlink and Uniswap circuits are compatible. If Chainlink is UNI-WBTC and WBTC-USD and Uniswap is just UNI-WETH,\n    /// then Chainlink cannot be the final circuit\n    constructor(\n        address[] memory addressInAndOutUni,\n        IUniswapV3Pool[] memory _circuitUniswap,\n        uint8[] memory _circuitUniIsMultiplied,\n        uint32 _twapPeriod,\n        uint16 observationLength,\n        uint8 _uniFinalCurrency,\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint32 stalePeriod,\n        address[] memory guardians,\n        bytes32 _description\n    )\n        ModuleUniswapMulti(_circuitUniswap, _circuitUniIsMultiplied, _twapPeriod, observationLength, guardians)\n        ModuleChainlinkMulti(_circuitChainlink, _circuitChainIsMultiplied, stalePeriod, guardians)\n    {\n        require(addressInAndOutUni.length == 2, \"107\");\n        // Using the tokens' metadata to get the in and out currencies decimals\n        IERC20Metadata inCur = IERC20Metadata(addressInAndOutUni[0]);\n        IERC20Metadata outCur = IERC20Metadata(addressInAndOutUni[1]);\n        inBase = 10**(inCur.decimals());\n        outBase = 10**(outCur.decimals());\n\n        uniFinalCurrency = _uniFinalCurrency;\n        description = _description;\n    }\n\n    /// @notice Reads the Uniswap rate using the circuit given\n    /// @return The current rate between the in-currency and out-currency\n    /// @dev By default even if there is a Chainlink rate, this function returns the Uniswap rate\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function read() external view override returns (uint256) {\n        return _readUniswapQuote(inBase);\n    }\n\n    /// @notice Converts an in-currency quote amount to out-currency using the Uniswap rate\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency\n    /// @return Quote amount in out-currency from the base amount in in-currency\n    /// @dev Like in the `read` function, this function returns the Uniswap quote\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuote(uint256 quoteAmount) external view override returns (uint256) {\n        return _readUniswapQuote(quoteAmount);\n    }\n\n    /// @notice Returns Uniswap and Chainlink values (with the first one being the smallest one)\n    /// @param quoteAmount Amount expressed in the in-currency base.\n    /// @dev If quoteAmount is `inBase`, rates are returned\n    /// @return The first parameter is the lowest value and the second parameter is the highest\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readAll(uint256 quoteAmount) internal view override returns (uint256, uint256) {\n        uint256 quoteAmountUni = _quoteUniswap(quoteAmount);\n\n        // The current uni rate is in `outBase` we want our rate to all be in base `BASE`\n        quoteAmountUni = (quoteAmountUni * BASE) / outBase;\n        // The current amount is in `inBase` we want our rate to all be in base `BASE`\n        uint256 quoteAmountCL = (quoteAmount * BASE) / inBase;\n        uint256 ratio;\n\n        (quoteAmountCL, ratio) = _quoteChainlink(quoteAmountCL);\n\n        if (uniFinalCurrency > 0) {\n            quoteAmountUni = _changeUniswapNotFinal(ratio, quoteAmountUni);\n        }\n\n        // As DAI is made to be a stablecoin, compute the rate as if Uniswap returned `BASE * quoteAmount / inBase`\n        ratio = _changeUniswapNotFinal(ratio, (quoteAmount * BASE) / inBase);\n\n        if (quoteAmountCL <= quoteAmountUni) {\n            if (ratio <= quoteAmountCL) {\n                return (ratio, quoteAmountUni);\n            } else if (quoteAmountUni <= ratio) {\n                return (quoteAmountCL, ratio);\n            }\n            return (quoteAmountCL, quoteAmountUni);\n        } else {\n            if (ratio <= quoteAmountUni) {\n                return (ratio, quoteAmountCL);\n            } else if (quoteAmountCL <= ratio) {\n                return (quoteAmountUni, ratio);\n            }\n            return (quoteAmountUni, quoteAmountCL);\n        }\n    }\n\n    /// @notice Uses Chainlink's value to change Uniswap's rate\n    /// @param ratio Value of the last oracle rate of Chainlink\n    /// @param quoteAmountUni End quote computed from Uniswap's circuit\n    /// @dev We use the last Chainlink rate to correct the value obtained with Uniswap. It may for instance be used\n    /// to get a Uniswap price in EUR (ex: ETH -> USDC and we use this to do USDC -> EUR)\n    function _changeUniswapNotFinal(uint256 ratio, uint256 quoteAmountUni) internal view returns (uint256) {\n        uint256 idxLastPoolCL = circuitChainlink.length - 1;\n        (quoteAmountUni, ) = _readChainlinkFeed(\n            quoteAmountUni,\n            circuitChainlink[idxLastPoolCL],\n            circuitChainIsMultiplied[idxLastPoolCL],\n            chainlinkDecimals[idxLastPoolCL],\n            ratio\n        );\n        return quoteAmountUni;\n    }\n\n    /// @notice Internal function to convert an in-currency quote amount to out-currency using only the Uniswap rate\n    /// and by correcting it if needed from Chainlink last rate\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency using Uniswap (and Chainlink)\n    /// at the end of the funnel\n    /// @return uniAmount Quote amount in out-currency from the base amount in in-currency\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readUniswapQuote(uint256 quoteAmount) internal view returns (uint256 uniAmount) {\n        uniAmount = _quoteUniswap(quoteAmount);\n        // The current uni rate is in outBase we want our rate to all be in base\n        uniAmount = (uniAmount * BASE) / outBase;\n        if (uniFinalCurrency > 0) {\n            uniAmount = _changeUniswapNotFinal(0, uniAmount);\n        }\n    }\n}\n"
    },
    "contracts/oracle/OracleChainlinkMulti.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./modules/ModuleChainlinkMulti.sol\";\nimport \"./OracleAbstract.sol\";\n\n/// @title OracleChainlinkMulti\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that uses Chainlink with multiple pools to read from\n/// @dev It inherits the `ModuleChainlinkMulti` contract and like all oracle contracts, this contract\n/// is an instance of `OracleAstract` that contains some base functions\ncontract OracleChainlinkMulti is OracleAbstract, ModuleChainlinkMulti {\n    /// @notice Constructor for an oracle using Chainlink with multiple pools to read from\n    /// @param _circuitChainlink Chainlink pool addresses (in order)\n    /// @param _circuitChainIsMultiplied Whether we should multiply or divide by this rate\n    /// @param _description Description of the assets concerned by the oracle\n    constructor(\n        address[] memory _circuitChainlink,\n        uint8[] memory _circuitChainIsMultiplied,\n        uint256 _inBase,\n        uint32 stalePeriod,\n        address[] memory guardians,\n        bytes32 _description\n    ) ModuleChainlinkMulti(_circuitChainlink, _circuitChainIsMultiplied, stalePeriod, guardians) {\n        inBase = _inBase;\n        description = _description;\n    }\n\n    /// @notice Reads the rate from the Chainlink circuit\n    /// @return rate The current rate between the in-currency and out-currency\n    function read() external view override returns (uint256 rate) {\n        (rate, ) = _quoteChainlink(BASE);\n    }\n\n    /// @notice Converts an in-currency quote amount to out-currency using Chainlink's circuit\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency\n    /// @return Quote amount in out-currency from the base amount in in-currency\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuote(uint256 quoteAmount) external view override returns (uint256) {\n        return _readQuote(quoteAmount);\n    }\n\n    /// @notice Returns Chainlink quote values twice\n    /// @param quoteAmount Amount expressed in the in-currency base.\n    /// @dev If quoteAmount is `inBase`, rates are returned\n    /// @return The two return values are similar\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readAll(uint256 quoteAmount) internal view override returns (uint256, uint256) {\n        uint256 quote = _readQuote(quoteAmount);\n        return (quote, quote);\n    }\n\n    /// @notice Internal function to convert an in-currency quote amount to out-currency using Chainlink's circuit\n    /// @param quoteAmount Amount (in the input collateral) to be converted to be converted in out-currency\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readQuote(uint256 quoteAmount) internal view returns (uint256) {\n        quoteAmount = (quoteAmount * BASE) / inBase;\n        (quoteAmount, ) = _quoteChainlink(quoteAmount);\n        // We return only rates with base as decimals\n        return quoteAmount;\n    }\n}\n"
    },
    "contracts/oracle/modules/ModuleChainlinkSingle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../utils/ChainlinkUtils.sol\";\n\n/// @title ModuleChainlinkSingle\n/// @author Angle Core Team\n/// @notice Module Contract that is going to be used to help compute Chainlink prices\n/// @dev This contract will help for an oracle using a single Chainlink price\n/// @dev An oracle using Chainlink is either going to be a `ModuleChainlinkSingle` or a `ModuleChainlinkMulti`\nabstract contract ModuleChainlinkSingle is ChainlinkUtils {\n    /// @notice Chainlink pool to look for in the contract\n    AggregatorV3Interface public immutable poolChainlink;\n    /// @notice Whether the rate computed using the Chainlink pool should be multiplied to the quote amount or not\n    uint8 public immutable isChainlinkMultiplied;\n    /// @notice Decimals for each Chainlink pairs\n    uint8 public immutable chainlinkDecimals;\n\n    /// @notice Constructor for an oracle using only a single Chainlink\n    /// @param _poolChainlink Chainlink pool address\n    /// @param _isChainlinkMultiplied Whether we should multiply or divide the quote amount by the rate\n    constructor(\n        address _poolChainlink,\n        uint8 _isChainlinkMultiplied,\n        uint32 _stalePeriod,\n        address[] memory guardians\n    ) {\n        require(_poolChainlink != address(0), \"105\");\n        poolChainlink = AggregatorV3Interface(_poolChainlink);\n        chainlinkDecimals = AggregatorV3Interface(_poolChainlink).decimals();\n        // There is no `GOVERNOR_ROLE` in this contract, governor has `GUARDIAN_ROLE`\n        require(guardians.length > 0, \"101\");\n        for (uint256 i = 0; i < guardians.length; i++) {\n            require(guardians[i] != address(0), \"0\");\n            _setupRole(GUARDIAN_ROLE_CHAINLINK, guardians[i]);\n        }\n        _setRoleAdmin(GUARDIAN_ROLE_CHAINLINK, GUARDIAN_ROLE_CHAINLINK);\n\n        stalePeriod = _stalePeriod;\n        isChainlinkMultiplied = _isChainlinkMultiplied;\n    }\n\n    /// @notice Reads oracle price using a single Chainlink pool\n    /// @param quoteAmount Amount expressed with base decimal\n    /// @dev If `quoteAmount` is base, the output is the oracle rate\n    function _quoteChainlink(uint256 quoteAmount) internal view returns (uint256, uint256) {\n        // No need for a for loop here as there is only a single pool we are looking at\n        return _readChainlinkFeed(quoteAmount, poolChainlink, isChainlinkMultiplied, chainlinkDecimals, 0);\n    }\n}\n"
    },
    "contracts/oracle/OracleChainlinkSingle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// contracts/oracle/OracleChainlinkSingle.sol\npragma solidity ^0.8.7;\n\nimport \"./OracleAbstract.sol\";\nimport \"./modules/ModuleChainlinkSingle.sol\";\n\n/// @title OracleChainlinkSingle\n/// @author Angle Core Team\n/// @notice Oracle contract, one contract is deployed per collateral/stablecoin pair\n/// @dev This contract concerns an oracle that only uses Chainlink and a single pool\n/// @dev This is mainly going to be the contract used for the USD/EUR pool (or for other fiat currencies)\n/// @dev Like all oracle contracts, this contract is an instance of `OracleAstract` that contains some\n/// base functions\ncontract OracleChainlinkSingle is OracleAbstract, ModuleChainlinkSingle {\n    /// @notice Constructor for the oracle using a single Chainlink pool\n    /// @param _poolChainlink Chainlink pool address\n    /// @param _isChainlinkMultiplied Whether we should multiply or divide by the Chainlink rate the\n    /// in-currency amount to get the out-currency amount\n    /// @param _inBase Number of units of the in-currency\n    /// @param _description Description of the assets concerned by the oracle\n    constructor(\n        address _poolChainlink,\n        uint8 _isChainlinkMultiplied,\n        uint256 _inBase,\n        uint32 stalePeriod,\n        address[] memory guardians,\n        bytes32 _description\n    ) ModuleChainlinkSingle(_poolChainlink, _isChainlinkMultiplied, stalePeriod, guardians) {\n        inBase = _inBase;\n        description = _description;\n    }\n\n    /// @notice Reads the rate from the Chainlink feed\n    /// @return rate The current rate between the in-currency and out-currency\n    function read() external view override returns (uint256 rate) {\n        (rate, ) = _quoteChainlink(BASE);\n    }\n\n    /// @notice Converts an in-currency quote amount to out-currency using Chainlink's feed\n    /// @param quoteAmount Amount (in the input collateral) to be converted in out-currency\n    /// @return Quote amount in out-currency from the base amount in in-currency\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function readQuote(uint256 quoteAmount) external view override returns (uint256) {\n        return _readQuote(quoteAmount);\n    }\n\n    /// @notice Returns Chainlink quote value twice\n    /// @param quoteAmount Amount expressed in the in-currency base.\n    /// @dev If quoteAmount is `inBase`, rates are returned\n    /// @return The two return values are similar in this case\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readAll(uint256 quoteAmount) internal view override returns (uint256, uint256) {\n        uint256 quote = _readQuote(quoteAmount);\n        return (quote, quote);\n    }\n\n    /// @notice Internal function to convert an in-currency quote amount to out-currency using Chainlink's feed\n    /// @param quoteAmount Amount (in the input collateral) to be converted\n    /// @dev The amount returned is expressed with base `BASE` (and not the base of the out-currency)\n    function _readQuote(uint256 quoteAmount) internal view returns (uint256) {\n        quoteAmount = (quoteAmount * BASE) / inBase;\n        (quoteAmount, ) = _quoteChainlink(quoteAmount);\n        // We return only rates with base BASE\n        return quoteAmount;\n    }\n}\n"
    },
    "contracts/strategies/StrategyStETHAcc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"../interfaces/external/curve/Curve.sol\";\nimport \"../interfaces/external/lido/ISteth.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./BaseStrategy.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title StrategyStETHAcc\n/// @author Forked from https://github.com/Grandthrax/yearn-steth-acc/blob/master/contracts/Strategy.sol\n/// @notice A strategy designed to getting yield on wETH by putting ETH in Lido or Curve for stETH and exiting\n/// for wETH\ncontract StrategyStETHAcc is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @notice Current `apr` of the strategy: this apr needs to be manually filled by the strategist\n    /// and updated when Lido's APR changes. It is put like that as there is no easy way to compute Lido's APR\n    /// on-chain\n    uint256 public apr;\n\n    /// @notice Reference to the Curve ETH/stETH\n    ICurveFi public immutable stableSwapSTETH;\n    /// @notice Reference to wETH, it should normally be equal to `want`\n    IWETH public immutable weth;\n    /// @notice Reference to the stETH token\n    ISteth public immutable stETH;\n\n    address private _referral = 0x16388463d60FFE0661Cf7F1f31a7D658aC790ff7; //stratms. for recycling and redepositing\n    /// @notice Maximum trade size within the strategy\n    uint256 public maxSingleTrade;\n    /// @notice Parameter used for slippage protection\n    uint256 public constant DENOMINATOR = 10_000;\n    /// @notice Slippage parameter for the swaps on Curve: out of `DENOMINATOR`\n    uint256 public slippageProtectionOut; // = 50; //out of 10000. 50 = 0.5%\n\n    /// @notice ID of wETH in the Curve pool\n    int128 private constant _WETHID = 0;\n    /// @notice ID of stETH in the Curve pool\n    int128 private constant _STETHID = 1;\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param _rewards  The token given to reward keepers.\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param _stableSwapSTETH Address of the stETH/ETH Curve pool\n    /// @param _weth Address of wETH\n    /// @param _stETH Address of the stETH token\n    constructor(\n        address _poolManager,\n        IERC20 _rewards,\n        address[] memory governorList,\n        address guardian,\n        address _stableSwapSTETH,\n        address _weth,\n        ISteth _stETH\n    ) BaseStrategy(_poolManager, _rewards, governorList, guardian) {\n        require(address(want) == _weth, \"20\");\n        stableSwapSTETH = ICurveFi(_stableSwapSTETH);\n        weth = IWETH(_weth);\n        stETH = ISteth(_stETH);\n        _stETH.approve(_stableSwapSTETH, type(uint256).max);\n        maxSingleTrade = 1_000 * 1e18;\n        slippageProtectionOut = 50;\n    }\n\n    /// @notice This contract gets ETH and so it needs this function\n    receive() external payable {}\n\n    // ========================== View Functions ===================================\n\n    /// @notice View function to check the total assets managed by the strategy\n    /// @dev We are purposely treating stETH and ETH as being equivalent.\n    /// This is for a few reasons. The main one is that we do not have a good way to value\n    /// stETH at any current time without creating exploit routes.\n    /// Currently you can mint eth for steth but can't burn steth for eth so need to sell.\n    /// Once eth 2.0 is merged you will be able to burn 1-1 as well.\n    /// The main downside here is that we will noramlly overvalue our position as we expect stETH\n    /// to trade slightly below peg. That means we will earn profit on deposits and take losses on withdrawals.\n    /// This may sound scary but it is the equivalent of using virtualprice in a curve lp.\n    /// As we have seen from many exploits, virtual pricing is safer than touch pricing.\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return stethBalance() + wantBalance();\n    }\n\n    /// @notice Returns the wETH balance of the strategy\n    function wantBalance() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @notice Returns the stETH balance of the strategy\n    function stethBalance() public view returns (uint256) {\n        return stETH.balanceOf(address(this));\n    }\n\n    /// @notice The ETH APR of owning stETH\n    function estimatedAPR() external view returns (uint256) {\n        return apr;\n    }\n\n    // ========================== Strategy Functions ===============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt: it is an amount made available for the `PoolManager`\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        uint256 wantBal = wantBalance();\n        uint256 stethBal = stethBalance();\n        uint256 totalAssets = wantBal + stethBal;\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (totalAssets >= debt) {\n            _profit = totalAssets - debt;\n\n            uint256 toWithdraw = _profit + _debtOutstanding;\n            // If more should be withdrawn than what's in the strategy: we divest from Curve\n            if (toWithdraw > wantBal) {\n                // We step our withdrawals. Adjust max single trade to withdraw more\n                uint256 willWithdraw = Math.min(maxSingleTrade, toWithdraw);\n                uint256 withdrawn = _divest(willWithdraw);\n                if (withdrawn < willWithdraw) {\n                    _loss = willWithdraw - withdrawn;\n                }\n            }\n            wantBal = wantBalance();\n\n            // Computing net off profit and loss\n            if (_profit >= _loss) {\n                _profit = _profit - _loss;\n                _loss = 0;\n            } else {\n                _profit = 0;\n                _loss = _loss - _profit;\n            }\n\n            // profit + _debtOutstanding must be <= wantbalance. Prioritise profit first\n            if (wantBal < _profit) {\n                _profit = wantBal;\n            } else if (wantBal < toWithdraw) {\n                _debtPayment = wantBal - _profit;\n            } else {\n                _debtPayment = _debtOutstanding;\n            }\n        } else {\n            _loss = debt - totalAssets;\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        _divest(stethBalance());\n        _amountFreed = wantBalance();\n    }\n\n    /// @notice Function called when harvesting to invest in stETH\n    function _adjustPosition() internal override {\n        uint256 toInvest = wantBalance();\n        if (toInvest > 0) {\n            uint256 realInvest = Math.min(maxSingleTrade, toInvest);\n            _invest(realInvest);\n        }\n    }\n\n    /// @notice Invests `_amount` wETH in stETH\n    /// @param _amount Amount of wETH to put in stETH\n    /// @return The amount of stETH received from the investment\n    /// @dev This function chooses the optimal route between going to Lido directly or doing a swap on Curve\n    /// @dev This function automatically wraps wETH to ETH\n    function _invest(uint256 _amount) internal returns (uint256) {\n        uint256 before = stethBalance();\n        // Unwrapping the tokens\n        weth.withdraw(_amount);\n        // Test if we should buy from Curve instead of minting from Lido\n        uint256 out = stableSwapSTETH.get_dy(_WETHID, _STETHID, _amount);\n        if (out < _amount) {\n            // If we get less than one stETH per wETH we use Lido\n            stETH.submit{ value: _amount }(_referral);\n        } else {\n            // Otherwise, we do a Curve swap\n            stableSwapSTETH.exchange{ value: _amount }(_WETHID, _STETHID, _amount, _amount);\n        }\n\n        return stethBalance() - before;\n    }\n\n    /// @notice Divests stETH on Curve and gets wETH back to the strategy in exchange\n    /// @param _amount Amount of stETH to divest\n    /// @dev Curve is the only place to convert stETH to ETH\n    function _divest(uint256 _amount) internal returns (uint256) {\n        uint256 before = wantBalance();\n\n        // Computing slippage protection for the swap\n        uint256 slippageAllowance = (_amount * (DENOMINATOR - slippageProtectionOut)) / DENOMINATOR;\n        // Curve swap\n        stableSwapSTETH.exchange(_STETHID, _WETHID, _amount, slippageAllowance);\n\n        weth.deposit{ value: address(this).balance }();\n\n        return wantBalance() - before;\n    }\n\n    /// @notice Attempts to withdraw `_amountNeeded` from the strategy and lets the user decide if they take the loss or not\n    /// @param _amountNeeded Amount to withdraw from the strategy\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 wantBal = wantBalance();\n        if (wantBal < _amountNeeded) {\n            uint256 toWithdraw = _amountNeeded - wantBal;\n            uint256 withdrawn = _divest(toWithdraw);\n            if (withdrawn < toWithdraw) {\n                _loss = toWithdraw - withdrawn;\n            }\n        }\n\n        _liquidatedAmount = _amountNeeded - _loss;\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    // Override this to add all tokens/tokenized positions this contract manages\n    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)\n    // NOTE: Do *not* include `want`, already included in `sweep` below\n    //\n    // Example:\n    //\n    //    function _protectedTokens() internal override view returns (address[] memory) {\n    //      address[] memory protected = new address[](3);\n    //      protected[0] = tokenA;\n    //      protected[1] = tokenB;\n    //      protected[2] = tokenC;\n    //      return protected;\n    //    }\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(stETH);\n\n        return protected;\n    }\n\n    // ============================ Governance =====================================\n\n    /// @notice Updates the referral code for Lido\n    /// @param newReferral Address of the new referral\n    function updateReferral(address newReferral) public onlyRole(GUARDIAN_ROLE) {\n        _referral = newReferral;\n    }\n\n    /// @notice Updates the size of a trade in the strategy\n    /// @param _maxSingleTrade New `maxSingleTrade` value\n    function updateMaxSingleTrade(uint256 _maxSingleTrade) public onlyRole(GUARDIAN_ROLE) {\n        maxSingleTrade = _maxSingleTrade;\n    }\n\n    /// @notice Changes the estimated APR of the strategy\n    /// @param _apr New strategy APR\n    function setApr(uint256 _apr) public onlyRole(GUARDIAN_ROLE) {\n        apr = _apr;\n    }\n\n    /// @notice Updates the maximum slippage protection parameter\n    /// @param _slippageProtectionOut New slippage protection parameter\n    function updateSlippageProtectionOut(uint256 _slippageProtectionOut) public onlyRole(GUARDIAN_ROLE) {\n        slippageProtectionOut = _slippageProtectionOut;\n    }\n\n    /// @notice Invests `_amount` in stETH\n    /// @param _amount Amount to invest\n    /// @dev This function allows to override the behavior that could be obtained through `harvest` calls\n    function invest(uint256 _amount) external onlyRole(GUARDIAN_ROLE) {\n        require(wantBalance() >= _amount);\n        uint256 realInvest = Math.min(maxSingleTrade, _amount);\n        _invest(realInvest);\n    }\n\n    /// @notice Rescues stuck ETH from the strategy\n    /// @dev This strategy should never have stuck eth, but let it just in case\n    function rescueStuckEth() external onlyRole(GUARDIAN_ROLE) {\n        weth.deposit{ value: address(this).balance }();\n    }\n\n    // ========================== Manager functions ================================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/Curve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\ninterface ICurveFi {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(\n        // sBTC pool\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function add_liquidity(\n        // bUSD pool\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function add_liquidity(\n        // stETH pool\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    function remove_liquidity_imbalance(uint256[4] calldata amounts, uint256 max_burn_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function exchange(\n        int128 from,\n        int128 to,\n        uint256 _from_amount,\n        uint256 _min_to_amount\n    ) external payable;\n\n    function balances(int128) external view returns (uint256);\n\n    function get_dy(\n        int128 from,\n        int128 to,\n        uint256 _from_amount\n    ) external view returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts, bool is_deposit) external view returns (uint256);\n}\n\ninterface Zap {\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/lido/ISteth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISteth is IERC20 {\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function decimals() external view returns (uint256);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/dao/Timelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\ncontract Timelock is TimelockController {\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) TimelockController(minDelay, proposers, executors) {}\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    /// For example, if `decimals` equals `2`, a balance of `505` tokens should\n    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    /// @notice allow to mint\n    /// @param account the account to mint to\n    /// @param amount the amount to mint\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    /// @notice allow to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of agToken to burn from caller\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n}\n"
    },
    "contracts/mock/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./MockToken.sol\";\n\ncontract MockWETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    receive() external payable {}\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        (bool sent, ) = msg.sender.call{ value: wad }(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/mock/MockStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./MockToken.sol\";\n\ncontract MockStETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    /// @dev To account for the fact that the balance increases we can simply mint stETH to the concerned address\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    receive() external payable {}\n\n    function submit(address) external payable returns (uint256) {\n        _mint(msg.sender, msg.value);\n        return msg.value;\n    }\n}\n"
    },
    "contracts/mock/MockANGLE.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockANGLE is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'ANGLE')\n    /// @param symbol_ the stablecoin symbol ('ANGLE')\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\n\n    /// @notice allow to mint\n    /// @param account the account to mint to\n    /// @param amount the amount to mint\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    /// @notice allow to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of agToken to burn from caller\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n}\n"
    },
    "contracts/mock/MockAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/external/aave/IAave.sol\";\n\ncontract MockAave is\n    IAToken,\n    ERC20,\n    IAaveIncentivesController,\n    ILendingPool,\n    ILendingPoolAddressesProvider,\n    IReserveInterestRateStrategy,\n    IStakedAave\n{\n    using SafeERC20 for IERC20;\n\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    IERC20 public token; // Interface for the token\n\n    uint256 public constant BASE = 10**27;\n\n    uint256 public distributionEnd = type(uint256).max;\n    uint256 public emissionsPerSecond = 10;\n    uint256 public unstakeWindow = type(uint256).max;\n    uint256 public stakersCooldownsValue = 0;\n    uint128 public currentLiquidityRate = 0;\n    uint256 public rewardsBalance = 0;\n\n    mapping(address => uint256) public reserveNormalizedIncomes; // Mapping between an underlying asset and its reserveNoramlized income\n\n    /// @notice constructor\n    /// @param name_ of the token lent\n    /// @param symbol_ of the token lent\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address token_\n    ) ERC20(name_, symbol_) {\n        token = IERC20(token_);\n    }\n\n    function deployNewUnderlying(address underlying) external {\n        reserveNormalizedIncomes[underlying] = BASE;\n    }\n\n    function getReserveNormalizedIncome(address asset) external view returns (uint256) {\n        return reserveNormalizedIncomes[asset] / BASE;\n    }\n\n    function changeReserveNormalizedIncome(uint256 newIncome, address asset) external {\n        reserveNormalizedIncomes[asset] = newIncome * BASE;\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external override {\n        IERC20 underlying = IERC20(asset);\n        underlying.safeTransferFrom(msg.sender, address(this), amount);\n        // With Aave the amount of cToken is exactly what has been given\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        _mint(onBehalfOf, (amount * BASE) / reserveNormalizedIncome_); // Here we don't exactly respect what Aave is doing\n        emit Minting(onBehalfOf, msg.sender, amount);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        uint256 amountcToken = (amount * BASE) / reserveNormalizedIncome_;\n        burn(msg.sender, amountcToken);\n        uint256 amountToken = (amountcToken * reserveNormalizedIncome_) / BASE;\n        token.safeTransfer(to, amountToken);\n        return (amountToken);\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function getIncentivesController() external view override returns (IAaveIncentivesController) {\n        return IAaveIncentivesController(address(this));\n    }\n\n    function getRewardsBalance(address[] calldata, address) external view override returns (uint256) {\n        return rewardsBalance;\n    }\n\n    function setRewardsBalance(uint256 _rewardsBalance) external {\n        rewardsBalance = _rewardsBalance;\n    }\n\n    function claimRewards(\n        address[] calldata,\n        uint256,\n        address\n    ) external override returns (uint256) {\n        return uint256(0);\n    }\n\n    function getDistributionEnd() external view override returns (uint256) {\n        return distributionEnd;\n    }\n\n    function setDistributionEnd(uint256 _distributionEnd) external {\n        distributionEnd = _distributionEnd;\n    }\n\n    function getAssetData(address)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (0, emissionsPerSecond, 0);\n    }\n\n    function setEmissionsPerSecond(uint256 _emissionsPerSecond) external {\n        emissionsPerSecond = _emissionsPerSecond;\n    }\n\n    function setCurrentLiquidityRate(uint128 _liquidityRate) external {\n        currentLiquidityRate = _liquidityRate;\n    }\n\n    function getReserveData(address) external view override returns (DataTypes.ReserveData memory) {\n        return\n            DataTypes.ReserveData(\n                DataTypes.ReserveConfigurationMap(uint256(0)),\n                uint128(0),\n                uint128(0),\n                currentLiquidityRate,\n                uint128(0),\n                uint128(0),\n                uint40(0),\n                address(this),\n                address(this),\n                address(this),\n                address(this),\n                uint8(0)\n            );\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return address(this);\n    }\n\n    function calculateInterestRates(\n        address reserve,\n        uint256 utilizationRate,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        override\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        )\n    {\n        return (0.04 ether, 0.04 ether, 0.04 ether);\n    }\n\n    function stake(address to, uint256 amount) external override {}\n\n    function redeem(address to, uint256 amount) external override {}\n\n    function cooldown() external override {}\n\n    function claimRewards(address to, uint256 amount) external override {}\n\n    function getTotalRewardsBalance(address) external view override returns (uint256) {}\n\n    function COOLDOWN_SECONDS() external view override returns (uint256) {\n        return 0;\n    }\n\n    function stakersCooldowns(address) external view override returns (uint256) {\n        return stakersCooldownsValue;\n    }\n\n    function UNSTAKE_WINDOW() external view override returns (uint256) {\n        return unstakeWindow;\n    }\n\n    function setUnstakeWindowAndStakers(uint256 _unstakeWindow, uint256 _stakersCooldownsValue) external {\n        unstakeWindow = _unstakeWindow;\n        stakersCooldownsValue = _stakersCooldownsValue;\n    }\n}\n\ncontract MockProtocolDataProvider is IProtocolDataProvider {\n    address public aave;\n    uint256 public availableLiquidityStorage = 0;\n\n    constructor(address _aave) {\n        aave = _aave;\n    }\n\n    function ADDRESSES_PROVIDER() external view override returns (ILendingPoolAddressesProvider) {\n        return ILendingPoolAddressesProvider(aave);\n    }\n\n    function getReserveConfigurationData(address)\n        external\n        view\n        override\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        )\n    {\n        return (uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), true, true, true, true, true);\n    }\n\n    function setAvailableLiquidity(uint256 _availableLiquidity) external {\n        availableLiquidityStorage = _availableLiquidity;\n    }\n\n    function getReserveData(address)\n        external\n        view\n        override\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        availableLiquidity = availableLiquidityStorage;\n        return (\n            availableLiquidity,\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint40(0)\n        );\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/IAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport { DataTypes } from \"./DataTypes.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAaveIncentivesController {\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    function getDistributionEnd() external view returns (uint256);\n\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n\ninterface IAToken is IERC20 {\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n\ninterface ILendingPool {\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n}\n\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\n\ninterface IProtocolDataProvider {\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n}\n\ninterface IReserveInterestRateStrategy {\n    function calculateInterestRates(\n        address reserve,\n        uint256 utilizationRate,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n}\n\ninterface IStakedAave {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address) external view returns (uint256);\n\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function stakersCooldowns(address) external view returns (uint256);\n\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/aave/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n}\n"
    },
    "contracts/staking/AngleDistributorEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../interfaces/IGaugeController.sol\";\nimport \"../interfaces/ILiquidityGauge.sol\";\nimport \"../interfaces/IAngleMiddlemanGauge.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\n/// @title AngleDistributorEvents\n/// @author Angle Core Team\n/// @notice All the events used in `AngleDistributor` contract\ncontract AngleDistributorEvents {\n    event DelegateGaugeUpdated(address indexed _gaugeAddr, address indexed _delegateGauge);\n    event DistributionsToggled(bool _distributionsOn);\n    event GaugeControllerUpdated(address indexed _controller);\n    event GaugeToggled(address indexed gaugeAddr, bool newStatus);\n    event InterfaceKnownToggled(address indexed _delegateGauge, bool _isInterfaceKnown);\n    event RateUpdated(uint256 _newRate);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n    event RewardDistributed(address indexed gaugeAddr, uint256 rewardTally);\n    event UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface IGaugeController {\n    //solhint-disable-next-line\n    function gauge_types(address addr) external view returns (int128);\n\n    //solhint-disable-next-line\n    function gauge_relative_weight_write(address addr, uint256 timestamp) external returns (uint256);\n\n    //solhint-disable-next-line\n    function gauge_relative_weight(address addr, uint256 timestamp) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface ILiquidityGauge {\n    // solhint-disable-next-line\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IAngleMiddlemanGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ninterface IAngleMiddlemanGauge {\n    function notifyReward(address gauge, uint256 amount) external;\n}\n"
    },
    "contracts/feeManager/FeeManagerEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IFeeManager.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStableMaster.sol\";\nimport \"../interfaces/IPerpetualManager.sol\";\n\n/// @title FeeManagerEvents\n/// @author Angle Core Team\n/// @dev This file contains all the events that are triggered by the `FeeManager` contract\ncontract FeeManagerEvents {\n    event UserAndSLPFeesUpdated(\n        uint256 _collatRatio,\n        uint64 _bonusMalusMint,\n        uint64 _bonusMalusBurn,\n        uint64 _slippage,\n        uint64 _slippageFee\n    );\n\n    event FeeMintUpdated(uint256[] _xBonusMalusMint, uint64[] _yBonusMalusMint);\n\n    event FeeBurnUpdated(uint256[] _xBonusMalusBurn, uint64[] _yBonusMalusBurn);\n\n    event SlippageUpdated(uint256[] _xSlippage, uint64[] _ySlippage);\n\n    event SlippageFeeUpdated(uint256[] _xSlippageFee, uint64[] _ySlippageFee);\n\n    event HaFeesUpdated(uint64 _haFeeDeposit, uint64 _haFeeWithdraw);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable {\n    function __IGovernor_init() internal initializer {\n        __IGovernor_init_unchained();\n    }\n\n    function __IGovernor_init_unchained() internal initializer {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast.\n     *\n     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = For, 1 = Against, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev block number used to retrieve user's votes and quorum.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev timestamp at which votes close.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev delay, in number of blocks, between the vote start and vote ends.\n     *\n     * Note: the {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snaphot used for counting vote. This allows to scale the\n     * quroum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal initializer {\n        __IGovernor_init_unchained();\n        __IGovernorTimelock_init_unchained();\n    }\n\n    function __IGovernorTimelock_init_unchained() internal initializer {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"../TimelockControllerUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (an ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {\n    TimelockControllerUpgradeable private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __IGovernorTimelock_init_unchained();\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal initializer {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {\n        return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-state} function with added support for the `Queued` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return status;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overriden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled and executed using the {Governor} workflow.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/TimersUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several function to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {getVotes}\n * - Additionanly, the {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable {\n    using SafeCastUpgradeable for uint256;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    struct ProposalCore {\n        TimersUpgradeable.BlockNumber voteStart;\n        TimersUpgradeable.BlockNumber voteEnd;\n        bool executed;\n        bool canceled;\n    }\n\n    string private _name;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    /**\n     * @dev Restrict access to governor executing address. Some module might override the _executor function to make\n     * sure this modifier is consistant with the execution model.\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __EIP712_init_unchained(name_, version());\n        __IGovernor_init_unchained();\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal initializer {\n        _name = name_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IGovernorUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the RLC encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * accross multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore memory proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (proposal.voteStart.isPending()) {\n            return ProposalState.Pending;\n        } else if (proposal.voteEnd.isPending()) {\n            return ProposalState.Active;\n        } else if (proposal.voteEnd.isExpired()) {\n            return\n                _quorumReached(proposalId) && _voteSucceeded(proposalId)\n                    ? ProposalState.Succeeded\n                    : ProposalState.Defeated;\n        } else {\n            revert(\"Governor: unknown proposal id\");\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart.getDeadline();\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd.getDeadline();\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Register a vote with a given support and voting weight.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual;\n\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n\n        emit ProposalCreated(\n            proposalId,\n            _msgSender(),\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overriden to implement different execution mechanism\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = getVotes(account, proposal.voteStart.getDeadline());\n        _countVote(proposalId, account, support, weight);\n\n        emit VoteCast(account, proposalId, support, weight, reason);\n\n        return weight;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    function __TimelockController_init(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __TimelockController_init_unchained(minDelay, proposers, executors);\n    }\n\n    function __TimelockController_init_unchained(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal initializer {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/TimersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary TimersUpgradeable {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n"
    },
    "contracts/mock/MockGovernor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorProposalThresholdUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract MockGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorProposalThresholdUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorTimelockControlUpgradeable\n{\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n    event VotingDelayUpdated(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodUpdated(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdUpdated(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _quorum;\n    uint256 private _proposalThreshold;\n\n    function initialize(ERC20VotesUpgradeable _token, TimelockControllerUpgradeable _timelock) public initializer {\n        __Governor_init(\"Angle Governor\");\n        __GovernorProposalThreshold_init();\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(_token);\n        __GovernorTimelockControl_init(_timelock);\n\n        _votingDelay = 2; // 2 blocks\n        _votingPeriod = 2; // 2 blocks\n        _quorum = 25_000_000e18; // 25M ANGLE\n        _proposalThreshold = 2500_000e18; // 2M5 ANGLE\n    }\n\n    /// @notice Returns the voting delay\n    function votingDelay() public view override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /// @notice Returns the voting period\n    function votingPeriod() public view override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /// @notice Returns the quorum\n    function quorum(uint256 blockNumber) public view override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _quorum;\n    }\n\n    /// @notice Returns the proposal threshold\n    function proposalThreshold() public view override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /// @notice Sets the voting delay\n    /// @param newVotingDelay New voting delay\n    function setVotingDelay(uint256 newVotingDelay) public onlyGovernance {\n        uint256 oldVotingDelay = _votingDelay;\n        _votingDelay = newVotingDelay;\n        emit VotingDelayUpdated(oldVotingDelay, newVotingDelay);\n    }\n\n    /// @notice Sets the voting period\n    /// @param newVotingPeriod New voting period\n    function setVotingPeriod(uint256 newVotingPeriod) public onlyGovernance {\n        uint256 oldVotingPeriod = _votingPeriod;\n        _votingPeriod = newVotingPeriod;\n        emit VotingPeriodUpdated(oldVotingPeriod, newVotingPeriod);\n    }\n\n    /// @notice Sets the quorum\n    /// @param newQuorum New quorum\n    function setQuorum(uint256 newQuorum) public onlyGovernance {\n        uint256 oldQuorum = _quorum;\n        _quorum = newQuorum;\n        emit QuorumUpdated(oldQuorum, newQuorum);\n    }\n\n    /// @notice Sets the proposal threshold\n    /// @param newProposalThreshold Proposal threshold\n    function setProposalThreshold(uint256 newProposalThreshold) public onlyGovernance {\n        uint256 oldProposalThreshold = _proposalThreshold;\n        _proposalThreshold = newProposalThreshold;\n        emit ProposalThresholdUpdated(oldProposalThreshold, newProposalThreshold);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function getVotes(address account, uint256 blockNumber)\n        public\n        view\n        override(IGovernorUpgradeable, GovernorVotesUpgradeable)\n        returns (uint256)\n    {\n        return super.getVotes(account, blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    )\n        public\n        override(GovernorUpgradeable, GovernorProposalThresholdUpgradeable, IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorProposalThresholdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for proposal restriction to token holders with a minimum balance.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorProposalThresholdUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorProposalThreshold_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorProposalThreshold_init_unchained();\n    }\n\n    function __GovernorProposalThreshold_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(\n            getVotes(msg.sender, block.number - 1) >= proposalThreshold(),\n            \"GovernorCompatibilityBravo: proposer votes below proposal threshold\"\n        );\n\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256);\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorCountingSimple_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorCountingSimple_init_unchained();\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be scritly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"../../utils/math/MathUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    ERC20VotesUpgradeable public token;\n\n    function __GovernorVotes_init(ERC20VotesUpgradeable tokenAddress) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __IGovernor_init_unchained();\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(ERC20VotesUpgradeable tokenAddress) internal initializer {\n        token = tokenAddress;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {IGovernor-getVotes}).\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return token.getPastVotes(account, blockNumber);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/dao/Governor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorProposalThresholdUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Governor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorProposalThresholdUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorTimelockControlUpgradeable\n{\n    event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n    event VotingDelayUpdated(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodUpdated(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdUpdated(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _quorum;\n    uint256 private _proposalThreshold;\n\n    function initialize(ERC20VotesUpgradeable _token, TimelockControllerUpgradeable _timelock) public initializer {\n        __Governor_init(\"Angle Governor\");\n        __GovernorProposalThreshold_init();\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(_token);\n        __GovernorTimelockControl_init(_timelock);\n\n        _votingDelay = 545; // 2 hours\n        _votingPeriod = 19636; // 3 day\n        _quorum = 25_000_000e18; // 25M ANGLE\n        _proposalThreshold = 2500_000e18; // 2M5 ANGLE\n    }\n\n    /// @notice Returns the voting delay\n    function votingDelay() public view override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /// @notice Returns the voting period\n    function votingPeriod() public view override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /// @notice Returns the quorum\n    function quorum(uint256 blockNumber) public view override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _quorum;\n    }\n\n    /// @notice Returns the proposal threshold\n    function proposalThreshold() public view override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /// @notice Sets the voting delay\n    /// @param newVotingDelay New voting delay\n    function setVotingDelay(uint256 newVotingDelay) public onlyGovernance {\n        uint256 oldVotingDelay = _votingDelay;\n        _votingDelay = newVotingDelay;\n        emit VotingDelayUpdated(oldVotingDelay, newVotingDelay);\n    }\n\n    /// @notice Sets the voting period\n    /// @param newVotingPeriod New voting period\n    function setVotingPeriod(uint256 newVotingPeriod) public onlyGovernance {\n        uint256 oldVotingPeriod = _votingPeriod;\n        _votingPeriod = newVotingPeriod;\n        emit VotingPeriodUpdated(oldVotingPeriod, newVotingPeriod);\n    }\n\n    /// @notice Sets the quorum\n    /// @param newQuorum New quorum\n    function setQuorum(uint256 newQuorum) public onlyGovernance {\n        uint256 oldQuorum = _quorum;\n        _quorum = newQuorum;\n        emit QuorumUpdated(oldQuorum, newQuorum);\n    }\n\n    /// @notice Sets the proposal threshold\n    /// @param newProposalThreshold Proposal threshold\n    function setProposalThreshold(uint256 newProposalThreshold) public onlyGovernance {\n        uint256 oldProposalThreshold = _proposalThreshold;\n        _proposalThreshold = newProposalThreshold;\n        emit ProposalThresholdUpdated(oldProposalThreshold, newProposalThreshold);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function getVotes(address account, uint256 blockNumber)\n        public\n        view\n        override(IGovernorUpgradeable, GovernorVotesUpgradeable)\n        returns (uint256)\n    {\n        return super.getVotes(account, blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    )\n        public\n        override(GovernorUpgradeable, GovernorProposalThresholdUpgradeable, IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/mock/MockSanToken/MockUpgradeSanToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\nimport \"../../interfaces/IPoolManager.sol\";\nimport \"./IMockUpgradeSanToken.sol\";\nimport \"../../interfaces/IStableMaster.sol\";\n\ncontract MockUpgradeSanToken is IMockUpgradeSanToken, ERC20PermitUpgradeable {\n    uint8 public decimal;\n    address public override stableMaster;\n    address public override poolManager;\n\n    // Random functions added for testing storage collision\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#storage-collisions-between-implementation-versions\n    uint256 public var7;\n    uint256 public var8;\n    address public var9;\n    address public var10;\n    uint256 public var11;\n    uint256 public var12;\n\n    uint256 public a;\n    uint256 public b;\n    address public c;\n    address public d;\n    uint256 public e;\n    uint256 public f;\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address _poolManager\n    ) public initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        poolManager = _poolManager;\n        stableMaster = IPoolManager(poolManager).stableMaster();\n        decimal = IERC20MetadataUpgradeable(IPoolManager(poolManager).token()).decimals();\n    }\n\n    modifier onlyStableMaster() {\n        require(msg.sender == stableMaster, \"1\");\n        _;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    function burnNoRedeem(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    // Only change: added \"randomParam\"\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 randomParam\n    ) external override returns (uint256) {\n        _mint(account, amount);\n        return randomParam;\n    }\n\n    function burnSelf(uint256 amount, address burner) external override onlyStableMaster {\n        _burn(burner, amount);\n    }\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external override onlyStableMaster {\n        uint256 currentAllowance = allowance(burner, sender);\n        require(currentAllowance >= amount, \"23\");\n        _approve(burner, sender, currentAllowance - amount);\n        _burn(burner, amount);\n    }\n}\n"
    },
    "contracts/mock/MockSanToken/IMockUpgradeSanToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title ISanToken\n/// @author Angle Core Team\n/// @notice Interface for Angle's `SanToken` contract, that handles sanTokens, tokens that are given to SLPs\n/// contributing to a collateral for a given stablecoin\ninterface IMockUpgradeSanToken is IERC20Upgradeable {\n    // ================================== StableMaster =============================\n\n    function mint(\n        address account,\n        uint256 amount,\n        uint256 randomParam\n    ) external returns (uint256);\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    function stableMaster() external view returns (address);\n\n    function poolManager() external view returns (address);\n}\n"
    },
    "contracts/collateralSettler/CollateralSettlerERC20Events.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/ICollateralSettler.sol\";\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IPerpetualManager.sol\";\nimport \"../interfaces/ISanToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\n\n/// @title CollateralSettlerERC20Events\n/// @author Angle Core Team\n/// @notice All the events used in `CollateralSettlerERC20` contract\ncontract CollateralSettlerERC20Events {\n    event CollateralSettlerInit(address indexed poolManager, address indexed angle, uint256 claimTime);\n\n    event SettlementTriggered(uint256 _amountToRedistribute);\n\n    event UserClaimGovUpdated(uint256 userClaimGov);\n\n    event UserClaimUpdated(uint256 userClaim);\n\n    event LPClaimGovUpdated(uint256 lpClaimGov);\n\n    event LPClaimUpdated(uint256 lpClaim);\n\n    event AmountToRedistributeAnnouncement(\n        uint256 baseAmountToUserGov,\n        uint256 baseAmountToUser,\n        uint256 baseAmountToLpGov,\n        uint256 baseAmountToLp,\n        uint256 amountToRedistribute\n    );\n\n    event AmountRedistributeUpdated(uint256 amountRedistribute);\n\n    event ProportionalRatioGovUpdated(uint64 proportionalRatioGovUser, uint64 proportionalRatioGovLP);\n\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n}\n"
    },
    "contracts/mock/MockBot.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IRewardsDistributor.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\nimport \"../interfaces/IBondingCurve.sol\";\nimport \"../interfaces/IAgToken.sol\";\n\n// Contract we have to fix flash attacks\ncontract MockBot {\n    function distributorDrip(address distributor, address stakingContract) public {\n        IRewardsDistributor(distributor).drip(IStakingRewards(stakingContract));\n    }\n\n    function buyANGLEFromBondingCurve(\n        address bondingCurve,\n        address agToken,\n        uint256 targetANGLEQuantity\n    ) public {\n        IBondingCurve(bondingCurve).buySoldToken(IAgToken(agToken), targetANGLEQuantity, type(uint256).max);\n    }\n}\n"
    },
    "contracts/interfaces/IBondingCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IAgToken.sol\";\nimport \"./IOracle.sol\";\n\n/// @title IBondingCurve\n/// @author Angle Core Team\n/// @notice Interface for the `BondingCurve` contract\ninterface IBondingCurve {\n    // ============================ User Functions =================================\n\n    function buySoldToken(\n        IAgToken _agToken,\n        uint256 targetSoldTokenQuantity,\n        uint256 maxAmountToPayInAgToken\n    ) external;\n\n    // ========================== Governance Functions =============================\n\n    function changeOracle(IAgToken _agToken, IOracle _oracle) external;\n}\n"
    },
    "contracts/bondingCurve/BondingCurveEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IBondingCurve.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n/// @title BondingCurveEvents\n/// @author Angle Core Team\n/// @notice All the events used in `BondingCurve` contract\ncontract BondingCurveEvents {\n    event BondingCurveInit(uint256 _startPrice, address indexed _soldToken);\n\n    event StartPriceUpdated(uint256 _startPrice);\n\n    event TokensToSellUpdated(uint256 _tokensToSell);\n\n    event TokenSale(uint256 _quantityOfANGLESold, address indexed _stableCoinUsed, uint256 _amountToPayInAgToken);\n\n    event ModifiedStablecoin(address indexed _agToken, bool _isReference, address indexed _oracle);\n\n    event RevokedStablecoin(address indexed _agToken);\n\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n}\n"
    },
    "contracts/mock/MockUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Mock contract to get access to the price of a token\ncontract MockUniswapV2Router is IUniswapV2Router {\n    using SafeERC20 for IERC20;\n    uint256 public price;\n\n    constructor(uint256 _price) {\n        price = _price;\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] calldata) external view override returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](1);\n        // Assumes same basis between want and COMP or AAVE (like 18)\n        // And price should be a small amount like 10 -> a price of 10\n        result[0] = price * amountIn;\n        return result;\n    }\n\n    function setPrice(uint256 _price) external {\n        price = _price;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 swapAmount,\n        uint256 minAmount,\n        address[] calldata path,\n        address,\n        uint256\n    ) external override {\n        IERC20(path[0]).safeTransferFrom(msg.sender, address(this), swapAmount);\n        require(swapAmount * price >= minAmount, \"15\");\n        IERC20(path[path.length - 1]).safeTransfer(msg.sender, swapAmount * price);\n    }\n}\n"
    },
    "contracts/mock/MockLiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/ILiquidityGauge.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice MockLiquidityGauge contract\ncontract MockLiquidityGauge is ILiquidityGauge {\n    using SafeERC20 for IERC20;\n    mapping(address => uint256) public checkpoints;\n    uint256 public factor = 10**18;\n    event NotifiedAmount(address _gauge, uint256 amount);\n\n    IERC20 public token;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    // solhint-disable-next-line\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external override {\n        IERC20(_rewardToken).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function setFactor(uint256 _factor) external {\n        factor = _factor;\n    }\n\n    function notifyReward(address _gauge, uint256 amount) external {\n        emit NotifiedAmount(_gauge, amount);\n    }\n}\n"
    },
    "contracts/mock/MockFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Mock FeeDistributor contract\ncontract MockFeeDistributor is IFeeDistributor {\n    using SafeERC20 for IERC20;\n\n    constructor() {}\n\n    function burn(address token) external override {\n        IERC20(token).safeTransferFrom(msg.sender, address(this), IERC20(token).balanceOf(msg.sender));\n    }\n}\n"
    },
    "contracts/mock/MockCurveStETHETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contract we have to fix flash attacks\ncontract MockCurveStETHETH {\n    using SafeERC20 for IERC20;\n\n    address public stETH;\n    uint256 public dy;\n\n    constructor(address _stETH) {\n        stETH = _stETH;\n        dy = 10**18;\n    }\n\n    receive() external payable {}\n\n    function exchange(\n        int128 from,\n        int128 to,\n        uint256 _from_amount,\n        uint256 _min_to_amount\n    ) external payable {\n        if (from == 0 && to == 1) {\n            IERC20(stETH).transfer(msg.sender, (msg.value * dy) / 10**18);\n        } else {\n            IERC20(stETH).transferFrom(msg.sender, address(this), _from_amount);\n            (bool sent, ) = msg.sender.call{ value: (_from_amount * 10**18) / dy }(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n\n    function setDy(uint256 _dy) external {\n        dy = _dy;\n    }\n\n    function get_dy(\n        int128 from,\n        int128 to,\n        uint256 _from_amount\n    ) external view returns (uint256) {\n        return (_from_amount * dy) / 10**18;\n    }\n}\n"
    },
    "contracts/bondingCurve/BondingCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./BondingCurveEvents.sol\";\n\n/// @title BondingCurve\n/// @author Angle Core Team\n/// @notice Enables anyone to buy ANGLE governance token or any type of token following a bonding\n/// curve using stablecoins of the protocol\ncontract BondingCurve is BondingCurveEvents, IBondingCurve, AccessControl, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only: governor can change an oracle contract, recover tokens\n    /// or take actions that are going to modify the price of the tokens\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Base used to compute ratios and floating numbers\n    uint256 public constant BASE_TOKENS = 1e18;\n\n    // ============================ References to contracts ========================\n\n    /// @notice Interface for the token sold by this contract, most likely ANGLE tokens\n    IERC20 public immutable soldToken;\n\n    /// @notice Address of the reference coin, the one other stablecoins are converted to\n    /// @dev If the reference is not a stablecoin that can be used to buy tokens with this contract,\n    /// this is set to 0\n    /// @dev The reference stablecoin may change, but it would imply a change in all oracles,\n    /// so it's important to be wary when updating it\n    /// @dev The reference does not necessarily have to be an accepted stablecoin by the system\n    address public referenceCoin = address(0);\n\n    // ============================ Parameters =====================================\n\n    /// @notice Start price at which the bonding curve will sell\n    /// This price will be expressed in a reference (most likely USD or EUR)\n    uint256 public startPrice;\n\n    /// @notice Number of tokens to sell with this contract. It can be either increased or decreased\n    uint256 public totalTokensToSell;\n\n    /// @notice Number of tokens sold so far. It should be inferior to `totalTokensToSell`\n    uint256 public tokensSold;\n\n    /// @notice Maps a stablecoin that can be used to buy the token to the oracle contract that gives the price\n    /// of the coin with respect to the reference stablecoin\n    mapping(IAgToken => IOracle) public allowedStablecoins;\n\n    // ============================ Modifier =======================================\n\n    /// @notice Checks if the stablecoin is valid\n    /// @dev This modifier verifies if there is an oracle associated to this contract or if this coin\n    /// is the reference coin\n    /// @dev It checks at the same time if `token` is non null. If `token` is not the reference then\n    /// `allowedStablecoins[address(0)] == address(0)`\n    modifier isValid(IAgToken token) {\n        require(\n            (address(allowedStablecoins[token]) != address(0)) ||\n                (referenceCoin == address(token) && referenceCoin != address(0)),\n            \"45\"\n        );\n        _;\n    }\n\n    // ============================ Constructor ====================================\n\n    /// @notice Initializes the `BondingCurve` contract\n    /// @param governorList List of the governor addresses of the protocol\n    /// @param guardian Address of the guardian\n    /// @param _startPrice Start price of the token, it converts an amount of reference stablecoins to an amount\n    /// of sold tokens (most of the time ANGLE tokens)\n    /// @param _soldToken Token that it will be possible to buy using this contract\n    constructor(\n        address[] memory governorList,\n        address guardian,\n        uint256 _startPrice,\n        IERC20 _soldToken\n    ) {\n        require(guardian != address(0) && address(_soldToken) != address(0), \"0\");\n        // Access control\n        for (uint256 i = 0; i < governorList.length; i++) {\n            require(governorList[i] != address(0), \"0\");\n            _setupRole(GOVERNOR_ROLE, governorList[i]);\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n\n        startPrice = _startPrice;\n        soldToken = _soldToken;\n\n        emit BondingCurveInit(startPrice, address(_soldToken));\n    }\n\n    // ============================ Main Function ==================================\n\n    /// @notice Lets `msg.sender` buy tokens (ANGLE tokens normally) against an allowed token (a stablecoin normally)\n    /// @param _agToken Reference to the agToken used, that is the stablecoin used to buy the token associated to this\n    /// bonding curve\n    /// @param targetSoldTokenQuantity Target quantity of tokens to buy\n    /// @param maxAmountToPayInAgToken Maximum amount to pay in agTokens that the user is willing to pay to buy the\n    /// `targetSoldTokenQuantity`\n    function buySoldToken(\n        IAgToken _agToken,\n        uint256 targetSoldTokenQuantity,\n        uint256 maxAmountToPayInAgToken\n    ) external override whenNotPaused isValid(_agToken) {\n        require(targetSoldTokenQuantity > 0, \"4\");\n        // Computing the number of reference stablecoins to burn to get the desired quantity\n        // of tokens sold by this contract\n        uint256 amountToPayInReference = _computePriceFromQuantity(targetSoldTokenQuantity);\n\n        uint256 amountToPayInAgToken;\n        // The validity of the stablecoin has already been checked\n        if (address(_agToken) == referenceCoin) {\n            amountToPayInAgToken = amountToPayInReference;\n        } else {\n            // Converting a number of reference stablecoin to a number of desired stablecoin\n            // using the oracle associated to each accepted stablecoin\n            IOracle oracle = allowedStablecoins[_agToken];\n            uint256 oracleValue = oracle.readLower();\n            // There is no base problem here as it is a conversion between two Angle's agTokens\n            // which are in base `BASE_TOKENS`\n            amountToPayInAgToken = (amountToPayInReference * BASE_TOKENS) / oracleValue;\n        }\n        require(amountToPayInAgToken > 0 && amountToPayInAgToken <= maxAmountToPayInAgToken, \"50\");\n\n        // Transferring the correct amount of agToken\n        _agToken.transferFrom(msg.sender, address(this), amountToPayInAgToken);\n\n        emit TokenSale(targetSoldTokenQuantity, address(_agToken), amountToPayInAgToken);\n        // Updating the internal variables\n        tokensSold += targetSoldTokenQuantity;\n\n        // Transfering the sold tokens to the caller\n        soldToken.safeTransfer(msg.sender, targetSoldTokenQuantity);\n    }\n\n    // ============================ View Functions =================================\n\n    /// @notice Returns the current price of the token (expressed in reference)\n    /// @dev This is an external utility function\n    /// @dev More generally than the expression used, the value of the price is:\n    /// `startPrice / (1 - tokensSoldInTx / tokensToSellInTotal) ^ 2`\n    /// @dev The precision of this function is not that important as it is a view function anyone can query\n    function getCurrentPrice() external view returns (uint256) {\n        if (_getQuantityLeftToSell() == 0) {\n            return 0;\n        }\n        return (totalTokensToSell**2 * startPrice) / ((totalTokensToSell - tokensSold)**2);\n    }\n\n    /// @notice Returns the quantity of governance tokens that are still to be sold\n    function getQuantityLeftToSell() external view returns (uint256) {\n        return _getQuantityLeftToSell();\n    }\n\n    /// @notice Returns the amount to pay for the desired amount of ANGLE to buy\n    /// @param targetQuantity Quantity of ANGLE tokens to buy\n    /// @dev This is an utility function that can be queried before buying tokens\n    function computePriceFromQuantity(uint256 targetQuantity) external view returns (uint256) {\n        return _computePriceFromQuantity(targetQuantity);\n    }\n\n    // ============================ GOVERNANCE =====================================\n\n    // ========================== Governor Functions ===============================\n\n    /// @notice Transfers tokens from the bonding curve to another address\n    /// @param tokenAddress Address of the token to recover\n    /// @param amountToRecover Amount of tokens to transfer\n    /// @param to Destination address\n    /// @dev This function automatically updates the amount of tokens to sell and hence the price of the tokens\n    /// in case the token recovered is the token handled by this contract\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (tokenAddress == address(soldToken)) {\n            // Updating the number of tokens to sell\n            _changeTokensToSell(totalTokensToSell - amountToRecover);\n            // No need to check the balance here\n            soldToken.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Changes the oracle associated to a stablecoin\n    /// @param _agToken Reference to the agToken\n    /// @param _oracle Reference to the oracle that will be used to have the price of this stablecoin in reference\n    /// @dev Oracle contract should give a price with respect to reference\n    /// @dev This function should only be called by governance as it can be used to manipulate prices\n    function changeOracle(IAgToken _agToken, IOracle _oracle)\n        external\n        override\n        onlyRole(GOVERNOR_ROLE)\n        isValid(_agToken)\n    {\n        require((address(_oracle) != address(0)), \"51\");\n        allowedStablecoins[_agToken] = _oracle;\n        emit ModifiedStablecoin(address(_agToken), referenceCoin == address(_agToken), address(_oracle));\n    }\n\n    /// @notice Allows a new stablecoin\n    /// @param _agToken Reference to the agToken\n    /// @param _oracle Reference to the oracle that will be used to have the price of this stablecoin in reference\n    /// @param _isReference Whether this stablecoin will be the reference for oracles\n    /// @dev To set a new reference coin, the old reference must have been revoked before\n    /// @dev Calling this function for a stablecoin that already exists will just change its oracle if the\n    /// agToken was already reference, and also set a new reference if the coin was already existing\n    /// @dev Since this function could be used to deploy a new stablecoin with a really low oracle value, it has\n    /// been made governor only\n    function allowNewStablecoin(\n        IAgToken _agToken,\n        IOracle _oracle,\n        uint256 _isReference\n    ) external onlyRole(GOVERNOR_ROLE) {\n        require((_isReference == 0) || (_isReference == 1), \"9\");\n        require(address(_agToken) != address(0), \"40\");\n        // It is impossible to change reference if the reference has not been revoked before\n        // There is an hidden if in the followings require. If `_isReference` is true then\n        // only the first require is important, otherwise only the second matters\n        require((_isReference == 0) || (referenceCoin == address(0)), \"52\");\n        require((_isReference == 1) || (address(_oracle) != address(0)), \"51\");\n\n        if (_isReference == 1) {\n            referenceCoin = address(_agToken);\n        }\n        // Oracle contract should give the price of the stablecoin with respect to the reference stablecoin\n        allowedStablecoins[_agToken] = _oracle;\n\n        emit ModifiedStablecoin(address(_agToken), (_isReference == 1), address(_oracle));\n    }\n\n    /// @notice Changes the start price (in reference)\n    /// @param _startPrice New start price for the formula\n    /// @dev This function may be useful to help re-collateralize the protocol in case of distress\n    /// as it could allow to buy governance tokens at a discount\n    /// @dev As this function can manipulate the price, it has to be governor only\n    function changeStartPrice(uint256 _startPrice) external onlyRole(GOVERNOR_ROLE) {\n        require(_startPrice > 0, \"53\");\n        startPrice = _startPrice;\n\n        emit StartPriceUpdated(_startPrice);\n    }\n\n    /// @notice Changes the total amount of tokens that can be sold with this bonding curve\n    /// @param _totalTokensToSell New total amount of tokens to sell\n    /// @dev As this function can manipulate the price, it has to be governor only\n    function changeTokensToSell(uint256 _totalTokensToSell) external onlyRole(GOVERNOR_ROLE) {\n        _changeTokensToSell(_totalTokensToSell);\n    }\n\n    // ========================== Guardian Functions ===============================\n\n    /// @notice Revokes a stablecoin as a medium of payment\n    /// @param _agToken Reference to the agToken\n    /// @dev If the `referenceCoin` is revoked, contract should be paused to let governance update parameters\n    /// like the `oracle` contracts associated to each allowed stablecoin or the start price\n    /// @dev It is also possible that the contract works without a reference stablecoin: if the reference coin\n    /// was USD but agUSD are no longer accepted, we may still want all the oracles and prices to be expressed\n    /// in USD\n    function revokeStablecoin(IAgToken _agToken) external onlyRole(GUARDIAN_ROLE) {\n        if (referenceCoin == address(_agToken)) {\n            referenceCoin = address(0);\n            _pause();\n        }\n        delete allowedStablecoins[_agToken];\n\n        emit RevokedStablecoin(address(_agToken));\n    }\n\n    /// @notice Pauses the possibility to buy `soldToken` from the contract\n    function pause() external onlyRole(GUARDIAN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses and reactivates the possibility to buy tokens from the contract\n    function unpause() external onlyRole(GUARDIAN_ROLE) {\n        _unpause();\n    }\n\n    // ============================ Internal =======================================\n\n    /// @notice Internal version of the functions that changes the total tokens to sell\n    /// @dev This function checks if the new amount of tokens to sell is compatible with what has already been sold\n    /// and the balance of tokens of the contract\n    /// @dev It can be used to decrease or increase what has already been sold\n    function _changeTokensToSell(uint256 _totalTokensToSell) internal {\n        require(_totalTokensToSell > tokensSold, \"54\");\n        require(soldToken.balanceOf(address(this)) >= _totalTokensToSell - tokensSold, \"56\");\n        totalTokensToSell = _totalTokensToSell;\n\n        emit TokensToSellUpdated(_totalTokensToSell);\n    }\n\n    /// @notice Internal version of `getQuantityLeftToSell`\n    function _getQuantityLeftToSell() internal view returns (uint256) {\n        return totalTokensToSell - tokensSold;\n    }\n\n    /// @notice Internal version of `computePriceFromQuantity`\n    /// @dev In the computation of the price, not all the multiplications are done before the divisions to avoid\n    /// for overflows\n    /// @dev The formula to compute the amount to pay is the integral of a the price over the bounds:\n    /// `tokensSold, tokensSold+targetQuantity`\n    /// @dev The integral computed by this function is the integral of the inverse of a square root\n    function _computePriceFromQuantity(uint256 targetQuantity) internal view returns (uint256 value) {\n        uint256 leftToSell = _getQuantityLeftToSell();\n        require(targetQuantity < leftToSell, \"55\");\n\n        // The global value to compute is (with `power = 2` here):\n        // `startPrice * totalTokensToSell **(power) * (leftToSell ** (power - 1) - (leftToSell - targetQuantity) ** (power - 1)) /((power - 1) * BASE_TOKENS * leftToSell ** (power - 1) * (leftToSell - targetQuantity) ** (power - 1))`\n        // If `totalTokensToSell` is `10**18 * (10**9)` (the maximum we could sell), then `totalTokensToSell ** power` is `(10**27)**power`\n        // And `leftToSell ** (power - 1) ` is inferior to `totalTokensToSell ** power`\n        // In this case the fact that power = 2 simplifies the computation\n        // Computation can hence be done as follows progressively without doing all the multiplications first to avoid overflows\n        value = (totalTokensToSell**2) / leftToSell;\n        value = (value * startPrice) / BASE_TOKENS;\n        value = (value * targetQuantity) / (leftToSell - targetQuantity);\n    }\n}\n"
    },
    "contracts/core/CoreEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../external/AccessControl.sol\";\n\nimport \"../interfaces/ICore.sol\";\nimport \"../interfaces/IAgToken.sol\";\nimport \"../interfaces/IStableMaster.sol\";\n\n/// @title CoreEvents\n/// @author Angle Core Team\n/// @notice All the events used in the `Core` contract\ncontract CoreEvents {\n    event StableMasterDeployed(address indexed _stableMaster, address indexed _agToken);\n\n    event StableMasterRevoked(address indexed _stableMaster);\n\n    event GovernorRoleGranted(address indexed governor);\n\n    event GovernorRoleRevoked(address indexed governor);\n\n    event GuardianRoleChanged(address indexed oldGuardian, address indexed newGuardian);\n\n    event CoreChanged(address indexed newCore);\n}\n"
    },
    "contracts/mock/MockCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../core/CoreEvents.sol\";\n\n/// @title MockCore\n/// @author Angle Core Team\n/// @notice Keeps track of all the `StableMaster` contracts and facilitates governance by allowing the propagation\n/// of changes across most contracts of the protocol (does not include oracle contract, `RewardsDistributor`, and some\n/// other side contracts like `BondingCurve` or `CollateralSettler`)\ncontract MockCore is CoreEvents, ICore {\n    /// @notice Map to track the addresses with a `GOVERNOR_ROLE` within Angle protocol\n    mapping(address => bool) public governorMap;\n\n    /// @notice Map to track the addresses of the `stableMaster` contracts that have already been deployed\n    /// This is used to avoid deploying a revoked `stableMaster` contract again and hence potentially creating\n    /// inconsistencies in the `GOVERNOR_ROLE` and `GUARDIAN_ROLE` of this `stableMaster`\n    mapping(address => bool) public deployedStableMasterMap;\n\n    /// @notice Address of the guardian, it can be revoked by Angle's governance\n    /// The protocol has only one guardian address\n    address public override guardian;\n\n    /// @notice List of the addresses of the `StableMaster` contracts accepted by the system\n    address[] internal _stablecoinList;\n\n    // List of all the governor addresses of Angle's protocol\n    // Initially only the timelock will be appointed governor but new addresses can be added along the way\n    address[] internal _governorList;\n\n    /// @notice Checks to see if the caller is a `governor`\n    /// The reason for having such modifiers rather than OpenZeppelin's Access Control logic is to make\n    /// sure that governors cannot bypass the `addGovernor` or `revokeGovernor` functions\n    modifier onlyGovernor() {\n        require(governorMap[msg.sender], \"1\");\n        _;\n    }\n\n    /// @notice Checks to see if the caller is a `guardian` or a `governor`\n    /// Same here, we do not use OpenZeppelin's Access Control logic to make sure that the `guardian`\n    /// cannot bypass the functions defined on purpose in this contract\n    modifier onlyGuardian() {\n        require(governorMap[msg.sender] || msg.sender == guardian, \"1\");\n        _;\n    }\n\n    /// @notice Checks if the new address given is not null\n    /// @param newAddress Address to check\n    modifier zeroCheck(address newAddress) {\n        require(newAddress != address(0), \"0\");\n        _;\n    }\n\n    // =============================== CONSTRUCTOR =================================\n\n    /// @notice Initializes the `Core` contract\n    /// @param _governor Address of the governor\n    /// @param _guardian Address of the guardian\n    constructor(\n        address _governor,\n        address _guardian,\n        address[] memory stableMasterList\n    ) {\n        // Creating references\n        require(_guardian != address(0) && _governor != address(0), \"0\");\n        require(_guardian != _governor, \"39\");\n        _governorList.push(_governor);\n        guardian = _guardian;\n        governorMap[_governor] = true;\n        for (uint256 i = 0; i < stableMasterList.length; i++) {\n            _stablecoinList.push(stableMasterList[i]);\n        }\n\n        emit GovernorRoleGranted(_governor);\n        emit GuardianRoleChanged(address(0), _guardian);\n    }\n\n    // ========================= GOVERNOR FUNCTIONS ================================\n\n    // ======================== Interactions with `StableMasters` ==================\n\n    /// @notice Changes the `Core` contract of the protocol\n    /// @param newCore Address of the new `Core` contract\n    /// @dev To maintain consistency, checks are performed. The governance of the new `Core`\n    /// contract should be exactly the same of this one, and the `_stablecoinList` should be\n    /// identical\n    function setCore(ICore newCore) external onlyGovernor zeroCheck(address(newCore)) {\n        require(address(this) != address(newCore), \"40\");\n        require(guardian == newCore.guardian(), \"41\");\n        // The length of the lists are stored as cache variables to avoid duplicate reads in storage\n        // Checking the consistency of the `governorList` and of the `_stablecoinList`\n        uint256 governorListLength = _governorList.length;\n        address[] memory _newCoreGovernorList = newCore.governorList();\n        uint256 stablecoinListLength = _stablecoinList.length;\n        address[] memory _newStablecoinList = newCore.stablecoinList();\n        require(\n            governorListLength == _newCoreGovernorList.length && stablecoinListLength == _newStablecoinList.length,\n            \"42\"\n        );\n        uint256 indexMet;\n        for (uint256 i = 0; i < governorListLength; i++) {\n            if (!governorMap[_newCoreGovernorList[i]]) {\n                indexMet = 1;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < stablecoinListLength; i++) {\n            // The stablecoin lists should preserve exactly the same orders of elements\n            if (_stablecoinList[i] != _newStablecoinList[i]) {\n                indexMet = 1;\n                break;\n            }\n        }\n        // Only performing one require, hence making it cheaper for a governance with a correct initia\n        require(indexMet == 0, \"43\");\n        // Propagates the change\n        for (uint256 i = 0; i < stablecoinListLength; i++) {\n            IStableMaster(_stablecoinList[i]).setCore(address(newCore));\n        }\n        emit CoreChanged(address(newCore));\n    }\n\n    /// @notice Adds a new stablecoin to the system\n    /// @param agToken Address of the new `AgToken` contract\n    /// @dev To maintain consistency, the address of the `StableMaster` contract corresponding to the\n    /// `AgToken` is automatically retrieved\n    /// @dev The `StableMaster` receives the reference to the governor and guardian addresses of the protocol\n    /// @dev The `AgToken` and `StableMaster` contracts should have previously been initialized with correct references\n    /// in it, with for the `StableMaster` a reference to the `Core` contract and for the `AgToken` a reference to the\n    /// `StableMaster`\n    function deployStableMaster(address agToken) external onlyGovernor zeroCheck(agToken) {\n        address stableMaster = IAgToken(agToken).stableMaster();\n        // Checking if `stableMaster` has not already been deployed\n        require(!deployedStableMasterMap[stableMaster], \"44\");\n\n        // Storing and initializing information about the stablecoin\n        _stablecoinList.push(stableMaster);\n        // Adding this `stableMaster` in the `deployedStableMasterMap`: it is not going to be possible\n        // to revoke and then redeploy this contract\n        deployedStableMasterMap[stableMaster] = true;\n\n        IStableMaster(stableMaster).deploy(_governorList, guardian, agToken);\n\n        emit StableMasterDeployed(address(stableMaster), agToken);\n    }\n\n    /// @notice Revokes a `StableMaster` contract\n    /// @param stableMaster Address of  the `StableMaster` to revoke\n    /// @dev This function just removes a `StableMaster` contract from the `_stablecoinList`\n    /// @dev The consequence is that the `StableMaster` contract will no longer be affected by changes in\n    /// governor or guardian occuring from the protocol\n    /// @dev This function is mostly here to clean the mappings and save some storage space\n    function revokeStableMaster(address stableMaster) external override onlyGovernor {\n        uint256 stablecoinListLength = _stablecoinList.length;\n        // Checking if `stableMaster` is correct and removing the stablecoin from the `_stablecoinList`\n        require(stablecoinListLength >= 1, \"45\");\n        uint256 indexMet;\n        for (uint256 i = 0; i < stablecoinListLength - 1; i++) {\n            if (_stablecoinList[i] == stableMaster) {\n                indexMet = 1;\n                _stablecoinList[i] = _stablecoinList[stablecoinListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || _stablecoinList[stablecoinListLength - 1] == stableMaster, \"45\");\n        _stablecoinList.pop();\n        // Deleting the stablecoin from the list\n        emit StableMasterRevoked(stableMaster);\n    }\n\n    // =============================== Access Control ==============================\n    // The following functions do not propagate the changes they induce to some bricks of the protocol\n    // like the `CollateralSettler`, the `BondingCurve`, the staking and rewards distribution contracts\n    // and the oracle contracts using Uniswap. Governance should be wary when calling these functions and\n    // make equivalent changes in these contracts to maintain consistency at the scale of the protocol\n\n    /// @notice Adds a new governor address\n    /// @param _governor New governor address\n    /// @dev This function propagates the new governor role across most contracts of the protocol\n    /// @dev Governor is also guardian everywhere in all contracts\n    function addGovernor(address _governor) external override onlyGovernor zeroCheck(_governor) {\n        require(!governorMap[_governor], \"46\");\n        governorMap[_governor] = true;\n        _governorList.push(_governor);\n        emit GovernorRoleGranted(_governor);\n    }\n\n    /// @notice Removes a governor address\n    /// @param _governor Governor address to remove\n    /// @dev There must always be one governor in the protocol\n    function removeGovernor(address _governor) external override onlyGovernor {\n        // Checking if removing the governor will leave with at least more than one governor\n        uint256 governorListLength = _governorList.length;\n        require(governorListLength > 1, \"47\");\n        // Removing the governor from the list of governors\n        // We still need to check if the address provided was well in the list\n        uint256 indexMet;\n        for (uint256 i = 0; i < governorListLength - 1; i++) {\n            if (_governorList[i] == _governor) {\n                indexMet = 1;\n                _governorList[i] = _governorList[governorListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || _governorList[governorListLength - 1] == _governor, \"48\");\n        _governorList.pop();\n        // Once it has been checked that the given address was a correct address, we can proceed to other changes\n        delete governorMap[_governor];\n        // Maintaining consistency across all contracts\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            // We have checked in this contract that the mentionned `_governor` here was well a governor\n            // There is no need to check this in the underlying contracts where this is going to be updated\n            IStableMaster(_stablecoinList[i]).removeGovernor(_governor);\n        }\n\n        emit GovernorRoleRevoked(_governor);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /// @notice Changes the guardian address\n    /// @param _newGuardian New guardian address\n    /// @dev Guardian is able to change by itself the address corresponding to its role\n    /// @dev There can only be one guardian address in the protocol\n    /// @dev The guardian address cannot be a governor address\n    function setGuardian(address _newGuardian) external override onlyGuardian zeroCheck(_newGuardian) {\n        require(!governorMap[_newGuardian], \"39\");\n        require(guardian != _newGuardian, \"49\");\n        address oldGuardian = guardian;\n        guardian = _newGuardian;\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            IStableMaster(_stablecoinList[i]).setGuardian(_newGuardian, oldGuardian);\n        }\n        emit GuardianRoleChanged(oldGuardian, _newGuardian);\n    }\n\n    /// @notice Revokes the guardian address\n    /// @dev Guardian is able to auto-revoke itself\n    /// @dev There can only be one `guardian` address in the protocol\n    function revokeGuardian() external override onlyGuardian {\n        address oldGuardian = guardian;\n        guardian = address(0);\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            IStableMaster(_stablecoinList[i]).revokeGuardian(oldGuardian);\n        }\n        emit GuardianRoleChanged(oldGuardian, address(0));\n    }\n\n    // ========================= VIEW FUNCTIONS ====================================\n\n    /// @notice Returns the list of all the governor addresses of the protocol\n    /// @return `_governorList`\n    /// @dev This getter is used by `StableMaster` contracts deploying new collateral types\n    /// and initializing them with correct references\n    function governorList() external view override returns (address[] memory) {\n        return _governorList;\n    }\n\n    /// @notice Returns the list of all the `StableMaster` addresses of the protocol\n    /// @return `_stablecoinList`\n    /// @dev This getter is used by the `Core` contract when setting a new `Core`\n    function stablecoinList() external view override returns (address[] memory) {\n        return _stablecoinList;\n    }\n}\n"
    },
    "contracts/core/Core.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./CoreEvents.sol\";\n\n/// @title Core\n/// @author Angle Core Team\n/// @notice Keeps track of all the `StableMaster` contracts and facilitates governance by allowing the propagation\n/// of changes across most contracts of the protocol (does not include oracle contract, `RewardsDistributor`, and some\n/// other side contracts like `BondingCurve` or `CollateralSettler`)\ncontract Core is CoreEvents, ICore {\n    /// @notice Map to track the addresses with a `GOVERNOR_ROLE` within Angle protocol\n    mapping(address => bool) public governorMap;\n\n    /// @notice Map to track the addresses of the `stableMaster` contracts that have already been deployed\n    /// This is used to avoid deploying a revoked `stableMaster` contract again and hence potentially creating\n    /// inconsistencies in the `GOVERNOR_ROLE` and `GUARDIAN_ROLE` of this `stableMaster`\n    mapping(address => bool) public deployedStableMasterMap;\n\n    /// @notice Address of the guardian, it can be revoked by Angle's governance\n    /// The protocol has only one guardian address\n    address public override guardian;\n\n    /// @notice List of the addresses of the `StableMaster` contracts accepted by the system\n    address[] internal _stablecoinList;\n\n    // List of all the governor addresses of Angle's protocol\n    // Initially only the timelock will be appointed governor but new addresses can be added along the way\n    address[] internal _governorList;\n\n    /// @notice Checks to see if the caller is a `governor`\n    /// The reason for having such modifiers rather than OpenZeppelin's Access Control logic is to make\n    /// sure that governors cannot bypass the `addGovernor` or `revokeGovernor` functions\n    modifier onlyGovernor() {\n        require(governorMap[msg.sender], \"1\");\n        _;\n    }\n\n    /// @notice Checks to see if the caller is a `guardian` or a `governor`\n    /// Same here, we do not use OpenZeppelin's Access Control logic to make sure that the `guardian`\n    /// cannot bypass the functions defined on purpose in this contract\n    modifier onlyGuardian() {\n        require(governorMap[msg.sender] || msg.sender == guardian, \"1\");\n        _;\n    }\n\n    /// @notice Checks if the new address given is not null\n    /// @param newAddress Address to check\n    modifier zeroCheck(address newAddress) {\n        require(newAddress != address(0), \"0\");\n        _;\n    }\n\n    // =============================== CONSTRUCTOR =================================\n\n    /// @notice Initializes the `Core` contract\n    /// @param _governor Address of the governor\n    /// @param _guardian Address of the guardian\n    constructor(address _governor, address _guardian) {\n        // Creating references\n        require(_guardian != address(0) && _governor != address(0), \"0\");\n        require(_guardian != _governor, \"39\");\n        _governorList.push(_governor);\n        guardian = _guardian;\n        governorMap[_governor] = true;\n\n        emit GovernorRoleGranted(_governor);\n        emit GuardianRoleChanged(address(0), _guardian);\n    }\n\n    // ========================= GOVERNOR FUNCTIONS ================================\n\n    // ======================== Interactions with `StableMasters` ==================\n\n    /// @notice Changes the `Core` contract of the protocol\n    /// @param newCore Address of the new `Core` contract\n    /// @dev To maintain consistency, checks are performed. The governance of the new `Core`\n    /// contract should be exactly the same as this one, and the `_stablecoinList` should be\n    /// identical\n    function setCore(ICore newCore) external onlyGovernor zeroCheck(address(newCore)) {\n        require(address(this) != address(newCore), \"40\");\n        require(guardian == newCore.guardian(), \"41\");\n        // The length of the lists are stored as cache variables to avoid duplicate reads in storage\n        // Checking the consistency of the `_governorList` and of the `_stablecoinList`\n        uint256 governorListLength = _governorList.length;\n        address[] memory _newCoreGovernorList = newCore.governorList();\n        uint256 stablecoinListLength = _stablecoinList.length;\n        address[] memory _newStablecoinList = newCore.stablecoinList();\n        require(\n            governorListLength == _newCoreGovernorList.length && stablecoinListLength == _newStablecoinList.length,\n            \"42\"\n        );\n        uint256 indexMet;\n        for (uint256 i = 0; i < governorListLength; i++) {\n            if (!governorMap[_newCoreGovernorList[i]]) {\n                indexMet = 1;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < stablecoinListLength; i++) {\n            // The stablecoin lists should preserve exactly the same order of elements\n            if (_stablecoinList[i] != _newStablecoinList[i]) {\n                indexMet = 1;\n                break;\n            }\n        }\n        // Only performing one require, hence making it cheaper for a governance with a correct initialization\n        require(indexMet == 0, \"43\");\n        // Propagates the change\n        for (uint256 i = 0; i < stablecoinListLength; i++) {\n            IStableMaster(_stablecoinList[i]).setCore(address(newCore));\n        }\n        emit CoreChanged(address(newCore));\n    }\n\n    /// @notice Adds a new stablecoin to the system\n    /// @param agToken Address of the new `AgToken` contract\n    /// @dev To maintain consistency, the address of the `StableMaster` contract corresponding to the\n    /// `AgToken` is automatically retrieved\n    /// @dev The `StableMaster` receives the reference to the governor and guardian addresses of the protocol\n    /// @dev The `AgToken` and `StableMaster` contracts should have previously been initialized with correct references\n    /// in it, with for the `StableMaster` a reference to the `Core` contract and for the `AgToken` a reference to the\n    /// `StableMaster`\n    function deployStableMaster(address agToken) external onlyGovernor zeroCheck(agToken) {\n        address stableMaster = IAgToken(agToken).stableMaster();\n        // Checking if `stableMaster` has not already been deployed\n        require(!deployedStableMasterMap[stableMaster], \"44\");\n\n        // Storing and initializing information about the stablecoin\n        _stablecoinList.push(stableMaster);\n        // Adding this `stableMaster` in the `deployedStableMasterMap`: it is not going to be possible\n        // to revoke and then redeploy this contract\n        deployedStableMasterMap[stableMaster] = true;\n\n        IStableMaster(stableMaster).deploy(_governorList, guardian, agToken);\n\n        emit StableMasterDeployed(address(stableMaster), agToken);\n    }\n\n    /// @notice Revokes a `StableMaster` contract\n    /// @param stableMaster Address of  the `StableMaster` to revoke\n    /// @dev This function just removes a `StableMaster` contract from the `_stablecoinList`\n    /// @dev The consequence is that the `StableMaster` contract will no longer be affected by changes in\n    /// governor or guardian occuring from the protocol\n    /// @dev This function is mostly here to clean the mappings and save some storage space\n    function revokeStableMaster(address stableMaster) external override onlyGovernor {\n        uint256 stablecoinListLength = _stablecoinList.length;\n        // Checking if `stableMaster` is correct and removing the stablecoin from the `_stablecoinList`\n        require(stablecoinListLength >= 1, \"45\");\n        uint256 indexMet;\n        for (uint256 i = 0; i < stablecoinListLength - 1; i++) {\n            if (_stablecoinList[i] == stableMaster) {\n                indexMet = 1;\n                _stablecoinList[i] = _stablecoinList[stablecoinListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || _stablecoinList[stablecoinListLength - 1] == stableMaster, \"45\");\n        _stablecoinList.pop();\n        // Deleting the stablecoin from the list\n        emit StableMasterRevoked(stableMaster);\n    }\n\n    // =============================== Access Control ==============================\n    // The following functions do not propagate the changes they induce to some bricks of the protocol\n    // like the `CollateralSettler`, the `BondingCurve`, the staking and rewards distribution contracts\n    // and the oracle contracts using Uniswap. Governance should be wary when calling these functions and\n    // make equivalent changes in these contracts to maintain consistency at the scale of the protocol\n\n    /// @notice Adds a new governor address\n    /// @param _governor New governor address\n    /// @dev This function propagates the new governor role across most contracts of the protocol\n    /// @dev Governor is also guardian everywhere in all contracts\n    function addGovernor(address _governor) external override onlyGovernor zeroCheck(_governor) {\n        require(!governorMap[_governor], \"46\");\n        governorMap[_governor] = true;\n        _governorList.push(_governor);\n        // Propagates the changes to maintain consistency across all the contracts that are attached to this\n        // `Core` contract\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            // Since a zero address check has already been performed in this contract, there is no need\n            // to repeat this check in underlying contracts\n            IStableMaster(_stablecoinList[i]).addGovernor(_governor);\n        }\n\n        emit GovernorRoleGranted(_governor);\n    }\n\n    /// @notice Removes a governor address\n    /// @param _governor Governor address to remove\n    /// @dev There must always be one governor in the protocol\n    function removeGovernor(address _governor) external override onlyGovernor {\n        // Checking if removing the governor will leave with at least more than one governor\n        uint256 governorListLength = _governorList.length;\n        require(governorListLength > 1, \"47\");\n        // Removing the governor from the list of governors\n        // We still need to check if the address provided was well in the list\n        uint256 indexMet;\n        for (uint256 i = 0; i < governorListLength - 1; i++) {\n            if (_governorList[i] == _governor) {\n                indexMet = 1;\n                _governorList[i] = _governorList[governorListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || _governorList[governorListLength - 1] == _governor, \"48\");\n        _governorList.pop();\n        // Once it has been checked that the given address was a correct address, we can proceed to other changes\n        delete governorMap[_governor];\n        // Maintaining consistency across all contracts\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            // We have checked in this contract that the mentionned `_governor` here was well a governor\n            // There is no need to check this in the underlying contracts where this is going to be updated\n            IStableMaster(_stablecoinList[i]).removeGovernor(_governor);\n        }\n\n        emit GovernorRoleRevoked(_governor);\n    }\n\n    // ============================== GUARDIAN FUNCTIONS ===========================\n\n    /// @notice Changes the guardian address\n    /// @param _newGuardian New guardian address\n    /// @dev Guardian is able to change by itself the address corresponding to its role\n    /// @dev There can only be one guardian address in the protocol\n    /// @dev The guardian address cannot be a governor address\n    function setGuardian(address _newGuardian) external override onlyGuardian zeroCheck(_newGuardian) {\n        require(!governorMap[_newGuardian], \"39\");\n        require(guardian != _newGuardian, \"49\");\n        address oldGuardian = guardian;\n        guardian = _newGuardian;\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            IStableMaster(_stablecoinList[i]).setGuardian(_newGuardian, oldGuardian);\n        }\n        emit GuardianRoleChanged(oldGuardian, _newGuardian);\n    }\n\n    /// @notice Revokes the guardian address\n    /// @dev Guardian is able to auto-revoke itself\n    /// @dev There can only be one `guardian` address in the protocol\n    function revokeGuardian() external override onlyGuardian {\n        address oldGuardian = guardian;\n        guardian = address(0);\n        for (uint256 i = 0; i < _stablecoinList.length; i++) {\n            IStableMaster(_stablecoinList[i]).revokeGuardian(oldGuardian);\n        }\n        emit GuardianRoleChanged(oldGuardian, address(0));\n    }\n\n    // ========================= VIEW FUNCTIONS ====================================\n\n    /// @notice Returns the list of all the governor addresses of the protocol\n    /// @return `_governorList`\n    /// @dev This getter is used by `StableMaster` contracts deploying new collateral types\n    /// and initializing them with correct references\n    function governorList() external view override returns (address[] memory) {\n        return _governorList;\n    }\n\n    /// @notice Returns the list of all the `StableMaster` addresses of the protocol\n    /// @return `_stablecoinList`\n    /// @dev This getter is used by the `Core` contract when setting a new `Core`\n    function stablecoinList() external view override returns (address[] memory) {\n        return _stablecoinList;\n    }\n}\n"
    },
    "contracts/collateralSettler/CollateralSettlerERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./CollateralSettlerERC20Events.sol\";\n\n/// @title CollateralSettlerERC20\n/// @author Angle Core Team\n/// @notice A contract to settle the positions associated to a collateral for a given stablecoin\n/// @dev In this contract the term LP refers to both SLPs and HAs\n// solhint-disable-next-line max-states-count\ncontract CollateralSettlerERC20 is CollateralSettlerERC20Events, ICollateralSettler, AccessControl, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for `StableMaster`. This role is also given to the governor addresses\n    bytes32 public constant STABLEMASTER_ROLE = keccak256(\"STABLEMASTER_ROLE\");\n    /// @notice Base that is used to compute ratios and floating numbers\n    uint256 public constant BASE_TOKENS = 10**18;\n    /// @notice Base that is used to define parameters that have a floating value\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    // Struct representing a claim that was made by sending governance tokens\n    struct GovTokenClaim {\n        // Number of gov tokens that is owed to users which claimed\n        uint256 govTokens;\n        // Value of the claim: this is the amount that is going to get treated preferably\n        // For a user claim, the `claim` parameter is going to be expressed in stablecoin value\n        // For a HA or LP claim, this parameter is going to be set in collateral value\n        uint256 claim;\n    }\n\n    // =================== References to contracts =================================\n\n    /// @notice Address of the `PerpetualManager` corresponding to the pool being closed\n    IPerpetualManagerFront public immutable perpetualManager;\n\n    /// @notice Address of the `SanToken` corresponding to the pool being closed\n    ISanToken public immutable sanToken;\n\n    /// @notice Address of the `AgToken` contract corresponding to the pool being closed\n    IAgToken public immutable agToken;\n\n    /// @notice Address of the `PoolManager` corresponding to the pool being closed\n    IPoolManager public immutable poolManager;\n\n    /// @notice Address of the corresponding ERC20 token\n    IERC20 public immutable underlyingToken;\n\n    /// @notice Governance token of the protocol\n    /// It is stored here because users, HAs and SLPs can send governance tokens to get treated preferably\n    /// in case of collateral settlement\n    IERC20 public immutable angle;\n\n    /// @notice Address of the Oracle contract corresponding to the pool being closed\n    /// It is used to fetch the price at which stablecoins are going to be converted in collateral at the end\n    /// of the settlement period\n    IOracle public immutable oracle;\n\n    // ========================= Activation Variables ==============================\n\n    /// @notice Base used in the collateral implementation (ERC20 decimal)\n    /// This parameter is set in the `constructor`\n    uint256 public collatBase;\n\n    /// @notice Value of the oracle at settlement trigger time\n    /// It is the one that is used to compute HAs claims\n    /// Note that the oracle value for HAs is going to be slightly different than that for users\n    /// For HAs, it is as if at the time of trigger of collateral settlement, their positions were forced closed\n    /// without needing to pay fees\n    uint256 public oracleValueHA;\n\n    /// @notice Value of the oracle at the end of the claim period. This is the value that is used to settle users\n    /// The reason for using a different value than for HAs is that the real value of the oracle could change\n    /// during the claim time. In case of the revokation of a single collateral, there could be, if we used the same value as HAs,\n    /// arbitrages among users seeing that the value of the oracle at which they are going to be settled differ\n    /// from the current oracle value. Or in case of multiple collaterals being revoked at the same time, users could see\n    /// a bargain in a collateral and all come to redeem one collateral in particular\n    uint256 public oracleValueUsers;\n\n    /// @notice Exchange rate between sanTokens and collateral at settlement trigger time\n    uint256 public sanRate;\n\n    /// @notice Maximum number of stablecoins that can be claimed using this collateral type\n    /// The reason for this parameter is that in case of generalized collateral settlement where all collateral types\n    /// are settled, it prevents users from all claiming the same collateral thus penalizing HAs and SLPs of this\n    /// collateral and advantaging HAs and SLPs of other collateral types.\n    /// This parameter is set equal to the `stocksUsers` for this collateral type at the time of activation\n    uint256 public maxStablecoinsClaimable;\n\n    /// @notice Total amount of collateral to redistribute\n    uint256 public amountToRedistribute;\n\n    /// @notice Time at which settlement was triggered, initialized at zero\n    uint256 public startTimestamp;\n\n    // ======================= Accounting Variables ================================\n\n    /// @notice Number used a boolean to see if the `setAmountToRedistributeEach` function\n    /// has already been called\n    /// @dev This function can only be called once throughout the lifetime of the contract\n    uint256 public baseAmountToEachComputed;\n\n    /// @notice Sum of the claims of users which did not bring governance tokens (expressed in stablecoin value)\n    uint256 public totalUserClaims;\n\n    /// @notice Sum of the claims of users which brought governance tokens (expressed in stablecoin value)\n    uint256 public totalUserClaimsWithGov;\n\n    /// @notice Sum of the claims from LPs (expressed in collateral value)\n    uint256 public totalLpClaims;\n\n    /// @notice Sum of the claims from LPs which had governance tokens (expressed in collateral value)\n    uint256 public totalLpClaimsWithGov;\n\n    /// @notice Ratio between what can be given and the claim for each user with gov tokens\n    /// It is going to be updated (like the quantities below) only once at the end of the claim period\n    uint64 public baseAmountToUserGov;\n\n    /// @notice Ratio between what can be given and the claim for each user\n    uint64 public baseAmountToUser;\n\n    /// @notice Ratio between what can be given and the claim for each LP with gov tokens\n    uint64 public baseAmountToLpGov;\n\n    /// @notice Ratio between what can be given and the claim for each LP\n    uint64 public baseAmountToLp;\n\n    // ============================ Parameters =====================================\n\n    /// @notice Used to compute the portion of the user claim that is going to be considered as a claim\n    /// with governance tokens for a unit amount of governance tokens brought\n    /// Attention, this ratio should be between an amount of governance tokens and an amout of stablecoins\n    uint64 public proportionalRatioGovUser;\n\n    /// @notice Used to compute the portion of the HA or SLP claim that is going to be considered as a claim\n    /// with governance tokens for a unit amount of governance tokens brought\n    uint64 public proportionalRatioGovLP;\n\n    /// @notice Time after the trigger in which users and LPs can come and claim their collateral\n    uint256 public claimTime;\n\n    // ============================= Mappings ======================================\n\n    /// @notice Mapping between an address and a claim (in collateral) for a stable holder\n    mapping(address => uint256) public userClaims;\n\n    /// @notice Mapping between a user address, its claim and number of gov tokens due\n    mapping(address => GovTokenClaim) public userClaimsWithGov;\n\n    /// @notice Mapping between the address of a LP and a claim\n    mapping(address => uint256) public lpClaims;\n\n    /// @notice Mapping between the address of a LP, its claim and the number of gov tokens brouhgt\n    mapping(address => GovTokenClaim) public lpClaimsWithGov;\n\n    /// @notice Mapping to check whether a HA perpetual has already been redeemed\n    mapping(uint256 => uint256) public haClaimCheck;\n\n    // ================================= Modifiers =================================\n\n    /// @notice Checks to see if the contract is currently in claim period\n    modifier onlyClaimPeriod() {\n        require(\n            startTimestamp != 0 && block.timestamp < claimTime + startTimestamp && block.timestamp > startTimestamp,\n            \"57\"\n        );\n        _;\n    }\n\n    /// @notice Checks to see if the base amounts to distribute to each category have already been computed\n    /// @dev This allows to verify if users and LPs can redeem their collateral\n    /// @dev As the `baseAmountToEachComputed` can only be changed from 0 during redeem period, this modifier\n    /// allows at the same time to check if claim period is over\n    modifier onlyBaseAmountsComputed() {\n        require(baseAmountToEachComputed != 0, \"58\");\n        _;\n    }\n\n    // =============================== Constructor =================================\n\n    /// @notice Collateral settler constructor\n    /// @param _poolManager Address of the corresponding `PoolManager`\n    /// @param _angle Address of the ANGLE token\n    /// @param _claimTime Duration in which users and LPs will be able to claim their collateral\n    /// @param governorList List of the governor addresses of the protocol\n    constructor(\n        IPoolManager _poolManager,\n        IERC20 _angle,\n        uint256 _claimTime,\n        address[] memory governorList\n    ) {\n        require(address(_angle) != address(0), \"0\");\n        // Retrieving from the `_poolManager` all the correct references, this guarantees the integrity of the contract\n        poolManager = _poolManager;\n        perpetualManager = IPerpetualManagerFront(_poolManager.perpetualManager());\n        address stableMaster = _poolManager.stableMaster();\n        (, ISanToken _sanToken, , IOracle _oracle, , , uint256 _collatBase, , ) = IStableMaster(stableMaster)\n            .collateralMap(_poolManager);\n        sanToken = _sanToken;\n        collatBase = _collatBase;\n        oracle = _oracle;\n        agToken = IAgToken(IStableMaster(stableMaster).agToken());\n        underlyingToken = IERC20(_poolManager.token());\n        angle = _angle;\n        claimTime = _claimTime;\n\n        // Access control\n        for (uint256 i = 0; i < governorList.length; i++) {\n            require(governorList[i] != address(0), \"0\");\n            _setupRole(GOVERNOR_ROLE, governorList[i]);\n            // Governors also have the `STABLEMASTER_ROLE` to allow them to trigger settlement directly\n            _setupRole(STABLEMASTER_ROLE, governorList[i]);\n        }\n        _setupRole(STABLEMASTER_ROLE, stableMaster);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(STABLEMASTER_ROLE, GOVERNOR_ROLE);\n\n        emit CollateralSettlerInit(address(_poolManager), address(_angle), claimTime);\n    }\n\n    // ========================== Contract Activation ==============================\n\n    /// @notice Activates settlement for this contract, launches claim period and freezes oracle value for HAs\n    /// @param _oracleValue Value of the oracle that will be used for the settlement to get the\n    /// value of HAs positions. A different oracle value is going to be defined later to convert stablecoins to\n    /// collateral for users\n    /// @param _sanRate Value of the `sanRate` at time of settlement to be able to convert an amount of\n    /// sanTokens to an amount of collateral\n    /// @param _stocksUsers Maximum amount of stablecoins that will be redeemable by users for this collateral\n    /// @dev This function is to be called by the `StableMaster` after governance called `revokeCollateral` or by\n    /// governance directly, in which case governance will have to pay attention to pass the right values and to\n    /// pause in the concerned `StableMaster` users, HAs and SLPs. In this situation, governance has more freedom\n    /// regarding the oracle value at which settlement will occur\n    /// @dev This function can only be called once throughout the contract's lifetime\n    /// @dev It is preferable to set the different proportion ratios at collateral deployment or before any\n    /// suspicion that triggerSettlement will be called to avoid front-running\n    function triggerSettlement(\n        uint256 _oracleValue,\n        uint256 _sanRate,\n        uint256 _stocksUsers\n    ) external override onlyRole(STABLEMASTER_ROLE) {\n        require(startTimestamp == 0, \"59\");\n        require(proportionalRatioGovLP != 0 && proportionalRatioGovUser != 0, \"60\");\n        oracleValueHA = _oracleValue;\n        sanRate = _sanRate;\n        maxStablecoinsClaimable = _stocksUsers;\n        startTimestamp = block.timestamp;\n        amountToRedistribute = underlyingToken.balanceOf(address(this));\n        emit SettlementTriggered(amountToRedistribute);\n    }\n\n    // =============================== User Claims =================================\n\n    /// @notice Allows a user to claim collateral for a `dest` address by sending agTokens and gov tokens (optional)\n    /// @param dest Address of the user to claim collateral for\n    /// @param amountAgToken Amount of agTokens sent\n    /// @param amountGovToken Amount of governance sent\n    /// @dev The more gov tokens a user sent, the more preferably it ends up being treated during the redeem period\n    function claimUser(\n        address dest,\n        uint256 amountAgToken,\n        uint256 amountGovToken\n    ) external onlyClaimPeriod whenNotPaused {\n        require(dest != address(0), \"0\");\n        require(totalUserClaimsWithGov + totalUserClaims + amountAgToken <= maxStablecoinsClaimable, \"61\");\n        // Since this involves a `transferFrom`, it is normal to update the variables after the transfers are done\n        // No need to use `safeTransfer` for agTokens and ANGLE tokens\n        agToken.transferFrom(msg.sender, address(this), amountAgToken);\n        if (amountGovToken > 0) {\n            angle.transferFrom(msg.sender, address(this), amountGovToken);\n            // From the `amountGovToken`, computing the portion of the initial claim that is going to be\n            // treated as a preferable claim\n            uint256 amountAgTokenGov = (amountGovToken * BASE_PARAMS) / proportionalRatioGovUser;\n            amountAgTokenGov = amountAgTokenGov > amountAgToken ? amountAgToken : amountAgTokenGov;\n            amountAgToken -= amountAgTokenGov;\n            totalUserClaimsWithGov += amountAgTokenGov;\n            userClaimsWithGov[dest].govTokens += amountGovToken;\n            userClaimsWithGov[dest].claim += amountAgTokenGov;\n            emit UserClaimGovUpdated(totalUserClaimsWithGov);\n        }\n        // The claims for users are stored in stablecoin value: conversion will be done later on at the end on\n        // the claim period\n        totalUserClaims += amountAgToken;\n        userClaims[dest] += amountAgToken;\n        emit UserClaimUpdated(totalUserClaims);\n    }\n\n    // =============================== HA Claims ===================================\n\n    /// @notice Allows a HA to claim collateral by sending a `perpetualID` and gov tokens (optional)\n    /// @param perpetualID Perpetual owned by the HA\n    /// @param amountGovToken Amount of governance sent\n    /// @dev The contract automatically recognizes the beneficiary of the perpetual\n    /// @dev If the perpetual of the HA should be liquidated then, this HA will not be able to get\n    /// a claim on the remaining collateral\n    function claimHA(uint256 perpetualID, uint256 amountGovToken) external onlyClaimPeriod whenNotPaused {\n        require(perpetualManager.isApprovedOrOwner(msg.sender, perpetualID), \"21\");\n        // Getting the owner of the perpetual\n        // The zero address cannot own a perpetual\n        address dest = perpetualManager.ownerOf(perpetualID);\n        require(haClaimCheck[perpetualID] == 0, \"64\");\n        // A HA cannot claim a given perpetual twice\n        haClaimCheck[perpetualID] = 1;\n        // Computing the amount of the claim from the perpetual\n        (uint256 amountInC, uint256 reachMaintenanceMargin) = perpetualManager.getCashOutAmount(\n            perpetualID,\n            oracleValueHA\n        );\n        // If the perpetual is below the maintenance margin, then the claim of the HA is null\n        if (reachMaintenanceMargin != 1 && amountInC > 0) {\n            // Updating the contract's mappings accordingly\n            _treatLPClaim(dest, amountGovToken, amountInC);\n        }\n    }\n\n    // =============================== SLP Claims ==================================\n\n    /// @notice Allows a SLP to claim collateral for an address `dest` by sending sanTokens and gov tokens (optional)\n    /// @param dest Address to claim collateral for\n    /// @param amountSanToken Amount of sanTokens sent\n    /// @param amountGovToken Amount of governance tokens sent\n    function claimSLP(\n        address dest,\n        uint256 amountSanToken,\n        uint256 amountGovToken\n    ) external onlyClaimPeriod whenNotPaused {\n        require(dest != address(0), \"0\");\n        sanToken.transferFrom(msg.sender, address(this), amountSanToken);\n        // Computing the amount of the claim from the number of sanTokens sent\n        uint256 amountInC = (amountSanToken * sanRate) / BASE_TOKENS;\n        // Updating the contract's mappings accordingly\n        _treatLPClaim(dest, amountGovToken, amountInC);\n    }\n\n    // ========================= Redeem Period =====================================\n\n    /// @notice Computes the base amount each category of claim will get after the claim period has ended\n    /// @dev This function can only be called once when claim period is over\n    /// @dev It is at the level of this function that the waterfall between the different\n    /// categories of stakeholders and of claims is executed\n    function setAmountToRedistributeEach() external whenNotPaused {\n        // Checking if it is the right time to call the function: claim period should be over\n        require(startTimestamp != 0 && block.timestamp > claimTime + startTimestamp, \"63\");\n        // This is what guarantees that this function can only be computed once\n        require(baseAmountToEachComputed == 0, \"62\");\n        baseAmountToEachComputed = 1;\n        // Fetching the oracle value at which stablecoins will be converted to collateral\n        oracleValueUsers = oracle.readLower();\n        // The waterfall first gives everything that's possible to stable holders which had governance tokens\n        // in the limit of what is owed to them\n        // We need to convert the user claims expressed in stablecoin value to claims in collateral value\n        uint256 totalUserClaimsWithGovInC = (totalUserClaimsWithGov * collatBase) / oracleValueUsers;\n        uint256 totalUserClaimsInC = (totalUserClaims * collatBase) / oracleValueUsers;\n        if (amountToRedistribute >= totalUserClaimsWithGovInC) {\n            baseAmountToUserGov = uint64(BASE_PARAMS);\n            amountToRedistribute -= totalUserClaimsWithGovInC;\n        } else {\n            baseAmountToUserGov = uint64((amountToRedistribute * BASE_PARAMS) / totalUserClaimsWithGovInC);\n            amountToRedistribute = 0;\n        }\n        // Then it gives everything that remains to other stable holders (in the limit of what is owed to them)\n        if (amountToRedistribute > totalUserClaimsInC) {\n            baseAmountToUser = uint64(BASE_PARAMS);\n            amountToRedistribute -= totalUserClaimsInC;\n        } else {\n            baseAmountToUser = uint64((amountToRedistribute * BASE_PARAMS) / totalUserClaimsInC);\n            amountToRedistribute = 0;\n        }\n        // After that, LPs which had governance tokens claims are going to be treated: once again the contract\n        // gives them everything it can in the limit of their claim\n        if (amountToRedistribute > totalLpClaimsWithGov) {\n            baseAmountToLpGov = uint64(BASE_PARAMS);\n            amountToRedistribute -= totalLpClaimsWithGov;\n        } else {\n            baseAmountToLpGov = uint64((amountToRedistribute * BASE_PARAMS) / totalLpClaimsWithGov);\n            amountToRedistribute = 0;\n        }\n        // And last, LPs claims without governance tokens are handled\n        if (amountToRedistribute > totalLpClaims) {\n            baseAmountToLp = uint64(BASE_PARAMS);\n            amountToRedistribute -= totalLpClaims;\n        } else {\n            baseAmountToLp = uint64((amountToRedistribute * BASE_PARAMS) / totalLpClaims);\n            amountToRedistribute = 0;\n        }\n\n        emit AmountToRedistributeAnnouncement(\n            baseAmountToUserGov,\n            baseAmountToUser,\n            baseAmountToLpGov,\n            baseAmountToLp,\n            amountToRedistribute\n        );\n    }\n\n    /// @notice Lets a user or a LP redeem its corresponding share of collateral\n    /// @param user Address of the user to redeem collateral to\n    /// @dev This function can only be called after the `setAmountToRedistributeEach` function has been called\n    /// @dev The entry point to redeem is the same for users, HAs and SLPs\n    function redeemCollateral(address user) external onlyBaseAmountsComputed whenNotPaused {\n        // Converting the claims stored for each user in collateral value\n        uint256 amountToGive = ((userClaimsWithGov[user].claim * collatBase * baseAmountToUserGov) /\n            oracleValueUsers +\n            (userClaims[user] * collatBase * baseAmountToUser) /\n            oracleValueUsers +\n            lpClaimsWithGov[user].claim *\n            baseAmountToLpGov +\n            lpClaims[user] *\n            baseAmountToLp) / BASE_PARAMS;\n        uint256 amountGovTokens = lpClaimsWithGov[user].govTokens + userClaimsWithGov[user].govTokens;\n        // Deleting the amounts stored for each so that someone cannot come and claim twice\n        delete userClaimsWithGov[user];\n        delete userClaims[user];\n        delete lpClaimsWithGov[user];\n        delete lpClaims[user];\n        if (amountToGive > 0) {\n            underlyingToken.safeTransfer(user, amountToGive);\n        }\n        if (amountGovTokens > 0) {\n            angle.transfer(user, amountGovTokens);\n        }\n    }\n\n    // ============================== Governance ===================================\n\n    /// @notice Changes the amount that can be redistributed with this contract\n    /// @param newAmountToRedistribute New amount that can be given by this contract\n    /// @dev This function should typically be called after the settlement trigger and after this contract\n    /// receives more collateral\n    function setAmountToRedistribute(uint256 newAmountToRedistribute) external onlyRole(GOVERNOR_ROLE) onlyClaimPeriod {\n        require(underlyingToken.balanceOf(address(this)) >= newAmountToRedistribute, \"66\");\n        amountToRedistribute = newAmountToRedistribute;\n\n        emit AmountRedistributeUpdated(amountToRedistribute);\n    }\n\n    /// @notice Recovers leftover tokens from the contract or tokens that were mistakenly sent to the contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address to send the remaining tokens to\n    /// @param amountToRecover Amount to recover from the contract\n    /// @dev It can be used after the `setAmountToDistributeEach` function has been called to allocate\n    /// the surplus of the contract elsewhere\n    /// @dev It can also be used to recover tokens that are mistakenly sent to this contract\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyRole(GOVERNOR_ROLE) onlyBaseAmountsComputed {\n        if (tokenAddress == address(underlyingToken)) {\n            require(amountToRedistribute >= amountToRecover, \"66\");\n            amountToRedistribute -= amountToRecover;\n            underlyingToken.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Changes the governance tokens proportionality ratio used to compute the claims\n    /// with governance tokens\n    /// @param _proportionalRatioGovUser New ratio for users\n    /// @param _proportionalRatioGovLP New ratio for LPs (both SLPs and HAs)\n    /// @dev This function can only be called before the claim period and settlement trigger: there could be\n    /// a governance attack if these ratios can be modified during the claim period\n    function setProportionalRatioGov(uint64 _proportionalRatioGovUser, uint64 _proportionalRatioGovLP)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        require(startTimestamp == 0, \"65\");\n        proportionalRatioGovUser = _proportionalRatioGovUser;\n        proportionalRatioGovLP = _proportionalRatioGovLP;\n        emit ProportionalRatioGovUpdated(proportionalRatioGovUser, proportionalRatioGovLP);\n    }\n\n    /// @notice Pauses pausable methods, that is all the claim and redeem methods\n    function pause() external onlyRole(GOVERNOR_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses paused methods\n    function unpause() external onlyRole(GOVERNOR_ROLE) {\n        _unpause();\n    }\n\n    // ============================= Internal Function =============================\n\n    /// @notice Handles a claim after having computed the amount in collateral (`amountInC`) from the claim\n    /// for a SLP or a HA\n    /// @param dest Address the claim will be for\n    /// @param amountGovToken Amount of governance tokens sent\n    /// @param amountInC Amount in collateral for the claim\n    /// @dev This function is called after the amount from a claim has been computed\n    /// @dev It is at the level of this function that it is seen from the proportional ratios whether a LP claim is\n    /// a preferable claim (involving governance tokens sent) or not\n    function _treatLPClaim(\n        address dest,\n        uint256 amountGovToken,\n        uint256 amountInC\n    ) internal {\n        if (amountGovToken > 0) {\n            angle.transferFrom(msg.sender, address(this), amountGovToken);\n            uint256 amountInCGov = (amountGovToken * BASE_PARAMS) / proportionalRatioGovLP;\n            amountInCGov = amountInCGov > amountInC ? amountInC : amountInCGov;\n            amountInC -= amountInCGov;\n            totalLpClaimsWithGov += amountInCGov;\n            lpClaimsWithGov[dest].govTokens += amountGovToken;\n            lpClaimsWithGov[dest].claim += amountInCGov;\n            emit LPClaimGovUpdated(totalLpClaimsWithGov);\n        }\n        totalLpClaims += amountInC;\n        lpClaims[dest] += amountInC;\n        emit LPClaimUpdated(totalLpClaims);\n    }\n}\n"
    },
    "contracts/feeManager/FeeManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./FeeManagerEvents.sol\";\n\n/// @title FeeManagerStorage\n/// @author Angle Core Team\n/// @dev `FeeManagerStorage` contains all the parameters (most often fee parameters) to add corrections\n/// to fees in the `StableMaster` and `PerpetualManager` contracts\ncontract FeeManagerStorage is FeeManagerEvents {\n    uint64 public constant BASE_PARAMS_CASTED = 10**9;\n    // ==================== References to other contracts ==========================\n\n    /// @notice Address of the `StableMaster` contract corresponding to this contract\n    /// This reference cannot be modified\n    IStableMaster public stableMaster;\n\n    /// @notice Address of the `PerpetualManager` corresponding to this contract\n    /// This reference cannot be modified\n    IPerpetualManager public perpetualManager;\n\n    // ================= Parameters that can be set by governance ==================\n\n    /// @notice Bonus - Malus Fee, means that if the `fee > BASE_PARAMS` then agents incur a malus and will\n    /// have larger fees, while `fee < BASE_PARAMS` they incur a smaller fee than what they would have if fees\n    /// just consisted in what was obtained using the hedge ratio\n    /// @notice Values of the collateral ratio where mint transaction fees will change for users\n    /// It should be ranked in ascending order\n    uint256[] public xBonusMalusMint;\n    /// @notice Values of the bonus/malus on the mint fees at the points of collateral ratio in the array above\n    /// The evolution of the fees when collateral ratio is between two threshold values is linear\n    uint64[] public yBonusMalusMint;\n    /// @notice Values of the collateral ratio where burn transaction fees will change\n    uint256[] public xBonusMalusBurn;\n    /// @notice Values of the bonus/malus on the burn fees at the points of collateral ratio in the array above\n    uint64[] public yBonusMalusBurn;\n\n    /// @notice Values of the collateral ratio where the slippage factor for SLPs exiting will evolve\n    uint256[] public xSlippage;\n    /// @notice Slippage factor at the values of collateral ratio above\n    uint64[] public ySlippage;\n    /// @notice Values of the collateral ratio where the slippage fee, that is the portion of the fees\n    /// that does not come to SLPs although changes\n    uint256[] public xSlippageFee;\n    /// @notice Slippage fee value at the values of collateral ratio above\n    uint64[] public ySlippageFee;\n\n    /// @notice Bonus - Malus HA deposit Fee, means that if the `fee > BASE_PARAMS` then HAs incur a malus and\n    /// will have larger fees, while `fee < BASE_PARAMS` they incur a smaller fee than what they would have if\n    /// fees just consisted in what was obtained using hedge ratio\n    uint64 public haFeeDeposit;\n    /// @notice Bonus - Malus HA withdraw Fee\n    uint64 public haFeeWithdraw;\n}\n"
    },
    "contracts/feeManager/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./FeeManagerStorage.sol\";\n\n/// @title FeeManager\n/// @author Angle Core Team\n/// @dev This contract interacts with fee parameters for a given stablecoin/collateral pair\n/// @dev `FeeManager` contains all the functions that keepers can call to update parameters\n/// in the `StableMaster` and `PerpetualManager` contracts\n/// @dev These parameters need to be updated by keepers because they depend on variables, like\n/// the collateral ratio, that are too expensive to compute each time transactions that would need\n/// it occur\ncontract FeeManager is FeeManagerStorage, IFeeManagerFunctions, AccessControl, Initializable {\n    /// @notice Role for `PoolManager` only\n    bytes32 public constant POOLMANAGER_ROLE = keccak256(\"POOLMANAGER_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Deploys the `FeeManager` contract for a pair stablecoin/collateral\n    /// @param _poolManager `PoolManager` contract handling the collateral\n    /// @dev The `_poolManager` address is used to grant the correct role. It does not need to be stored by the\n    /// contract\n    /// @dev There is no need to do a zero address check on the `_poolManager` as if the zero address is passed\n    /// the function will revert when trying to fetch the `StableMaster`\n    constructor(IPoolManager _poolManager) {\n        stableMaster = IStableMaster(_poolManager.stableMaster());\n        // Once a `FeeManager` contract has been initialized with a `PoolManager` contract, this\n        // reference cannot be modified\n        _setupRole(POOLMANAGER_ROLE, address(_poolManager));\n\n        _setRoleAdmin(POOLMANAGER_ROLE, POOLMANAGER_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, POOLMANAGER_ROLE);\n    }\n\n    /// @notice Initializes the governor and guardian roles of the contract as well as the reference to\n    /// the `perpetualManager` contract\n    /// @param governorList List of the governor addresses of the protocol\n    /// @param guardian Guardian address of the protocol\n    /// @param _perpetualManager `PerpetualManager` contract handling the perpetuals of the pool\n    /// @dev `GUARDIAN_ROLE` can then directly be granted or revoked by the corresponding `PoolManager`\n    /// As `POOLMANAGER_ROLE` is admin of `GUARDIAN_ROLE`, it corresponds to the intended behaviour of roles\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        address _perpetualManager\n    ) external override onlyRole(POOLMANAGER_ROLE) initializer {\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _grantRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _grantRole(GUARDIAN_ROLE, guardian);\n        perpetualManager = IPerpetualManager(_perpetualManager);\n    }\n\n    // ============================ `StableMaster` =================================\n\n    /// @notice Updates the SLP and Users fees associated to the pair stablecoin/collateral in\n    /// the `StableMaster` contract\n    /// @dev This function updates:\n    /// \t-\t`bonusMalusMint`: part of the fee induced by a user minting depending on the collateral ratio\n    ///                   In normal times, no fees are taken for that, and so this fee should be equal to `BASE_PARAMS`\n    ///\t\t-\t`bonusMalusBurn`: part of the fee induced by a user burning depending on the collateral ratio\n    ///\t\t-\tSlippage: what's given to SLPs compared with their claim when they exit\n    ///\t\t-\tSlippageFee: that is the portion of fees that is put aside because the protocol\n    ///         is not well collateralized\n    /// @dev `bonusMalusMint` and `bonusMalusBurn` allow governance to add penalties or bonuses for users minting\n    /// and burning in some situations of collateral ratio. These parameters are multiplied to the fee amount depending\n    /// on the hedge ratio by Hedging Agents to get the exact fee induced to the users\n    function updateUsersSLP() external override {\n        // Computing the collateral ratio, expressed in `BASE_PARAMS`\n        uint256 collatRatio = stableMaster.getCollateralRatio();\n        // Computing the fees based on this collateral ratio\n        uint64 bonusMalusMint = _piecewiseLinearCollatRatio(collatRatio, xBonusMalusMint, yBonusMalusMint);\n        uint64 bonusMalusBurn = _piecewiseLinearCollatRatio(collatRatio, xBonusMalusBurn, yBonusMalusBurn);\n        uint64 slippage = _piecewiseLinearCollatRatio(collatRatio, xSlippage, ySlippage);\n        uint64 slippageFee = _piecewiseLinearCollatRatio(collatRatio, xSlippageFee, ySlippageFee);\n\n        emit UserAndSLPFeesUpdated(collatRatio, bonusMalusMint, bonusMalusBurn, slippage, slippageFee);\n        stableMaster.setFeeKeeper(bonusMalusMint, bonusMalusBurn, slippage, slippageFee);\n    }\n\n    // ============================= PerpetualManager ==============================\n\n    /// @notice Updates HA fees associated to the pair stablecoin/collateral in the `PerpetualManager` contract\n    /// @dev This function updates:\n    ///     - The part of the fee taken from HAs when they open a perpetual or add collateral in it. This allows\n    ///        governance to add penalties or bonuses in some occasions to HAs opening their perpetuals\n    ///     - The part of the fee taken from the HA when they withdraw collateral from a perpetual. This allows\n    ///       governance to add penalty or bonuses in some occasions to HAs closing their perpetuals\n    /// @dev Penalties or bonuses for HAs should almost never be used\n    /// @dev In the `PerpetualManager` contract, these parameters are multiplied to the fee amount depending on the HA\n    /// hedge ratio to get the exact fee amount for HAs\n    /// @dev For the moment, these parameters do not depend on the collateral ratio, and they are just an extra\n    /// element that governance can play on to correct fees taken for HAs\n    function updateHA() external override {\n        emit HaFeesUpdated(haFeeDeposit, haFeeWithdraw);\n        perpetualManager.setFeeKeeper(haFeeDeposit, haFeeWithdraw);\n    }\n\n    // ============================= Governance ====================================\n\n    /// @notice Sets the x (i.e. thresholds of collateral ratio) array / y (i.e. value of fees at threshold)-array\n    /// for users minting, burning, for SLPs withdrawal slippage or for the slippage fee when updating\n    /// the exchange rate between sanTokens and collateral\n    /// @param xArray New collateral ratio thresholds (in ascending order)\n    /// @param yArray New fees or values for the parameters at thresholds\n    /// @param typeChange Type of parameter to change\n    /// @dev For `typeChange = 1`, `bonusMalusMint` fees are updated\n    /// @dev For `typeChange = 2`, `bonusMalusBurn` fees are updated\n    /// @dev For `typeChange = 3`, `slippage` values are updated\n    /// @dev For other values of `typeChange`, `slippageFee` values are updated\n    function setFees(\n        uint256[] memory xArray,\n        uint64[] memory yArray,\n        uint8 typeChange\n    ) external override onlyRole(GUARDIAN_ROLE) {\n        require(xArray.length == yArray.length && yArray.length > 0, \"5\");\n        for (uint256 i = 0; i <= yArray.length - 1; i++) {\n            if (i > 0) {\n                require(xArray[i] > xArray[i - 1], \"7\");\n            }\n        }\n        if (typeChange == 1) {\n            xBonusMalusMint = xArray;\n            yBonusMalusMint = yArray;\n            emit FeeMintUpdated(xBonusMalusMint, yBonusMalusMint);\n        } else if (typeChange == 2) {\n            xBonusMalusBurn = xArray;\n            yBonusMalusBurn = yArray;\n            emit FeeBurnUpdated(xBonusMalusBurn, yBonusMalusBurn);\n        } else if (typeChange == 3) {\n            xSlippage = xArray;\n            ySlippage = yArray;\n            _checkSlippageCompatibility();\n            emit SlippageUpdated(xSlippage, ySlippage);\n        } else {\n            xSlippageFee = xArray;\n            ySlippageFee = yArray;\n            _checkSlippageCompatibility();\n            emit SlippageFeeUpdated(xSlippageFee, ySlippageFee);\n        }\n    }\n\n    /// @notice Sets the extra fees that can be used when HAs deposit or withdraw collateral from the\n    /// protocol\n    /// @param _haFeeDeposit New parameter to modify deposit fee for HAs\n    /// @param _haFeeWithdraw New parameter to modify withdraw fee for HAs\n    function setHAFees(uint64 _haFeeDeposit, uint64 _haFeeWithdraw) external override onlyRole(GUARDIAN_ROLE) {\n        haFeeDeposit = _haFeeDeposit;\n        haFeeWithdraw = _haFeeWithdraw;\n    }\n\n    /// @notice Helps to make sure that the `slippageFee` and the `slippage` will in most situations be compatible\n    /// with one another\n    /// @dev Whenever the `slippageFee` is not null, the `slippage` should be non null, as otherwise, there would be\n    /// an opportunity cost to increase the collateral ratio to make the `slippage` non null and collect the fees\n    /// that have been left aside\n    /// @dev This function does not perform an exhaustive check around the fact that whenever the `slippageFee`\n    /// is not null the `slippage` is not null neither. It simply checks that each positive value in the `ySlippageFee` array\n    /// corresponds to a positive value of the `slippage`\n    /// @dev The protocol still relies on governance to make sure that this condition is always verified, this function\n    /// is just here to eliminate potentially extreme errors\n    function _checkSlippageCompatibility() internal view {\n        // We need this `if` condition because when this function is first called after contract deployment, the length\n        // of the two arrays is zero\n        if (xSlippage.length >= 1 && xSlippageFee.length >= 1) {\n            for (uint256 i = 0; i <= ySlippageFee.length - 1; i++) {\n                if (ySlippageFee[i] > 0) {\n                    require(ySlippageFee[i] <= BASE_PARAMS_CASTED, \"37\");\n                    require(_piecewiseLinearCollatRatio(xSlippageFee[i], xSlippage, ySlippage) > 0, \"38\");\n                }\n            }\n        }\n    }\n\n    /// @notice Computes the value of a linear by part function at a given point\n    /// @param x Point of the function we want to compute\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev The evolution of the linear by part function between two breaking points is linear\n    /// @dev Before the first breaking point and after the last one, the function is constant with a value\n    /// equal to the first or last value of the `yArray`\n    /// @dev The reason for having a function that is different from what's in the `FunctionUtils` contract is that\n    /// here the values in `xArray` can be greater than `BASE_PARAMS` meaning that there is a non negligeable risk that\n    /// the product between `yArray` and `xArray` values overflows\n    function _piecewiseLinearCollatRatio(\n        uint256 x,\n        uint256[] storage xArray,\n        uint64[] storage yArray\n    ) internal view returns (uint64 y) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            uint256 yCasted;\n            if (yArray[upper] > yArray[lower]) {\n                yCasted =\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                yCasted =\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n            // There is no problem with this cast as `y` was initially a `uint64` and we divided a `uint256` with a `uint256`\n            // that is greater\n            y = uint64(yCasted);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockGaugeController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IGaugeController.sol\";\n\n/// @notice MockGaugeController contract\ncontract MockGaugeController is IGaugeController {\n    address public unAllowedGauge = address(0);\n    mapping(address => uint256) public weights;\n    mapping(address => int128) public gauges;\n    uint256 public constant BASE = 10**18;\n    uint256 public baseWeight = BASE / 2;\n\n    constructor() {}\n\n    // solhint-disable-next-line\n    function gauge_types(address addr) external view override returns (int128) {\n        if (addr == unAllowedGauge) {\n            return -1;\n        }\n        return gauges[addr];\n    }\n\n    // solhint-disable-next-line\n    function gauge_relative_weight(address addr, uint256) external view override returns (uint256) {\n        return weights[addr];\n    }\n\n    // solhint-disable-next-line\n    function gauge_relative_weight_write(address addr, uint256) external override returns (uint256) {\n        weights[addr] = baseWeight;\n        return weights[addr];\n    }\n\n    function setBaseWeight(uint256 _baseWeight) external {\n        baseWeight = _baseWeight;\n    }\n\n    function setGauge(address gauge, int128 _type) external {\n        gauges[gauge] = _type;\n    }\n}\n"
    },
    "contracts/staking/AngleDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.7;\n\nimport \"./AngleDistributorEvents.sol\";\n\n/// @title AngleDistributor\n/// @author Forked from contracts developed by Curve and Frax and adapted by Angle Core Team\n/// - ERC20CRV.vy (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/ERC20CRV.vy)\n/// - FraxGaugeFXSRewardsDistributor.sol (https://github.com/FraxFinance/frax-solidity/blob/master/src/hardhat/contracts/Curve/FraxGaugeFXSRewardsDistributor.sol)\n/// @notice All the events used in `AngleDistributor` contract\ncontract AngleDistributor is AngleDistributorEvents, ReentrancyGuardUpgradeable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for the guardian\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Length of a week in seconds\n    uint256 public constant WEEK = 3600 * 24 * 7;\n\n    /// @notice Time at which the emission rate is updated\n    uint256 public constant RATE_REDUCTION_TIME = WEEK;\n\n    /// @notice Reduction of the emission rate\n    uint256 public constant RATE_REDUCTION_COEFFICIENT = 1007827884862117171; // 1.5 ^ (1/52) * 10**18\n\n    /// @notice Base used for computation\n    uint256 public constant BASE = 10**18;\n\n    /// @notice Maps the address of a gauge to the last time this gauge received rewards\n    mapping(address => uint256) public lastTimeGaugePaid;\n\n    /// @notice Maps the address of a gauge to whether it was killed or not\n    /// A gauge killed in this contract cannot receive any rewards\n    mapping(address => bool) public killedGauges;\n\n    /// @notice Maps the address of a type >= 2 gauge to a delegate address responsible\n    /// for giving rewards to the actual gauge\n    mapping(address => address) public delegateGauges;\n\n    /// @notice Maps the address of a gauge delegate to whether this delegate supports the `notifyReward` interface\n    /// and is therefore built for automation\n    mapping(address => bool) public isInterfaceKnown;\n\n    /// @notice Address of the ANGLE token given as a reward\n    IERC20 public rewardToken;\n\n    /// @notice Address of the `GaugeController` contract\n    IGaugeController public controller;\n\n    /// @notice Address responsible for pulling rewards of type >= 2 gauges and distributing it to the\n    /// associated contracts if there is not already an address delegated for this specific contract\n    address public delegateGauge;\n\n    /// @notice ANGLE current emission rate, it is first defined in the initializer and then updated every week\n    uint256 public rate;\n\n    /// @notice Timestamp at which the current emission epoch started\n    uint256 public startEpochTime;\n\n    /// @notice Amount of ANGLE tokens distributed through staking at the start of the epoch\n    /// This is an informational variable used to track how much has been distributed through liquidity mining\n    uint256 public startEpochSupply;\n\n    /// @notice Index of the current emission epoch\n    /// Here also, this variable is not useful per se inside the smart contracts of the protocol, it is\n    /// just an informational variable\n    uint256 public miningEpoch;\n\n    /// @notice Whether ANGLE distribution through this contract is on or no\n    bool public distributionsOn;\n\n    /// @notice Constructor of the contract\n    /// @param _rewardToken Address of the ANGLE token\n    /// @param _controller Address of the GaugeController\n    /// @param _initialRate Initial ANGLE emission rate\n    /// @param _startEpochSupply Amount of ANGLE tokens already distributed via liquidity mining\n    /// @param governor Governor address of the contract\n    /// @param guardian Address of the guardian of this contract\n    /// @param _delegateGauge Address that will be used to pull rewards for type 2 gauges\n    /// @dev After this contract is created, the correct amount of ANGLE tokens should be transferred to the contract\n    /// @dev The `_delegateGauge` can be the zero address\n    function initialize(\n        address _rewardToken,\n        address _controller,\n        uint256 _initialRate,\n        uint256 _startEpochSupply,\n        address governor,\n        address guardian,\n        address _delegateGauge\n    ) external initializer {\n        require(\n            _controller != address(0) && _rewardToken != address(0) && guardian != address(0) && governor != address(0),\n            \"0\"\n        );\n        rewardToken = IERC20(_rewardToken);\n        controller = IGaugeController(_controller);\n        startEpochSupply = _startEpochSupply;\n        miningEpoch = 0;\n        // Some ANGLE tokens should be sent to the contract directly after initialization\n        rate = _initialRate;\n        delegateGauge = _delegateGauge;\n        distributionsOn = false;\n        startEpochTime = block.timestamp;\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setupRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======================== Internal Functions =================================\n\n    /// @notice Internal function to distribute rewards to a gauge\n    /// @param gaugeAddr Address of the gauge to distribute rewards to\n    /// @return weeksElapsed Weeks elapsed since the last call\n    /// @return rewardTally Amount of rewards distributed to the gauge\n    /// @dev The reason for having an internal function is that it's called by the `distributeReward` and the\n    /// `distributeRewardToMultipleGauges`\n    /// @dev Although they would need to be performed all the time this function is called, this function does not\n    /// contain checks on whether distribution is on, and on whether rate should be reduced. These are done in each external\n    /// function calling this function for gas efficiency\n    function _distributeReward(address gaugeAddr) internal returns (uint256 weeksElapsed, uint256 rewardTally) {\n        // Checking if the gauge has been added or if it still possible to distribute rewards to this gauge\n        int128 gaugeType = IGaugeController(controller).gauge_types(gaugeAddr);\n        require(gaugeType >= 0 && !killedGauges[gaugeAddr], \"110\");\n\n        // Calculate the elapsed time in weeks.\n        uint256 lastTimePaid = lastTimeGaugePaid[gaugeAddr];\n\n        // Edge case for first reward for this gauge\n        if (lastTimePaid == 0) {\n            weeksElapsed = 1;\n            if (gaugeType == 0) {\n                // We give a full approval for the gauges with type zero which correspond to the staking\n                // contracts of the protocol\n                rewardToken.safeApprove(gaugeAddr, type(uint256).max);\n            }\n        } else {\n            // Truncation desired\n            weeksElapsed = (block.timestamp - lastTimePaid) / WEEK;\n            // Return early here for 0 weeks instead of throwing, as it could have bad effects in other contracts\n            if (weeksElapsed == 0) {\n                return (0, 0);\n            }\n        }\n        rewardTally = 0;\n        // We use this variable to keep track of the emission rate across different weeks\n        uint256 weeklyRate = rate;\n        for (uint256 i = 0; i < weeksElapsed; i++) {\n            uint256 relWeightAtWeek;\n            if (i == 0) {\n                // Mutative, for the current week: makes sure the weight is checkpointed. Also returns the weight.\n                relWeightAtWeek = controller.gauge_relative_weight_write(gaugeAddr, block.timestamp);\n            } else {\n                // View\n                relWeightAtWeek = controller.gauge_relative_weight(gaugeAddr, (block.timestamp - WEEK * i));\n            }\n            rewardTally += (weeklyRate * relWeightAtWeek * WEEK) / BASE;\n\n            // To get the rate of the week prior from the current rate we just have to multiply by the weekly division\n            // factor\n            // There may be some precisions error: inferred previous values of the rate may be different to what we would\n            // have had if the rate had been computed correctly in these weeks: we expect from empirical observations\n            // this `weeklyRate` to be inferior to what the `rate` would have been\n            weeklyRate = (weeklyRate * RATE_REDUCTION_COEFFICIENT) / BASE;\n        }\n\n        // Update the last time paid, rounded to the closest week\n        // in order not to have an ever moving time on when to call this function\n        lastTimeGaugePaid[gaugeAddr] = (block.timestamp / WEEK) * WEEK;\n\n        // If the `gaugeType >= 2`, this means that the gauge is a gauge on another chain (and corresponds to tokens\n        // that need to be bridged) or is associated to an external contract of the Angle Protocol\n        if (gaugeType >= 2) {\n            // If it is defined, we use the specific delegate attached to the gauge\n            address delegate = delegateGauges[gaugeAddr];\n            if (delegate == address(0)) {\n                // If not, we check if a delegate common to all gauges with type >= 2 can be used\n                delegate = delegateGauge;\n            }\n            if (delegate != address(0)) {\n                // In the case where the gauge has a delegate (specific or not), then rewards are transferred to this gauge\n                rewardToken.safeTransfer(delegate, rewardTally);\n                // If this delegate supports a specific interface, then rewards sent are notified through this\n                // interface\n                if (isInterfaceKnown[delegate]) {\n                    IAngleMiddlemanGauge(delegate).notifyReward(gaugeAddr, rewardTally);\n                }\n            } else {\n                rewardToken.safeTransfer(gaugeAddr, rewardTally);\n            }\n        } else if (gaugeType == 1) {\n            // This is for the case of Perpetual contracts which need to be able to receive their reward tokens\n            rewardToken.safeTransfer(gaugeAddr, rewardTally);\n            IStakingRewards(gaugeAddr).notifyRewardAmount(rewardTally);\n        } else {\n            // Mainnet: Pay out the rewards directly to the gauge\n            ILiquidityGauge(gaugeAddr).deposit_reward_token(address(rewardToken), rewardTally);\n        }\n        emit RewardDistributed(gaugeAddr, rewardTally);\n    }\n\n    /// @notice Updates mining rate and supply at the start of the epoch\n    /// @dev Any modifying mining call must also call this\n    /// @dev It is possible that more than one week past between two calls of this function, and for this reason\n    /// this function has been slightly modified from Curve implementation by Angle Team\n    function _updateMiningParameters() internal {\n        // When entering this function, we always have: `(block.timestamp - startEpochTime) / RATE_REDUCTION_TIME >= 1`\n        uint256 epochDelta = (block.timestamp - startEpochTime) / RATE_REDUCTION_TIME;\n\n        // Storing intermediate values for the rate and for the `startEpochSupply`\n        uint256 _rate = rate;\n        uint256 _startEpochSupply = startEpochSupply;\n\n        startEpochTime += RATE_REDUCTION_TIME * epochDelta;\n        miningEpoch += epochDelta;\n\n        for (uint256 i = 0; i < epochDelta; i++) {\n            // Updating the intermediate values of the `startEpochSupply`\n            _startEpochSupply += _rate * RATE_REDUCTION_TIME;\n            _rate = (_rate * BASE) / RATE_REDUCTION_COEFFICIENT;\n        }\n        rate = _rate;\n        startEpochSupply = _startEpochSupply;\n        emit UpdateMiningParameters(block.timestamp, _rate, _startEpochSupply);\n    }\n\n    /// @notice Toggles the fact that a gauge delegate can be used for automation or not and therefore supports\n    /// the `notifyReward` interface\n    /// @param _delegateGauge Address of the gauge to change\n    function _toggleInterfaceKnown(address _delegateGauge) internal {\n        bool isInterfaceKnownMem = isInterfaceKnown[_delegateGauge];\n        isInterfaceKnown[_delegateGauge] = !isInterfaceKnownMem;\n        emit InterfaceKnownToggled(_delegateGauge, !isInterfaceKnownMem);\n    }\n\n    // ================= Permissionless External Functions =========================\n\n    /// @notice Distributes rewards to a staking contract (also called gauge)\n    /// @param gaugeAddr Address of the gauge to send tokens too\n    /// @return weeksElapsed Number of weeks elapsed since the last time rewards were distributed\n    /// @return rewardTally Amount of tokens sent to the gauge\n    /// @dev Anyone can call this function to distribute rewards to the different staking contracts\n    function distributeReward(address gaugeAddr) external nonReentrant returns (uint256, uint256) {\n        // Checking if distribution is on\n        require(distributionsOn == true, \"109\");\n        // Updating rate distribution parameters if need be\n        if (block.timestamp >= startEpochTime + RATE_REDUCTION_TIME) {\n            _updateMiningParameters();\n        }\n        return _distributeReward(gaugeAddr);\n    }\n\n    /// @notice Distributes rewards to multiple staking contracts\n    /// @param gauges Addresses of the gauge to send tokens too\n    /// @dev Anyone can call this function to distribute rewards to the different staking contracts\n    /// @dev Compared with the `distributeReward` function, this function sends rewards to multiple\n    /// contracts at the same time\n    function distributeRewardToMultipleGauges(address[] memory gauges) external nonReentrant {\n        // Checking if distribution is on\n        require(distributionsOn == true, \"109\");\n        // Updating rate distribution parameters if need be\n        if (block.timestamp >= startEpochTime + RATE_REDUCTION_TIME) {\n            _updateMiningParameters();\n        }\n        for (uint256 i = 0; i < gauges.length; i++) {\n            _distributeReward(gauges[i]);\n        }\n    }\n\n    /// @notice Updates mining rate and supply at the start of the epoch\n    /// @dev Callable by any address, but only once per epoch\n    function updateMiningParameters() external {\n        require(block.timestamp >= startEpochTime + RATE_REDUCTION_TIME, \"108\");\n        _updateMiningParameters();\n    }\n\n    // ========================= Governor Functions ================================\n\n    /// @notice Withdraws ERC20 tokens that could accrue on this contract\n    /// @param tokenAddress Address of the ERC20 token to withdraw\n    /// @param to Address to transfer to\n    /// @param amount Amount to transfer\n    /// @dev Added to support recovering LP Rewards and other mistaken tokens\n    /// from other systems to be distributed to holders\n    /// @dev This function could also be used to recover ANGLE tokens in case the rate got smaller\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external onlyRole(GOVERNOR_ROLE) {\n        // If the token is the ANGLE token, we need to make sure that governance is not going to withdraw\n        // too many tokens and that it'll be able to sustain the weekly distribution forever\n        // This check assumes that `distributeReward` has been called for gauges and that there are no gauges\n        // which have not received their past week's rewards\n        if (tokenAddress == address(rewardToken)) {\n            uint256 currentBalance = rewardToken.balanceOf(address(this));\n            // The amount distributed till the end is `rate * WEEK / (1 - RATE_REDUCTION_FACTOR)` where\n            // `RATE_REDUCTION_FACTOR = BASE / RATE_REDUCTION_COEFFICIENT` which translates to:\n            require(\n                currentBalance >=\n                    ((rate * RATE_REDUCTION_COEFFICIENT) * WEEK) / (RATE_REDUCTION_COEFFICIENT - BASE) + amount,\n                \"4\"\n            );\n        }\n        IERC20(tokenAddress).safeTransfer(to, amount);\n        emit Recovered(tokenAddress, to, amount);\n    }\n\n    /// @notice Sets a new gauge controller\n    /// @param _controller Address of the new gauge controller\n    function setGaugeController(address _controller) external onlyRole(GOVERNOR_ROLE) {\n        require(_controller != address(0), \"0\");\n        controller = IGaugeController(_controller);\n        emit GaugeControllerUpdated(_controller);\n    }\n\n    /// @notice Sets a new delegate gauge for pulling rewards of a type >= 2 gauges or of all type >= 2 gauges\n    /// @param gaugeAddr Gauge to change the delegate of\n    /// @param _delegateGauge Address of the new gauge delegate related to `gaugeAddr`\n    /// @param toggleInterface Whether we should toggle the fact that the `_delegateGauge` is built for automation or not\n    /// @dev This function can be used to remove delegating or introduce the pulling of rewards to a given address\n    /// @dev If `gaugeAddr` is the zero address, this function updates the delegate gauge common to all gauges with type >= 2\n    /// @dev The `toggleInterface` parameter has been added for convenience to save one transaction when adding a gauge delegate\n    /// which supports the `notifyReward` interface\n    function setDelegateGauge(\n        address gaugeAddr,\n        address _delegateGauge,\n        bool toggleInterface\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (gaugeAddr != address(0)) {\n            delegateGauges[gaugeAddr] = _delegateGauge;\n        } else {\n            delegateGauge = _delegateGauge;\n        }\n        emit DelegateGaugeUpdated(gaugeAddr, _delegateGauge);\n\n        if (toggleInterface) {\n            _toggleInterfaceKnown(_delegateGauge);\n        }\n    }\n\n    /// @notice Changes the ANGLE emission rate\n    /// @param _newRate New ANGLE emission rate\n    /// @dev It is important to be super wary when calling this function and to make sure that `distributeReward`\n    /// has been called for all gauges in the past weeks. If not, gauges may get an incorrect distribution of ANGLE rewards\n    /// for these past weeks based on the new rate and not on the old rate\n    /// @dev Governance should thus make sure to call this function rarely and when it does to do it after the weekly `distributeReward`\n    /// calls for all existing gauges\n    /// @dev As this function assumes that `distributeReward` has been called during the week, it also assumes that the `startEpochSupply`\n    /// parameter has been put up to date\n    function setRate(uint256 _newRate) external onlyRole(GOVERNOR_ROLE) {\n        // Checking if the new rate is compatible with the amount of ANGLE tokens this contract has in balance\n        // This check assumes, like this function, that `distributeReward` has correctly been called before\n        require(\n            rewardToken.balanceOf(address(this)) >=\n                ((_newRate * RATE_REDUCTION_COEFFICIENT) * WEEK) / (RATE_REDUCTION_COEFFICIENT - BASE),\n            \"4\"\n        );\n        rate = _newRate;\n        emit RateUpdated(_newRate);\n    }\n\n    /// @notice Toggles the status of a gauge to either killed or unkilled\n    /// @param gaugeAddr Gauge to toggle the status of\n    /// @dev It is impossible to kill a gauge in the `GaugeController` contract, for this reason killing of gauges\n    /// takes place in the `AngleDistributor` contract\n    /// @dev This means that people could vote for a gauge in the gauge controller contract but that rewards are not going\n    /// to be distributed to it in the end: people would need to remove their weights on the gauge killed to end the diminution\n    /// in rewards\n    /// @dev In the case of a gauge being killed, this function resets the timestamps at which this gauge has been approved and\n    /// disapproves the gauge to spend the token\n    /// @dev It should be cautiously called by governance as it could result in less ANGLE overall rewards than initially planned\n    /// if people do not remove their voting weights to the killed gauge\n    function toggleGauge(address gaugeAddr) external onlyRole(GOVERNOR_ROLE) {\n        bool gaugeKilledMem = killedGauges[gaugeAddr];\n        if (!gaugeKilledMem) {\n            delete lastTimeGaugePaid[gaugeAddr];\n            rewardToken.safeApprove(gaugeAddr, 0);\n        }\n        killedGauges[gaugeAddr] = !gaugeKilledMem;\n        emit GaugeToggled(gaugeAddr, !gaugeKilledMem);\n    }\n\n    // ========================= Guardian Function =================================\n\n    /// @notice Halts or activates distribution of rewards\n    function toggleDistributions() external onlyRole(GUARDIAN_ROLE) {\n        bool distributionsOnMem = distributionsOn;\n        distributionsOn = !distributionsOnMem;\n        emit DistributionsToggled(!distributionsOnMem);\n    }\n\n    /// @notice Notifies that the interface of a gauge delegate is known or has changed\n    /// @param _delegateGauge Address of the gauge to change\n    /// @dev Gauge delegates that are built for automation should be toggled\n    function toggleInterfaceKnown(address _delegateGauge) external onlyRole(GUARDIAN_ROLE) {\n        _toggleInterfaceKnown(_delegateGauge);\n    }\n}\n"
    },
    "contracts/genericLender/GenericAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/external/uniswap/IUniswapRouter.sol\";\nimport \"../interfaces/external/aave/IAave.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\nstruct AaveReferences {\n    IAToken aToken;\n    IProtocolDataProvider protocolDataProvider;\n    IStakedAave stkAave;\n    address aave;\n}\n\n/// @title GenericAave\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericAave.sol\n/// @notice A contract to lend any ERC20 to Aave\n/// @dev This contract is already in production, see at 0x71bE8726C96873F04d2690AA05b2ACcA7C7104d0 or there: https://etherscan.io/address/0xb164c0f42d9C6DBf976b60962fFe790A35e42b13#code\ncontract GenericAave is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event PathUpdated(bytes _path);\n    event IncentivisedUpdated(bool _isIncentivised);\n    event CustomReferralUpdated(uint16 customReferral);\n\n    uint256 internal constant _SECONDS_IN_YEAR = 365 days;\n    uint16 internal constant _DEFAULT_REFERRAL = 179; // jmonteer's referral code\n\n    // ==================== References to contracts =============================\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    IAToken public immutable aToken;\n    IProtocolDataProvider public immutable protocolDataProvider;\n    IStakedAave public immutable stkAave;\n    address public immutable aave;\n    IUniswapV3Router public immutable uniswapV3Router;\n    // Used to get the `want` price of the AAVE token\n    IUniswapV2Router public immutable uniswapV2Router;\n\n    // ==================== Parameters =============================\n\n    bytes public path;\n    bool public isIncentivised;\n    uint16 internal _customReferral;\n\n    // ============================= Constructor =============================\n\n    /// @param _path Bytes to encode the swap from aave to want\n    constructor(\n        address _strategy,\n        string memory name,\n        IUniswapV3Router _uniswapV3Router,\n        IUniswapV2Router _uniswapV2Router,\n        AaveReferences memory aaveReferences,\n        bool _isIncentivised,\n        bytes memory _path,\n        address[] memory governorList,\n        address guardian\n    ) GenericLenderBase(_strategy, name, governorList, guardian) {\n        // This transaction is going to revert if `_strategy`, `aave`, `protocolDataProvider` or `aToken`\n        // are equal to the zero address\n        require(\n            address(_uniswapV2Router) != address(0) &&\n                address(_uniswapV3Router) != address(0) &&\n                address(aaveReferences.stkAave) != address(0),\n            \"0\"\n        );\n        require(\n            !_isIncentivised || address(aaveReferences.aToken.getIncentivesController()) != address(0),\n            \"aToken does not have incentives controller set up\"\n        );\n        uniswapV3Router = _uniswapV3Router;\n        uniswapV2Router = _uniswapV2Router;\n        aToken = aaveReferences.aToken;\n        protocolDataProvider = aaveReferences.protocolDataProvider;\n        stkAave = aaveReferences.stkAave;\n        aave = aaveReferences.aave;\n        isIncentivised = _isIncentivised;\n        path = _path;\n        ILendingPool lendingPool = ILendingPool(\n            aaveReferences.protocolDataProvider.ADDRESSES_PROVIDER().getLendingPool()\n        );\n        // We cannot store a `lendingPool` variable here otherwise we would get a stack too deep problem\n        require(\n            lendingPool.getReserveData(address(want)).aTokenAddress == address(aaveReferences.aToken),\n            \"wrong aToken\"\n        );\n        IERC20(address(want)).safeApprove(address(lendingPool), type(uint256).max);\n        // Approving the Uniswap router for the transactions\n        IERC20(aaveReferences.aave).safeApprove(address(_uniswapV3Router), type(uint256).max);\n    }\n\n    // ============================= External Functions =============================\n\n    /// @notice Deposits the current balance to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        _deposit(balance);\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount Amount to withdraw\n    /// @return Amount actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the `PoolManager`\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or if the amount withdrawn is correct\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        _lendingPool().withdraw(address(want), amount, address(this));\n\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    /// @notice Withdraws as much as possible\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    function startCooldown() external onlyRole(GUARDIAN_ROLE) {\n        // for emergency cases\n        IStakedAave(stkAave).cooldown(); // it will revert if balance of stkAave == 0\n    }\n\n    /// @notice Trigger to claim rewards once every 10 days\n    /// Only callable if the token is incentivised by Aave Governance (_checkCooldown returns true)\n    /// @dev Only for incentivised aTokens\n    function harvest() external {\n        require(_checkCooldown(), \"conditions are not met\");\n        // redeem AAVE from stkAave\n        uint256 stkAaveBalance = IERC20(address(stkAave)).balanceOf(address(this));\n        if (stkAaveBalance > 0) {\n            stkAave.redeem(address(this), stkAaveBalance);\n        }\n\n        // sell AAVE for want\n        uint256 aaveBalance = IERC20(aave).balanceOf(address(this));\n        _sellAAVEForWant(aaveBalance);\n\n        // deposit want in lending protocol\n        uint256 balance = want.balanceOf(address(this));\n        if (balance > 0) {\n            _deposit(balance);\n        }\n\n        // claim rewards\n        address[] memory assets = new address[](1);\n        assets[0] = address(aToken);\n        uint256 pendingRewards = _incentivesController().getRewardsBalance(assets, address(this));\n        if (pendingRewards > 0) {\n            _incentivesController().claimRewards(assets, pendingRewards, address(this));\n        }\n\n        // request start of cooldown period\n        if (IERC20(address(stkAave)).balanceOf(address(this)) > 0) {\n            stkAave.cooldown();\n        }\n    }\n\n    // ============================= External View Functions =============================\n\n    /// @notice Returns the current total of assets managed\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @notice Returns the current balance of aTokens\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        balance = aToken.balanceOf(address(this));\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by a factor\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// @param extraAmount The amount to add to the lending platform\n    function aprAfterDeposit(uint256 extraAmount) external view override returns (uint256) {\n        // i need to calculate new supplyRate after Deposit (when deposit has not been done yet)\n        DataTypes.ReserveData memory reserveData = _lendingPool().getReserveData(address(want));\n\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            ,\n            ,\n            ,\n            uint256 averageStableBorrowRate,\n            ,\n            ,\n\n        ) = protocolDataProvider.getReserveData(address(want));\n\n        uint256 newLiquidity = availableLiquidity + extraAmount;\n\n        (, , , , uint256 reserveFactor, , , , , ) = protocolDataProvider.getReserveConfigurationData(address(want));\n\n        (uint256 newLiquidityRate, , ) = IReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n            .calculateInterestRates(\n                address(want),\n                newLiquidity,\n                totalStableDebt,\n                totalVariableDebt,\n                averageStableBorrowRate,\n                reserveFactor\n            );\n        uint256 incentivesRate = _incentivesRate(newLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n\n        return newLiquidityRate / 1e9 + incentivesRate; // divided by 1e9 to go from Ray to Wad\n    }\n\n    /// @notice Checks if assets are currently managed by this contract\n    function hasAssets() external view override returns (bool) {\n        return aToken.balanceOf(address(this)) > 0;\n    }\n\n    /// @notice Checks if harvest is callable\n    function harvestTrigger() external view returns (bool) {\n        return _checkCooldown();\n    }\n\n    // ============================= Internal Functions =============================\n\n    /// @notice See `apr`\n    function _apr() internal view returns (uint256) {\n        uint256 liquidityRate = uint256(_lendingPool().getReserveData(address(want)).currentLiquidityRate) / 1e9; // dividing by 1e9 to pass from ray to wad\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n\n        ) = protocolDataProvider.getReserveData(address(want));\n        uint256 incentivesRate = _incentivesRate(availableLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n        return liquidityRate + incentivesRate;\n    }\n\n    /// @notice See `nav`\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = aToken.balanceOf(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(aToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                _lendingPool().withdraw(address(want), toWithdraw, address(this));\n            } else {\n                //take all we can\n                _lendingPool().withdraw(address(want), liquidity, address(this));\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice See `deposit`\n    function _deposit(uint256 amount) internal {\n        ILendingPool lp = _lendingPool();\n        // NOTE: Checks if allowance is enough and acts accordingly\n        // allowance might not be enough if\n        //     i) initial allowance has been used (should take years)\n        //     ii) lendingPool contract address has changed (Aave updated the contract address)\n        if (want.allowance(address(this), address(lp)) < amount) {\n            IERC20(address(want)).safeApprove(address(lp), 0);\n            IERC20(address(want)).safeApprove(address(lp), type(uint256).max);\n        }\n\n        uint16 referral;\n        uint16 __customReferral = _customReferral;\n        if (__customReferral != 0) {\n            referral = __customReferral;\n        } else {\n            referral = _DEFAULT_REFERRAL;\n        }\n\n        lp.deposit(address(want), amount, address(this), referral);\n    }\n\n    /// @notice Returns address of lending pool from Aave's address provider\n    function _lendingPool() internal view returns (ILendingPool lendingPool) {\n        lendingPool = ILendingPool(protocolDataProvider.ADDRESSES_PROVIDER().getLendingPool());\n    }\n\n    /// @notice Checks if there is a need for calling harvest\n    function _checkCooldown() internal view returns (bool) {\n        if (!isIncentivised) {\n            return false;\n        }\n\n        uint256 cooldownStartTimestamp = IStakedAave(stkAave).stakersCooldowns(address(this));\n        uint256 cooldownSeconds = IStakedAave(stkAave).COOLDOWN_SECONDS();\n        uint256 unstakeWindow = IStakedAave(stkAave).UNSTAKE_WINDOW();\n        if (block.timestamp >= cooldownStartTimestamp + cooldownSeconds) {\n            return\n                block.timestamp - cooldownStartTimestamp + cooldownSeconds <= unstakeWindow ||\n                cooldownStartTimestamp == 0;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Calculates APR from Liquidity Mining Program\n    /// @param totalLiquidity Total liquidity available in the pool\n    /// @dev At Angle, compared with Yearn implementation, we have decided to add a check\n    /// about the `totalLiquidity` before entering the `if` branch\n    function _incentivesRate(uint256 totalLiquidity) internal view returns (uint256) {\n        // only returns != 0 if the incentives are in place at the moment.\n        // it will fail if the isIncentivised is set to true but there is no incentives\n        IAaveIncentivesController incentivesController = _incentivesController();\n        if (isIncentivised && block.timestamp < incentivesController.getDistributionEnd() && totalLiquidity > 0) {\n            uint256 _emissionsPerSecond;\n            (, _emissionsPerSecond, ) = _incentivesController().getAssetData(address(aToken));\n            if (_emissionsPerSecond > 0) {\n                uint256 emissionsInWant = _AAVEtoWant(_emissionsPerSecond); // amount of emissions in want\n\n                uint256 incentivesRate = (emissionsInWant * _SECONDS_IN_YEAR * 1e18) / totalLiquidity; // APRs are in 1e18\n\n                return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n            }\n        }\n        return 0;\n    }\n\n    /// @notice Estimates the value of `_amount` AAVE tokens\n    /// @param _amount Amount of AAVE to compute the `want` price of\n    /// @dev This function uses a UniswapV2 oracle to easily compute the price (which is not feasible\n    /// with UniswapV3)\n    ///@dev When entering this function, it has been checked that the `amount` parameter is not null\n    // solhint-disable-next-line func-name-mixedcase\n    function _AAVEtoWant(uint256 _amount) internal view returns (uint256) {\n        // We use a different path when trying to get the price of the AAVE in `want`\n        address[] memory pathPrice;\n\n        if (address(want) == address(WETH)) {\n            pathPrice = new address[](2);\n            pathPrice[0] = address(aave);\n            pathPrice[1] = address(want);\n        } else {\n            pathPrice = new address[](3);\n            pathPrice[0] = address(aave);\n            pathPrice[1] = address(WETH);\n            pathPrice[2] = address(want);\n        }\n\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(_amount, pathPrice);\n        return amounts[amounts.length - 1];\n    }\n\n    /// @notice Swaps an amount from `AAVE` to Want\n    /// @param _amount The amount to convert\n    function _sellAAVEForWant(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        if (IERC20(aave).allowance(address(this), address(uniswapV3Router)) < _amount) {\n            IERC20(aave).safeApprove(address(uniswapV3Router), 0);\n            IERC20(aave).safeApprove(address(uniswapV3Router), type(uint256).max);\n        }\n\n        uniswapV3Router.exactInput(ExactInputParams(path, address(this), block.timestamp, _amount, uint256(0)));\n    }\n\n    /// @notice Returns the incentive controller\n    function _incentivesController() internal view returns (IAaveIncentivesController) {\n        if (isIncentivised) {\n            return aToken.getIncentivesController();\n        } else {\n            return IAaveIncentivesController(address(0));\n        }\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(aToken);\n        return protected;\n    }\n\n    // ============================= Governance =============================\n\n    /// @notice For the management to activate / deactivate incentives functionality\n    /// @param _isIncentivised Boolean for activation\n    function setIsIncentivised(bool _isIncentivised) external onlyRole(GUARDIAN_ROLE) {\n        // NOTE: if the aToken is not incentivised, `getIncentivesController()` might revert (aToken won't implement it)\n        // to avoid calling it, we use the OR and lazy evaluation\n        require(\n            !_isIncentivised || address(aToken.getIncentivesController()) != address(0),\n            \"aToken does not have incentives controller set up\"\n        );\n        isIncentivised = _isIncentivised;\n        emit IncentivisedUpdated(_isIncentivised);\n    }\n\n    /// @notice Sets the referral\n    /// @param __customReferral New custom referral\n    function setReferralCode(uint16 __customReferral) external onlyRole(GUARDIAN_ROLE) {\n        require(__customReferral != 0, \"invalid referral code\");\n        _customReferral = __customReferral;\n        emit CustomReferralUpdated(_customReferral);\n    }\n\n    /// @notice Sets the path for swap of AAVE to `want`\n    /// @param _path New path\n    function setPath(bytes memory _path) external onlyRole(GUARDIAN_ROLE) {\n        path = _path;\n        emit PathUpdated(_path);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/dao/ANGLE.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\n\n/// @title ANGLE\n/// @author Forked but improved from https://github.com/compound-finance/compound-protocol/tree/master/contracts/Governance\n/// by Angle Core Team\n/// @notice Governance token of Angle's protocol\ncontract ANGLE is ERC20Votes {\n    /// @notice An event that is emitted when the minter address is changed\n    event MinterChanged(address minter, address newMinter);\n\n    /// @notice Minimum time between mints\n    uint32 public constant MINIMUM_BETWEEN_MINTS = 1 days * 30;\n\n    /// @notice Cap on the percentage of `totalSupply()` that can be minted at each mint\n    uint8 public constant MAX_MINT = 1;\n\n    /// @notice Address which may mint new tokens\n    address public minter;\n\n    /// @notice The timestamp after which minting may occur\n    uint256 public mintingAllowedAfter;\n\n    /// @notice Constructs a new ANGLE token\n    /// @param account Initial account to grant all the tokens to\n    /// @param minter_ Account with minting ability\n    constructor(address account, address minter_) ERC20Permit(\"ANGLE\") ERC20(\"ANGLE\", \"ANGLE\") {\n        require(account != address(0) && minter_ != address(0), \"0\");\n        _mint(account, 1_000_000_000e18); // 1 billion ANGLE\n        minter = minter_;\n        emit MinterChanged(address(0), minter);\n        mintingAllowedAfter = block.timestamp;\n    }\n\n    /// @notice Changes the minter address\n    /// @param minter_ Address of the new minter\n    function setMinter(address minter_) external {\n        require(msg.sender == minter, \"67\");\n        require(minter_ != address(0), \"0\");\n        emit MinterChanged(minter, minter_);\n        minter = minter_;\n    }\n\n    /// @notice Mints new tokens\n    /// @param dst Address of the destination account\n    /// @param amount Number of tokens to be minted\n    function mint(address dst, uint256 amount) external {\n        require(msg.sender == minter, \"68\");\n        require(block.timestamp >= mintingAllowedAfter, \"69\");\n        require(amount <= (totalSupply() * MAX_MINT) / 100, \"70\");\n        // Record the mint\n        mintingAllowedAfter = block.timestamp + MINIMUM_BETWEEN_MINTS;\n\n        // Mint the amount\n        _mint(dst, amount);\n    }\n}\n"
    },
    "contracts/mock/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockOracle is IOracle {\n    event Update(uint256 _peg);\n\n    uint256 public base = 10**18;\n    uint256 public override inBase;\n    uint256 public precision = 10**18;\n    uint256 public rate;\n    bool public outdated;\n\n    /// @notice Initiate with a fixe change rate\n    constructor(uint256 rate_, uint256 _inDecimals) {\n        rate = rate_;\n        inBase = 10**_inDecimals;\n    }\n\n    /// @notice Mock read\n    function read() external view override returns (uint256) {\n        return rate;\n    }\n\n    function readAll() external view override returns (uint256, uint256) {\n        return (rate, rate);\n    }\n\n    /// @notice Mock readLower\n    function readLower() external view override returns (uint256) {\n        return rate;\n    }\n\n    /// @notice Mock readUpper\n    function readUpper() external view override returns (uint256) {\n        return rate;\n    }\n\n    /// @notice Mock readQuote\n    function readQuote(uint256 baseAmount) external view override returns (uint256) {\n        return (baseAmount * rate * base) / (precision * inBase);\n    }\n\n    /// @notice Mock readQuoteLower\n    function readQuoteLower(uint256 baseAmount) external view override returns (uint256) {\n        return (baseAmount * rate * base) / (precision * inBase);\n    }\n\n    /// @notice change oracle rate\n    function update(uint256 newRate) external {\n        rate = newRate;\n    }\n\n    function changeInBase(uint256 newInBase) external {\n        inBase = newInBase;\n    }\n}\n"
    },
    "contracts/strategies/Strategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./StrategyEvents.sol\";\n\n/// @title Strategy\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat\n/// @notice A lender optimisation strategy for any ERC20 asset\n/// @dev This strategy works by taking plugins designed for standard lending platforms\n/// It automatically chooses the best yield generating platform and adjusts accordingly\n/// The adjustment is sub optimal so there is an additional option to manually set position\ncontract Strategy is StrategyEvents, BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ======================== References to contracts ============================\n\n    IGenericLender[] public lenders;\n\n    // ======================== Parameters =========================================\n\n    uint256 public withdrawalThreshold;\n\n    // ============================== Constructor ==================================\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param _rewards  The token given to reward keepers.\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    constructor(\n        address _poolManager,\n        IERC20 _rewards,\n        address[] memory governorList,\n        address guardian\n    ) BaseStrategy(_poolManager, _rewards, governorList, guardian) {\n        withdrawalThreshold = 1000 * wantBase;\n    }\n\n    // ========================== Internal Mechanics ===============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = 0;\n        _loss = 0; //for clarity\n        _debtPayment = _debtOutstanding;\n\n        uint256 lentAssets = lentTotalAssets();\n\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        uint256 total = looseAssets + lentAssets;\n\n        if (lentAssets == 0) {\n            // No position to harvest or profit to report\n            if (_debtPayment > looseAssets) {\n                // We can only return looseAssets\n                _debtPayment = looseAssets;\n            }\n\n            return (_profit, _loss, _debtPayment);\n        }\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (total > debt) {\n            _profit = total - debt;\n\n            uint256 amountToFree = _profit + _debtPayment;\n            // We need to add outstanding to our profit\n            // don't need to do logic if there is nothing to free\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_profit > newLoose) {\n                        _profit = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _profit, _debtPayment);\n                    }\n                }\n            }\n        } else {\n            // Serious loss should never happen but if it does lets record it accurately\n            _loss = debt - total;\n\n            uint256 amountToFree = _loss + _debtPayment;\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust `_debtOutstanding` and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_loss > newLoose) {\n                        _loss = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _loss, _debtPayment);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Estimates highest and lowest apr lenders among a `lendersList`\n    /// @param lendersList List of all the lender contracts associated to this strategy\n    /// @return _lowest The index of the lender in the `lendersList` with lowest apr\n    /// @return _lowestApr The lowest apr\n    /// @return _highest The index of the lender with highest apr\n    /// @return _potential The potential apr of this lender if funds are moved from lowest to highest\n    /// @dev `lendersList` is kept as a parameter to avoid multiplying reads in storage to the `lenders`\n    /// array\n    function _estimateAdjustPosition(IGenericLender[] memory lendersList)\n        internal\n        view\n        returns (\n            uint256 _lowest,\n            uint256 _lowestApr,\n            uint256 _highest,\n            uint256 _potential\n        )\n    {\n        //all loose assets are to be invested\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        // our simple algo\n        // get the lowest apr strat\n        // cycle through and see who could take its funds plus want for the highest apr\n        _lowestApr = type(uint256).max;\n        _lowest = 0;\n        uint256 lowestNav = 0;\n\n        uint256 highestApr = 0;\n        _highest = 0;\n\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            uint256 aprAfterDeposit = lendersList[i].aprAfterDeposit(looseAssets);\n            if (aprAfterDeposit > highestApr) {\n                highestApr = aprAfterDeposit;\n                _highest = i;\n            }\n\n            if (lendersList[i].hasAssets()) {\n                uint256 apr = lendersList[i].apr();\n                if (apr < _lowestApr) {\n                    _lowestApr = apr;\n                    _lowest = i;\n                    lowestNav = lendersList[i].nav();\n                }\n            }\n        }\n\n        //if we can improve apr by withdrawing we do so\n        _potential = lendersList[_highest].aprAfterDeposit(lowestNav + looseAssets);\n    }\n\n    /// @notice Function called by keepers to adjust the position\n    /// @dev The algorithm moves assets from lowest return to highest\n    /// like a very slow idiot bubble sort\n    function _adjustPosition() internal override {\n        // Emergency exit is dealt with at beginning of harvest\n        if (emergencyExit) {\n            return;\n        }\n        // Storing the `lenders` array in a cache variable\n        IGenericLender[] memory lendersList = lenders;\n        // We just keep all money in want if we dont have any lenders\n        if (lendersList.length == 0) {\n            return;\n        }\n\n        (uint256 lowest, uint256 lowestApr, uint256 highest, uint256 potential) = _estimateAdjustPosition(lendersList);\n\n        if (potential > lowestApr) {\n            // Apr should go down after deposit so won't be withdrawing from self\n            lendersList[lowest].withdrawAll();\n        }\n\n        uint256 bal = want.balanceOf(address(this));\n        if (bal > 0) {\n            want.safeTransfer(address(lendersList[highest]), bal);\n            lendersList[highest].deposit();\n        }\n    }\n\n    /// @notice Withdraws a given amount from lenders\n    /// @param _amount The amount to withdraw\n    /// @dev Cycle through withdrawing from worst rate first\n    function _withdrawSome(uint256 _amount) internal returns (uint256 amountWithdrawn) {\n        IGenericLender[] memory lendersList = lenders;\n        if (lendersList.length == 0) {\n            return 0;\n        }\n\n        // Don't withdraw dust\n        if (_amount < withdrawalThreshold) {\n            return 0;\n        }\n\n        amountWithdrawn = 0;\n        // In most situations this will only run once. Only big withdrawals will be a gas guzzler\n        uint256 j = 0;\n        while (amountWithdrawn < _amount) {\n            uint256 lowestApr = type(uint256).max;\n            uint256 lowest = 0;\n            for (uint256 i = 0; i < lendersList.length; i++) {\n                if (lendersList[i].hasAssets()) {\n                    uint256 apr = lendersList[i].apr();\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowest = i;\n                    }\n                }\n            }\n            if (!lendersList[lowest].hasAssets()) {\n                return amountWithdrawn;\n            }\n            amountWithdrawn = amountWithdrawn + lendersList[lowest].withdraw(_amount - amountWithdrawn);\n            j++;\n            // To avoid want infinite loop\n            if (j >= 6) {\n                return amountWithdrawn;\n            }\n        }\n    }\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed, uint256 _loss) {\n        uint256 _balance = want.balanceOf(address(this));\n\n        if (_balance >= _amountNeeded) {\n            //if we don't set reserve here withdrawer will be sent our full balance\n            return (_amountNeeded, 0);\n        } else {\n            uint256 received = _withdrawSome(_amountNeeded - _balance) + (_balance);\n            if (received >= _amountNeeded) {\n                return (_amountNeeded, 0);\n            } else {\n                return (received, 0);\n            }\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        (_amountFreed, ) = _liquidatePosition(estimatedTotalAssets());\n    }\n\n    // ========================== View Functions ===================================\n\n    struct LendStatus {\n        string name;\n        uint256 assets;\n        uint256 rate;\n        address add;\n    }\n\n    /// @notice View function to check the current state of the strategy\n    /// @return Returns the status of all lenders attached the strategy\n    function lendStatuses() external view returns (LendStatus[] memory) {\n        uint256 lendersListLength = lenders.length;\n        LendStatus[] memory statuses = new LendStatus[](lendersListLength);\n        for (uint256 i = 0; i < lendersListLength; i++) {\n            LendStatus memory s;\n            s.name = lenders[i].lenderName();\n            s.add = address(lenders[i]);\n            s.assets = lenders[i].nav();\n            s.rate = lenders[i].apr();\n            statuses[i] = s;\n        }\n        return statuses;\n    }\n\n    /// @notice View function to check the total assets lent\n    function lentTotalAssets() public view returns (uint256) {\n        uint256 nav = 0;\n        for (uint256 i = 0; i < lenders.length; i++) {\n            nav = nav + lenders[i].nav();\n        }\n        return nav;\n    }\n\n    /// @notice View function to check the total assets managed by the strategy\n    function estimatedTotalAssets() public view override returns (uint256 nav) {\n        nav = lentTotalAssets() + want.balanceOf(address(this));\n    }\n\n    /// @notice View function to check the number of lending platforms\n    function numLenders() external view returns (uint256) {\n        return lenders.length;\n    }\n\n    /// @notice The weighted apr of all lenders. sum(nav * apr)/totalNav\n    function estimatedAPR() external view returns (uint256) {\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) {\n            return 0;\n        }\n\n        uint256 weightedAPR = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            weightedAPR = weightedAPR + lenders[i].weightedApr();\n        }\n\n        return weightedAPR / bal;\n    }\n\n    /// @notice Prevents the governance from withdrawing want tokens\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    // ============================ Governance =====================================\n\n    struct LenderRatio {\n        address lender;\n        //share x 1000\n        uint16 share;\n    }\n\n    /// @notice Reallocates all funds according to a new distributions\n    /// @param _newPositions List of shares to specify the new allocation\n    /// @dev Share must add up to 1000. 500 means 50% etc\n    /// @dev This code has been forked, so we have not thoroughly tested it on our own\n    function manualAllocation(LenderRatio[] memory _newPositions) external onlyRole(GUARDIAN_ROLE) {\n        IGenericLender[] memory lendersList = lenders;\n        uint256 share = 0;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            lendersList[i].withdrawAll();\n        }\n\n        uint256 assets = want.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n            bool found = false;\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n            for (uint256 j = 0; j < lendersList.length; j++) {\n                if (address(lendersList[j]) == _newPositions[i].lender) {\n                    found = true;\n                }\n            }\n            require(found, \"94\");\n\n            share = share + _newPositions[i].share;\n            uint256 toSend = (assets * _newPositions[i].share) / 1000;\n            want.safeTransfer(_newPositions[i].lender, toSend);\n            IGenericLender(_newPositions[i].lender).deposit();\n        }\n\n        require(share == 1000, \"95\");\n    }\n\n    /// @notice Changes the withdrawal threshold\n    /// @param _threshold The new withdrawal threshold\n    /// @dev governor, guardian or `PoolManager` only\n    function setWithdrawalThreshold(uint256 _threshold) external onlyRole(GUARDIAN_ROLE) {\n        withdrawalThreshold = _threshold;\n    }\n\n    /// @notice Add lenders for the strategy to choose between\n    /// @param newLender The adapter to the added lending platform\n    /// @dev Governor, guardian or `PoolManager` only\n    function addLender(IGenericLender newLender) external onlyRole(GUARDIAN_ROLE) {\n        require(newLender.strategy() == address(this), \"96\");\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            require(address(newLender) != address(lenders[i]), \"97\");\n        }\n        lenders.push(newLender);\n\n        emit AddLender(address(newLender));\n    }\n\n    /// @notice Removes a lending platform and fails if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function safeRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, false);\n    }\n\n    /// @notice Removes a lending platform and even if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function forceRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, true);\n    }\n\n    /// @notice Internal function to handle lending platform removing\n    /// @param lender The address of the adapter for the lending platform to remove\n    /// @param force Whether it is required that all the funds are withdrawn prior to removal\n    function _removeLender(address lender, bool force) internal {\n        IGenericLender[] memory lendersList = lenders;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            if (lender == address(lendersList[i])) {\n                bool allWithdrawn = lendersList[i].withdrawAll();\n\n                if (!force) {\n                    require(allWithdrawn, \"98\");\n                }\n\n                // Put the last index here\n                // then remove last index\n                if (i != lendersList.length - 1) {\n                    lenders[i] = lendersList[lendersList.length - 1];\n                }\n\n                // Pop shortens array by 1 thereby deleting the last index\n                lenders.pop();\n\n                // If balance to spend we might as well put it into the best lender\n                if (want.balanceOf(address(this)) > 0) {\n                    _adjustPosition();\n                }\n\n                emit RemoveLender(lender);\n\n                return;\n            }\n        }\n        require(false, \"94\");\n    }\n\n    // ========================== Manager functions ================================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].grantRole(GUARDIAN_ROLE, _guardian);\n        }\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].revokeRole(GUARDIAN_ROLE, guardian);\n        }\n    }\n}\n"
    },
    "contracts/staking/RewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./RewardsDistributorEvents.sol\";\n\n/// @notice Distribution parameters for a given contract\nstruct StakingParameters {\n    // Amount of rewards distributed since the beginning\n    uint256 distributedRewards;\n    // Last time rewards were distributed to the staking contract\n    uint256 lastDistributionTime;\n    // Frequency with which rewards should be given to the underlying contract\n    uint256 updateFrequency;\n    // Number of tokens distributed for the person calling the update function\n    uint256 incentiveAmount;\n    // Time at which reward distribution started for this reward contract\n    uint256 timeStarted;\n    // Amount of time during which rewards will be distributed\n    uint256 duration;\n    // Amount of tokens to distribute to the concerned contract\n    uint256 amountToDistribute;\n}\n\n/// @title RewardsDistributor\n/// @author Angle Core Team (forked form FEI Protocol)\n/// @notice Controls and handles the distribution of governance tokens to the different staking contracts of the protocol\n/// @dev Inspired from FEI contract:\n/// https://github.com/fei-protocol/fei-protocol-core/blob/master/contracts/staking/FeiRewardsDistributor.sol\ncontract RewardsDistributor is RewardsDistributorEvents, IRewardsDistributor, AccessControl {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    // ============================ Reference to a contract ========================\n\n    /// @notice Token used as a reward\n    IERC20 public immutable override rewardToken;\n\n    // ============================== Parameters ===================================\n\n    /// @notice Maps a `StakingContract` to its distribution parameters\n    mapping(IStakingRewards => StakingParameters) public stakingContractsMap;\n\n    /// @notice List of all the staking contracts handled by the rewards distributor\n    /// Used to be able to change the rewards distributor and propagate a new reference to the underlying\n    /// staking contract\n    IStakingRewards[] public stakingContractsList;\n\n    // ============================ Constructor ====================================\n\n    /// @notice Initializes the distributor contract with a first set of parameters\n    /// @param governorList List of the governor addresses of the protocol\n    /// @param guardian The guardian address, optional\n    /// @param rewardTokenAddress The ERC20 token to distribute\n    constructor(\n        address[] memory governorList,\n        address guardian,\n        address rewardTokenAddress\n    ) {\n        require(rewardTokenAddress != address(0) && guardian != address(0), \"0\");\n        require(governorList.length > 0, \"47\");\n        rewardToken = IERC20(rewardTokenAddress);\n        // Since this contract is independent from the rest of the protocol\n        // When updating the governor list, governors should make sure to still update the roles\n        // in this contract\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        for (uint256 i = 0; i < governorList.length; i++) {\n            require(governorList[i] != address(0), \"0\");\n            _setupRole(GOVERNOR_ROLE, governorList[i]);\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _setupRole(GUARDIAN_ROLE, guardian);\n    }\n\n    // ============================ External Functions =============================\n\n    /// @notice Sends reward tokens to the staking contract\n    /// @param stakingContract Reference to the staking contract\n    /// @dev The way to pause this function is to set `updateFrequency` to infinity,\n    /// or to completely delete the contract\n    /// @dev A keeper calling this function could be frontran by a miner seeing the potential profit\n    /// from calling this function\n    /// @dev This function automatically computes the amount of reward tokens to send to the staking\n    /// contract based on the time elapsed since the last drip, on the amount to distribute and on\n    /// the duration of the distribution\n    function drip(IStakingRewards stakingContract) external override returns (uint256) {\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n        require(stakingParams.duration > 0, \"80\");\n        require(_isDripAvailable(stakingParams), \"81\");\n\n        uint256 dripAmount = _computeDripAmount(stakingParams);\n        stakingParams.lastDistributionTime = block.timestamp;\n        require(dripAmount != 0, \"82\");\n        stakingParams.distributedRewards += dripAmount;\n        emit Dripped(msg.sender, dripAmount, address(stakingContract));\n\n        rewardToken.safeTransfer(address(stakingContract), dripAmount);\n        IStakingRewards(stakingContract).notifyRewardAmount(dripAmount);\n        _incentivize(stakingParams);\n\n        return dripAmount;\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Sends tokens back to governance treasury or another address\n    /// @param amount Amount of tokens to send back to treasury\n    /// @param to Address to send the tokens to\n    /// @dev Only callable by governance and not by the guardian\n    function governorWithdrawRewardToken(uint256 amount, address to) external override onlyRole(GOVERNOR_ROLE) {\n        emit RewardTokenWithdrawn(amount);\n        rewardToken.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to withdraw ERC20 tokens that could accrue on a staking contract\n    /// @param tokenAddress Address of the ERC20 to recover\n    /// @param to Address to transfer to\n    /// @param amount Amount to transfer\n    /// @param stakingContract Reference to the staking contract\n    /// @dev A use case would be to claim tokens if the staked tokens accumulate rewards or if tokens were\n    /// mistakenly sent to staking contracts\n    function governorRecover(\n        address tokenAddress,\n        address to,\n        uint256 amount,\n        IStakingRewards stakingContract\n    ) external override onlyRole(GOVERNOR_ROLE) {\n        stakingContract.recoverERC20(tokenAddress, to, amount);\n    }\n\n    /// @notice Sets a new rewards distributor contract and automatically makes this contract useless\n    /// @param newRewardsDistributor Address of the new rewards distributor contract\n    /// @dev This contract is not upgradeable, setting a new contract could allow for upgrades, which should be\n    /// propagated across all staking contracts\n    /// @dev This function transfers all the reward tokens to the new address\n    /// @dev The new rewards distributor contract should be initialized correctly with all the staking contracts\n    /// from the staking contract list\n    function setNewRewardsDistributor(address newRewardsDistributor) external override onlyRole(GOVERNOR_ROLE) {\n        // Checking the compatibility of the reward tokens. It is checked at the initialization of each staking contract\n        // in the `setStakingContract` function that reward tokens are compatible with the `rewardsDistributor`. If\n        // the `newRewardsDistributor` has a compatible rewards token, then all staking contracts will automatically be\n        // compatible with it\n        require(address(IRewardsDistributor(newRewardsDistributor).rewardToken()) == address(rewardToken), \"83\");\n        require(newRewardsDistributor != address(this), \"84\");\n        for (uint256 i = 0; i < stakingContractsList.length; i++) {\n            stakingContractsList[i].setNewRewardsDistribution(newRewardsDistributor);\n        }\n        rewardToken.safeTransfer(newRewardsDistributor, rewardToken.balanceOf(address(this)));\n        // The functions `setStakingContract` should then be called for each staking contract in the `newRewardsDistributor`\n        emit NewRewardsDistributor(newRewardsDistributor);\n    }\n\n    /// @notice Deletes a staking contract from the staking contract map and removes it from the\n    /// `stakingContractsList`\n    /// @param stakingContract Contract to remove\n    /// @dev Allows to clean some space and to avoid keeping in memory contracts which became useless\n    /// @dev It is also a way governance has to completely stop rewards distribution from a contract\n    function removeStakingContract(IStakingRewards stakingContract) external override onlyRole(GOVERNOR_ROLE) {\n        uint256 indexMet;\n        uint256 stakingContractsListLength = stakingContractsList.length;\n        require(stakingContractsListLength >= 1, \"80\");\n        for (uint256 i = 0; i < stakingContractsListLength - 1; i++) {\n            if (stakingContractsList[i] == stakingContract) {\n                indexMet = 1;\n                stakingContractsList[i] = stakingContractsList[stakingContractsListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || stakingContractsList[stakingContractsListLength - 1] == stakingContract, \"80\");\n\n        stakingContractsList.pop();\n\n        delete stakingContractsMap[stakingContract];\n        emit DeletedStakingContract(address(stakingContract));\n    }\n\n    // =================== Guardian Functions (for parameters) =====================\n\n    /// @notice Notifies and initializes a new staking contract\n    /// @param _stakingContract Address of the staking contract\n    /// @param _duration Time frame during which tokens will be distributed\n    /// @param _incentiveAmount Incentive amount given to keepers calling the update function\n    /// @param _updateFrequency Frequency when it is possible to call the update function and give tokens to the staking contract\n    /// @param _amountToDistribute Amount of gov tokens to give to the staking contract across all drips\n    /// @dev Called by governance to activate a contract\n    /// @dev After setting a new staking contract, everything is as if the contract had already been set for `_updateFrequency`\n    /// meaning that it is possible to `drip` the staking contract immediately after that\n    function setStakingContract(\n        address _stakingContract,\n        uint256 _duration,\n        uint256 _incentiveAmount,\n        uint256 _updateFrequency,\n        uint256 _amountToDistribute\n    ) external override onlyRole(GOVERNOR_ROLE) {\n        require(_duration > 0, \"85\");\n        require(_duration >= _updateFrequency && block.timestamp >= _updateFrequency, \"86\");\n\n        IStakingRewards stakingContract = IStakingRewards(_stakingContract);\n\n        require(stakingContract.rewardToken() == rewardToken, \"83\");\n\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n\n        stakingParams.updateFrequency = _updateFrequency;\n        stakingParams.incentiveAmount = _incentiveAmount;\n        stakingParams.lastDistributionTime = block.timestamp - _updateFrequency;\n        // In order to allow a drip whenever a `stakingContract` is set, we consider that staking has already started\n        // `_updateFrequency` ago\n        stakingParams.timeStarted = block.timestamp - _updateFrequency;\n        stakingParams.duration = _duration;\n        stakingParams.amountToDistribute = _amountToDistribute;\n        stakingContractsList.push(stakingContract);\n\n        emit NewStakingContract(_stakingContract);\n    }\n\n    /// @notice Sets the update frequency\n    /// @param _updateFrequency New update frequency\n    /// @param stakingContract Reference to the staking contract\n    function setUpdateFrequency(uint256 _updateFrequency, IStakingRewards stakingContract)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n    {\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n        require(stakingParams.duration > 0, \"80\");\n        require(stakingParams.duration >= _updateFrequency, \"87\");\n        stakingParams.updateFrequency = _updateFrequency;\n        emit FrequencyUpdated(_updateFrequency, address(stakingContract));\n    }\n\n    /// @notice Sets the incentive amount for calling drip\n    /// @param _incentiveAmount New incentive amount\n    /// @param stakingContract Reference to the staking contract\n    function setIncentiveAmount(uint256 _incentiveAmount, IStakingRewards stakingContract)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n    {\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n        require(stakingParams.duration > 0, \"80\");\n        stakingParams.incentiveAmount = _incentiveAmount;\n        emit IncentiveUpdated(_incentiveAmount, address(stakingContract));\n    }\n\n    /// @notice Sets the new amount to distribute to a staking contract\n    /// @param _amountToDistribute New amount to distribute\n    /// @param stakingContract Reference to the staking contract\n    function setAmountToDistribute(uint256 _amountToDistribute, IStakingRewards stakingContract)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n    {\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n        require(stakingParams.duration > 0, \"80\");\n        require(stakingParams.distributedRewards < _amountToDistribute, \"88\");\n        stakingParams.amountToDistribute = _amountToDistribute;\n        emit AmountToDistributeUpdated(_amountToDistribute, address(stakingContract));\n    }\n\n    /// @notice Sets the new duration with which tokens will be distributed to the staking contract\n    /// @param _duration New duration\n    /// @param stakingContract Reference to the staking contract\n    function setDuration(uint256 _duration, IStakingRewards stakingContract) external override onlyRole(GUARDIAN_ROLE) {\n        StakingParameters storage stakingParams = stakingContractsMap[stakingContract];\n        require(stakingParams.duration > 0, \"80\");\n        require(_duration >= stakingParams.updateFrequency, \"87\");\n        uint256 timeElapsed = _timeSinceStart(stakingParams);\n        require(timeElapsed < stakingParams.duration && timeElapsed < _duration, \"66\");\n        stakingParams.duration = _duration;\n        emit DurationUpdated(_duration, address(stakingContract));\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Gives the next time when `drip` could be called\n    /// @param stakingParams Parameters of the concerned staking contract\n    /// @return Block timestamp when `drip` will next be available\n    function _nextDripAvailable(StakingParameters memory stakingParams) internal pure returns (uint256) {\n        return stakingParams.lastDistributionTime + stakingParams.updateFrequency;\n    }\n\n    /// @notice Tells if `drip` can currently be called\n    /// @param stakingParams Parameters of the concerned staking contract\n    /// @return If the `updateFrequency` has passed since the last drip\n    function _isDripAvailable(StakingParameters memory stakingParams) internal view returns (bool) {\n        return block.timestamp >= _nextDripAvailable(stakingParams);\n    }\n\n    /// @notice Computes the amount of tokens to give at the current drip\n    /// @param stakingParams Parameters of the concerned staking contract\n    /// @dev Constant drip amount across time\n    function _computeDripAmount(StakingParameters memory stakingParams) internal view returns (uint256) {\n        if (stakingParams.distributedRewards >= stakingParams.amountToDistribute) {\n            return 0;\n        }\n        uint256 dripAmount = (stakingParams.amountToDistribute *\n            (block.timestamp - stakingParams.lastDistributionTime)) / stakingParams.duration;\n        uint256 timeLeft = stakingParams.duration - _timeSinceStart(stakingParams);\n        uint256 rewardsLeftToDistribute = stakingParams.amountToDistribute - stakingParams.distributedRewards;\n        if (timeLeft < stakingParams.updateFrequency || rewardsLeftToDistribute < dripAmount || timeLeft == 0) {\n            return rewardsLeftToDistribute;\n        } else {\n            return dripAmount;\n        }\n    }\n\n    /// @notice Computes the time since distribution has started for the staking contract\n    /// @param stakingParams Parameters of the concerned staking contract\n    /// @return The time since distribution has started for the staking contract\n    function _timeSinceStart(StakingParameters memory stakingParams) internal view returns (uint256) {\n        uint256 _duration = stakingParams.duration;\n        // `block.timestamp` is always greater than `timeStarted`\n        uint256 timePassed = block.timestamp - stakingParams.timeStarted;\n        return timePassed > _duration ? _duration : timePassed;\n    }\n\n    /// @notice Incentivizes the person calling the drip function\n    /// @param stakingParams Parameters of the concerned staking contract\n    function _incentivize(StakingParameters memory stakingParams) internal {\n        rewardToken.safeTransfer(msg.sender, stakingParams.incentiveAmount);\n    }\n}\n"
    },
    "contracts/staking/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./StakingRewardsEvents.sol\";\n\n/// @title StakingRewards\n/// @author Forked form SetProtocol\n/// https://github.com/SetProtocol/index-coop-contracts/blob/master/contracts/staking/StakingRewards.sol\n/// @notice The `StakingRewards` contracts allows to stake an ERC20 token to receive as reward another ERC20\n/// @dev This contracts is managed by the reward distributor and implements the staking interface\ncontract StakingRewards is StakingRewardsEvents, IStakingRewards, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Checks to see if it is the `rewardsDistribution` calling this contract\n    /// @dev There is no Access Control here, because it can be handled cheaply through these modifiers\n    modifier onlyRewardsDistribution() {\n        require(msg.sender == rewardsDistribution, \"1\");\n        _;\n    }\n\n    // ============================ References to contracts ========================\n\n    /// @notice ERC20 token given as reward\n    IERC20 public immutable override rewardToken;\n\n    /// @notice ERC20 token used for staking\n    IERC20 public immutable stakingToken;\n\n    /// @notice Base of the staked token, it is going to be used in the case of sanTokens\n    /// which are not in base 10**18\n    uint256 public immutable stakingBase;\n\n    /// @notice Rewards Distribution contract for this staking contract\n    address public rewardsDistribution;\n\n    // ============================ Staking parameters =============================\n\n    /// @notice Time at which distribution ends\n    uint256 public periodFinish;\n\n    /// @notice Reward per second given to the staking contract, split among the staked tokens\n    uint256 public rewardRate;\n\n    /// @notice Duration of the reward distribution\n    uint256 public rewardsDuration;\n\n    /// @notice Last time `rewardPerTokenStored` was updated\n    uint256 public lastUpdateTime;\n\n    /// @notice Helps to compute the amount earned by someone\n    /// Cumulates rewards accumulated for one token since the beginning.\n    /// Stored as a uint so it is actually a float times the base of the reward token\n    uint256 public rewardPerTokenStored;\n\n    /// @notice Stores for each account the `rewardPerToken`: we do the difference\n    /// between the current and the old value to compute what has been earned by an account\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice Stores for each account the accumulated rewards\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    // ============================ Constructor ====================================\n\n    /// @notice Initializes the staking contract with a first set of parameters\n    /// @param _rewardsDistribution Address owning the rewards token\n    /// @param _rewardToken ERC20 token given as reward\n    /// @param _stakingToken ERC20 token used for staking\n    /// @param _rewardsDuration Duration of the staking contract\n    constructor(\n        address _rewardsDistribution,\n        address _rewardToken,\n        address _stakingToken,\n        uint256 _rewardsDuration\n    ) {\n        require(_stakingToken != address(0) && _rewardToken != address(0) && _rewardsDistribution != address(0), \"0\");\n\n        // We are not checking the compatibility of the reward token between the distributor and this contract here\n        // because it is checked by the `RewardsDistributor` when activating the staking contract\n        // Parameters\n        rewardToken = IERC20(_rewardToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDuration = _rewardsDuration;\n        rewardsDistribution = _rewardsDistribution;\n\n        stakingBase = 10**IERC20Metadata(_stakingToken).decimals();\n    }\n\n    // ============================ Modifiers ======================================\n\n    /// @notice Checks to see if the calling address is the zero address\n    /// @param account Address to check\n    modifier zeroCheck(address account) {\n        require(account != address(0), \"0\");\n        _;\n    }\n\n    /// @notice Called frequently to update the staking parameters associated to an address\n    /// @param account Address of the account to update\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // ============================ View functions =================================\n\n    /// @notice Accesses the total supply\n    /// @dev Used instead of having a public variable to respect the ERC20 standard\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Accesses the number of token staked by an account\n    /// @param account Account to query the balance of\n    /// @dev Used instead of having a public variable to respect the ERC20 standard\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @notice Queries the last timestamp at which a reward was distributed\n    /// @dev Returns the current timestamp if a reward is being distributed and the end of the staking\n    /// period if staking is done\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    /// @notice Used to actualize the `rewardPerTokenStored`\n    /// @dev It adds to the reward per token: the time elapsed since the `rewardPerTokenStored` was\n    /// last updated multiplied by the `rewardRate` divided by the number of tokens\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * stakingBase) / _totalSupply);\n    }\n\n    /// @notice Returns how much a given account earned rewards\n    /// @param account Address for which the request is made\n    /// @return How much a given account earned rewards\n    /// @dev It adds to the rewards the amount of reward earned since last time that is the difference\n    /// in reward per token from now and last time multiplied by the number of tokens staked by the person\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            stakingBase +\n            rewards[account];\n    }\n\n    // ======================== Mutative functions forked ==========================\n\n    /// @notice Lets someone stake a given amount of `stakingTokens`\n    /// @param amount Amount of ERC20 staking token that the `msg.sender` wants to stake\n    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        _stake(amount, msg.sender);\n    }\n\n    /// @notice Lets a user withdraw a given amount of collateral from the staking contract\n    /// @param amount Amount of the ERC20 staking token that the `msg.sender` wants to withdraw\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"89\");\n        _totalSupply = _totalSupply - amount;\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /// @notice Triggers a payment of the reward earned to the msg.sender\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /// @notice Exits someone\n    /// @dev This function lets the caller withdraw its staking and claim rewards\n    // Attention here, there may be reentrancy attacks because of the following call\n    // to an external contract done before other things are modified, yet since the `rewardToken`\n    // is mostly going to be a trusted contract controlled by governance (namely the ANGLE token),\n    // this is not an issue. If the `rewardToken` changes to an untrusted contract, this need to be updated.\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    // ====================== Functions added by Angle Core Team ===================\n\n    /// @notice Allows to stake on behalf of another address\n    /// @param amount Amount to stake\n    /// @param onBehalf Address to stake onBehalf of\n    function stakeOnBehalf(uint256 amount, address onBehalf)\n        external\n        nonReentrant\n        zeroCheck(onBehalf)\n        updateReward(onBehalf)\n    {\n        _stake(amount, onBehalf);\n    }\n\n    /// @notice Internal function to stake called by `stake` and `stakeOnBehalf`\n    /// @param amount Amount to stake\n    /// @param onBehalf Address to stake on behalf of\n    /// @dev Before calling this function, it has already been verified whether this address was a zero address or not\n    function _stake(uint256 amount, address onBehalf) internal {\n        require(amount > 0, \"90\");\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        _totalSupply = _totalSupply + amount;\n        _balances[onBehalf] = _balances[onBehalf] + amount;\n        emit Staked(onBehalf, amount);\n    }\n\n    // ====================== Restricted Functions =================================\n\n    /// @notice Adds rewards to be distributed\n    /// @param reward Amount of reward tokens to distribute\n    /// @dev This reward will be distributed during `rewardsDuration` set previously\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        nonReentrant\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            // If no reward is currently being distributed, the new rate is just `reward / duration`\n            rewardRate = reward / rewardsDuration;\n        } else {\n            // Otherwise, cancel the future reward and add the amount left to distribute to reward\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensures the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of `rewardRate` in the earned and `rewardsPerToken` functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= balance / rewardsDuration, \"91\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration; // Change the duration\n        emit RewardAdded(reward);\n    }\n\n    /// @notice Withdraws ERC20 tokens that could accrue on this contract\n    /// @param tokenAddress Address of the ERC20 token to withdraw\n    /// @param to Address to transfer to\n    /// @param amount Amount to transfer\n    /// @dev A use case would be to claim tokens if the staked tokens accumulate rewards\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external override onlyRewardsDistribution {\n        require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardToken), \"20\");\n\n        IERC20(tokenAddress).safeTransfer(to, amount);\n        emit Recovered(tokenAddress, to, amount);\n    }\n\n    /// @notice Changes the rewards distributor associated to this contract\n    /// @param _rewardsDistribution Address of the new rewards distributor contract\n    /// @dev This function was also added by Angle Core Team\n    /// @dev A compatibility check of the reward token is already performed in the current `RewardsDistributor` implementation\n    /// which has right to call this function\n    function setNewRewardsDistribution(address _rewardsDistribution) external override onlyRewardsDistribution {\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(_rewardsDistribution);\n    }\n}\n"
    },
    "contracts/mock/MockERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721ReceiverUpgradeable {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract ERC721HolderWrongReason is IERC721ReceiverUpgradeable {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(false, \"incorrect holder\");\n    }\n}\n"
    },
    "contracts/perpetualManager/PerpetualManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PerpetualManagerEvents.sol\";\n\nstruct Perpetual {\n    // Oracle value at the moment of perpetual opening\n    uint256 entryRate;\n    // Timestamp at which the perpetual was opened\n    uint256 entryTimestamp;\n    // Amount initially brought in the perpetual (net from fees) + amount added - amount removed from it\n    // This is the only element that can be modified in the perpetual after its creation\n    uint256 margin;\n    // Amount of collateral covered by the perpetual. This cannot be modified once the perpetual is opened.\n    // The amount covered is used interchangeably with the amount hedged\n    uint256 committedAmount;\n}\n\n/// @title PerpetualManagerStorage\n/// @author Angle Core Team\n/// @notice `PerpetualManager` is the contract handling all the Hedging Agents positions and perpetuals\n/// @dev There is one `PerpetualManager` contract per pair stablecoin/collateral in the protocol\n/// @dev This file contains all the parameters and references used in the `PerpetualManager` contract\n// solhint-disable-next-line max-states-count\ncontract PerpetualManagerStorage is PerpetualManagerEvents, FunctionUtils {\n    // Base used in the collateral implementation (ERC20 decimal)\n    uint256 internal _collatBase;\n\n    // ============================== Perpetual Variables ==========================\n\n    /// @notice Total amount of stablecoins that are insured (i.e. that could be redeemed against\n    /// collateral thanks to HAs)\n    /// When a HA opens a perpetual, it covers/hedges a fixed amount of stablecoins for the protocol, equal to\n    /// the committed amount times the entry rate\n    /// `totalHedgeAmount` is the sum of all these hedged amounts\n    uint256 public totalHedgeAmount;\n\n    // Counter to generate a unique `perpetualID` for each perpetual\n    CountersUpgradeable.Counter internal _perpetualIDcount;\n\n    // ========================== Mutable References ============================\n\n    /// @notice `Oracle` to give the rate feed, that is the price of the collateral\n    /// with respect to the price of the stablecoin\n    /// This reference can be modified by the corresponding `StableMaster` contract\n    IOracle public oracle;\n\n    // `FeeManager` address allowed to update the way fees are computed for this contract\n    // This reference can be modified by the `PoolManager` contract\n    IFeeManager internal _feeManager;\n\n    // ========================== Immutable References ==========================\n\n    /// @notice Interface for the `rewardToken` distributed as a reward\n    /// As of Angle V1, only a single `rewardToken` can be distributed to HAs who own a perpetual\n    /// This implementation assumes that reward tokens have a base of 18 decimals\n    IERC20 public rewardToken;\n\n    /// @notice Address of the `PoolManager` instance\n    IPoolManager public poolManager;\n\n    // Address of the `StableMaster` instance\n    IStableMaster internal _stableMaster;\n\n    // Interface for the underlying token accepted by this contract\n    // This reference cannot be changed, it is taken from the `PoolManager`\n    IERC20 internal _token;\n\n    // ======================= Fees and other Parameters ===========================\n\n    /// Deposit fees for HAs depend on the hedge ratio that is the ratio between what is hedged\n    /// (or covered, this is a synonym) by HAs compared with the total amount to hedge\n    /// @notice Thresholds for the ratio between to amount hedged and the amount to hedge\n    /// The bigger the ratio the bigger the fees will be because this means that the max amount\n    /// to insure is soon to be reached\n    uint64[] public xHAFeesDeposit;\n\n    /// @notice Deposit fees at threshold values\n    /// This array should have the same length as the array above\n    /// The evolution of the fees between two threshold values is linear\n    uint64[] public yHAFeesDeposit;\n\n    /// Withdraw fees for HAs also depend on the hedge ratio\n    /// @notice Thresholds for the hedge ratio\n    uint64[] public xHAFeesWithdraw;\n\n    /// @notice Withdraw fees at threshold values\n    uint64[] public yHAFeesWithdraw;\n\n    /// @notice Maintenance Margin (in `BASE_PARAMS`) for each perpetual\n    /// The margin ratio is defined for a perpetual as: `(initMargin + PnL) / committedAmount` where\n    /// `PnL = committedAmount * (1 - initRate/currentRate)`\n    /// If the `marginRatio` is below `maintenanceMargin`: then the perpetual can be liquidated\n    uint64 public maintenanceMargin;\n\n    /// @notice Maximum leverage multiplier authorized for HAs (`in BASE_PARAMS`)\n    /// Leverage for a perpetual here corresponds to the ratio between the amount committed\n    /// and the margin of the perpetual\n    uint64 public maxLeverage;\n\n    /// @notice Target proportion of stablecoins issued using this collateral to insure with HAs.\n    /// This variable is exactly the same as the one in the `StableMaster` contract for this collateral.\n    /// Above this hedge ratio, HAs cannot open new perpetuals\n    /// When keepers are forcing the closing of some perpetuals, they are incentivized to bringing\n    /// the hedge ratio to this proportion\n    uint64 public targetHAHedge;\n\n    /// @notice Limit proportion of stablecoins issued using this collateral that HAs can insure\n    /// Above this ratio `forceCashOut` is activated and anyone can see its perpetual cashed out\n    uint64 public limitHAHedge;\n\n    /// @notice Extra parameter from the `FeeManager` contract that is multiplied to the fees from above and that\n    /// can be used to change deposit fees. It works as a bonus - malus fee, if `haBonusMalusDeposit > BASE_PARAMS`,\n    /// then the fee will be larger than `haFeesDeposit`, if `haBonusMalusDeposit < BASE_PARAMS`, fees will be smaller.\n    /// This parameter, updated by keepers in the `FeeManager` contract, could most likely depend on the collateral ratio\n    uint64 public haBonusMalusDeposit;\n\n    /// @notice Extra parameter from the `FeeManager` contract that is multiplied to the fees from above and that\n    /// can be used to change withdraw fees. It works as a bonus - malus fee, if `haBonusMalusWithdraw > BASE_PARAMS`,\n    /// then the fee will be larger than `haFeesWithdraw`, if `haBonusMalusWithdraw < BASE_PARAMS`, fees will be smaller\n    uint64 public haBonusMalusWithdraw;\n\n    /// @notice Amount of time before HAs are allowed to withdraw funds from their perpetuals\n    /// either using `removeFromPerpetual` or `closePerpetual`. New perpetuals cannot be forced closed in\n    /// situations where the `forceClosePerpetuals` function is activated before this `lockTime` elapsed\n    uint64 public lockTime;\n\n    // ================================= Keeper fees ======================================\n    // All these parameters can be modified by their corresponding governance function\n\n    /// @notice Portion of the leftover cash out amount of liquidated perpetuals that go to\n    /// liquidating keepers\n    uint64 public keeperFeesLiquidationRatio;\n\n    /// @notice Cap on the fees that go to keepers liquidating a perpetual\n    /// If a keeper liquidates n perpetuals in a single transaction, then this keeper is entitled to get as much as\n    /// `n * keeperFeesLiquidationCap` as a reward\n    uint256 public keeperFeesLiquidationCap;\n\n    /// @notice Cap on the fees that go to keepers closing perpetuals when too much collateral is hedged by HAs\n    /// (hedge ratio above `limitHAHedge`)\n    /// If a keeper forces the closing of n perpetuals in a single transaction, then this keeper is entitled to get\n    /// as much as `keeperFeesClosingCap`. This cap amount is independent of the number of perpetuals closed\n    uint256 public keeperFeesClosingCap;\n\n    /// @notice Thresholds on the values of the rate between the current hedged amount (`totalHedgeAmount`) and the\n    /// target hedged amount by HAs (`targetHedgeAmount`) divided by 2. A value of `0.5` corresponds to a hedge ratio\n    /// of `1`. Doing this allows to maintain an array with values of `x` inferior to `BASE_PARAMS`.\n    uint64[] public xKeeperFeesClosing;\n\n    /// @notice Values at thresholds of the proportions of the fees that should go to keepers closing perpetuals\n    uint64[] public yKeeperFeesClosing;\n\n    // =========================== Staking Parameters ==============================\n\n    /// @notice Below are parameters that can also be found in other staking contracts\n    /// to be able to compute rewards from staking (having perpetuals here) correctly\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    address public rewardsDistribution;\n\n    // ============================== ERC721 Base URI ==============================\n\n    /// @notice URI used for the metadata of the perpetuals\n    string public baseURI;\n\n    // =============================== Mappings ====================================\n\n    /// @notice Mapping from `perpetualID` to perpetual data\n    mapping(uint256 => Perpetual) public perpetualData;\n\n    /// @notice Mapping used to compute the rewards earned by a perpetual in a timeframe\n    mapping(uint256 => uint256) public perpetualRewardPerTokenPaid;\n\n    /// @notice Mapping used to get how much rewards in governance tokens are gained by a perpetual\n    // identified by its ID\n    mapping(uint256 => uint256) public rewards;\n\n    // Mapping from `perpetualID` to owner address\n    mapping(uint256 => address) internal _owners;\n\n    // Mapping from owner address to perpetual owned count\n    mapping(address => uint256) internal _balances;\n\n    // Mapping from `perpetualID` to approved address\n    mapping(uint256 => address) internal _perpetualApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n}\n"
    },
    "contracts/perpetualManager/PerpetualManagerInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PerpetualManagerStorage.sol\";\n\n/// @title PerpetualManagerInternal\n/// @author Angle Core Team\n/// @notice `PerpetualManager` is the contract handling all the Hedging Agents perpetuals\n/// @dev There is one `PerpetualManager` contract per pair stablecoin/collateral in the protocol\n/// @dev This file contains all the internal functions of the `PerpetualManager` contract\ncontract PerpetualManagerInternal is PerpetualManagerStorage {\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    // ======================== State Modifying Functions ==========================\n\n    /// @notice Cashes out a perpetual, which means that it simply deletes the references to the perpetual\n    /// in the contract\n    /// @param perpetualID ID of the perpetual\n    /// @param perpetual Data of the perpetual\n    function _closePerpetual(uint256 perpetualID, Perpetual memory perpetual) internal {\n        // Handling the staking logic\n        // Reward should always be updated before the `totalHedgeAmount`\n        // Rewards are distributed to the perpetual which is liquidated\n        uint256 hedge = perpetual.committedAmount * perpetual.entryRate;\n        _getReward(perpetualID, hedge);\n        delete perpetualRewardPerTokenPaid[perpetualID];\n\n        // Updating `totalHedgeAmount` to represent the fact that less money is insured\n        totalHedgeAmount -= hedge / _collatBase;\n\n        _burn(perpetualID);\n    }\n\n    /// @notice Allows the protocol to transfer collateral to an address while handling the case where there are\n    /// not enough reserves\n    /// @param owner Address of the receiver\n    /// @param amount The amount of collateral sent\n    /// @dev If there is not enough collateral in balance (this can happen when money has been lent to strategies),\n    /// then the owner is reimbursed by receiving what is missing in sanTokens at the correct value\n    function _secureTransfer(address owner, uint256 amount) internal {\n        uint256 curBalance = poolManager.getBalance();\n        if (curBalance >= amount && amount > 0) {\n            // Case where there is enough in reserves to reimburse the person\n            _token.safeTransferFrom(address(poolManager), owner, amount);\n        } else if (amount > 0) {\n            // When there is not enough to reimburse the entire amount, the protocol reimburses\n            // what it can using its reserves and the rest is paid in sanTokens at the current\n            // exchange rate\n            uint256 amountLeft = amount - curBalance;\n            _token.safeTransferFrom(address(poolManager), owner, curBalance);\n            _stableMaster.convertToSLP(amountLeft, owner);\n        }\n    }\n\n    /// @notice Checks whether the perpetual should be liquidated or not, and if so liquidates the perpetual\n    /// @param perpetualID ID of the perpetual to check and potentially liquidate\n    /// @param perpetual Data of the perpetual to check\n    /// @param rateDown Oracle value to compute the cash out amount of the perpetual\n    /// @return Cash out amount of the perpetual\n    /// @return Whether the perpetual was liquidated or not\n    /// @dev Generally, to check for the liquidation of a perpetual, we use the lowest oracle value possible:\n    /// it's the one that is most at the advantage of the protocol, hence the `rateDown` parameter\n    function _checkLiquidation(\n        uint256 perpetualID,\n        Perpetual memory perpetual,\n        uint256 rateDown\n    ) internal returns (uint256, uint256) {\n        uint256 liquidated;\n        (uint256 cashOutAmount, uint256 reachMaintenanceMargin) = _getCashOutAmount(perpetual, rateDown);\n        if (cashOutAmount == 0 || reachMaintenanceMargin == 1) {\n            _closePerpetual(perpetualID, perpetual);\n            // No need for an event to find out that a perpetual is liquidated\n            liquidated = 1;\n        }\n        return (cashOutAmount, liquidated);\n    }\n\n    // ========================= Internal View Functions ===========================\n\n    /// @notice Gets the current cash out amount of a perpetual\n    /// @param perpetual Data of the concerned perpetual\n    /// @param rate Value of the oracle\n    /// @return cashOutAmount Amount that the HA could get by closing this perpetual\n    /// @return reachMaintenanceMargin Whether the position of the perpetual is now too small\n    /// compared with its initial position\n    /// @dev Refer to the whitepaper or the doc for the formulas of the cash out amount\n    /// @dev The notion of `maintenanceMargin` is standard in centralized platforms offering perpetual futures\n    function _getCashOutAmount(Perpetual memory perpetual, uint256 rate)\n        internal\n        view\n        returns (uint256 cashOutAmount, uint256 reachMaintenanceMargin)\n    {\n        // All these computations are made just because we are working with uint and not int\n        // so we cannot do x-y if x<y\n        uint256 newCommit = (perpetual.committedAmount * perpetual.entryRate) / rate;\n        // Checking if a liquidation is needed: for this to happen the `cashOutAmount` should be inferior\n        // to the maintenance margin of the perpetual\n        reachMaintenanceMargin;\n        if (newCommit >= perpetual.committedAmount + perpetual.margin) cashOutAmount = 0;\n        else {\n            // The definition of the margin ratio is `(margin + PnL) / committedAmount`\n            // where `PnL = commit * (1-entryRate/currentRate)`\n            // So here: `newCashOutAmount = margin + PnL`\n            cashOutAmount = perpetual.committedAmount + perpetual.margin - newCommit;\n            if (cashOutAmount * BASE_PARAMS <= perpetual.committedAmount * maintenanceMargin)\n                reachMaintenanceMargin = 1;\n        }\n    }\n\n    /// @notice Calls the oracle to read both Chainlink and Uniswap rates\n    /// @return The lowest oracle value (between Chainlink and Uniswap) is the first outputted value\n    /// @return The highest oracle value is the second output\n    /// @dev If the oracle only involves a single oracle fees (like just Chainlink for USD-EUR),\n    /// the same value is returned twice\n    function _getOraclePrice() internal view returns (uint256, uint256) {\n        return oracle.readAll();\n    }\n\n    /// @notice Computes the incentive for the keeper as a function of the cash out amount of a liquidated perpetual\n    /// which value falls below its maintenance margin\n    /// @param cashOutAmount Value remaining in the perpetual\n    /// @dev By computing keeper fees as a fraction of the cash out amount of a perpetual rather than as a fraction\n    /// of the `committedAmount`, keepers are incentivized to react fast when a perpetual is below the maintenance margin\n    /// @dev Perpetual exchange protocols typically compute liquidation fees using an equivalent of the `committedAmount`,\n    /// this is not the case here\n    function _computeKeeperLiquidationFees(uint256 cashOutAmount) internal view returns (uint256 keeperFees) {\n        keeperFees = (cashOutAmount * keeperFeesLiquidationRatio) / BASE_PARAMS;\n        keeperFees = keeperFees < keeperFeesLiquidationCap ? keeperFees : keeperFeesLiquidationCap;\n    }\n\n    /// @notice Gets the value of the hedge ratio that is the ratio between the amount currently hedged by HAs\n    /// and the target amount that should be hedged by them\n    /// @param currentHedgeAmount Amount currently covered by HAs\n    /// @return ratio Ratio between the amount of collateral (in stablecoin value) currently hedged\n    /// and the target amount to hedge\n    function _computeHedgeRatio(uint256 currentHedgeAmount) internal view returns (uint64 ratio) {\n        // Fetching info from the `StableMaster`: the amount to hedge is based on the `stocksUsers`\n        // of the given collateral\n        uint256 targetHedgeAmount = (_stableMaster.getStocksUsers() * targetHAHedge) / BASE_PARAMS;\n        if (currentHedgeAmount < targetHedgeAmount)\n            ratio = uint64((currentHedgeAmount * BASE_PARAMS) / targetHedgeAmount);\n        else ratio = uint64(BASE_PARAMS);\n    }\n\n    // =========================== Fee Computation =================================\n\n    /// @notice Gets the net margin corrected from the fees at perpetual opening\n    /// @param margin Amount brought in the perpetual at creation\n    /// @param totalHedgeAmountUpdate Amount of stablecoins that this perpetual is going to insure\n    /// @param committedAmount Committed amount in the perpetual, we need it to compute the fees\n    /// paid by the HA\n    /// @return netMargin Amount that will be written in the perpetual as the `margin`\n    /// @dev The amount of stablecoins insured by a perpetual is `committedAmount * oracleRate / _collatBase`\n    function _getNetMargin(\n        uint256 margin,\n        uint256 totalHedgeAmountUpdate,\n        uint256 committedAmount\n    ) internal view returns (uint256 netMargin) {\n        // Checking if the HA has the right to open a perpetual with such amount\n        // If HAs hedge more than the target amount, then new HAs will not be able to create perpetuals\n        // The amount hedged by HAs after opening the perpetual is going to be:\n        uint64 ratio = _computeHedgeRatio(totalHedgeAmount + totalHedgeAmountUpdate);\n        require(ratio < uint64(BASE_PARAMS), \"25\");\n        // Computing the net margin of HAs to store in the perpetual: it consists simply in deducing fees\n        // Those depend on how much is already hedged by HAs compared with what's to hedge\n        uint256 haFeesDeposit = (haBonusMalusDeposit * _piecewiseLinear(ratio, xHAFeesDeposit, yHAFeesDeposit)) /\n            BASE_PARAMS;\n        // Fees are rounded to the advantage of the protocol\n        haFeesDeposit = committedAmount - (committedAmount * (BASE_PARAMS - haFeesDeposit)) / BASE_PARAMS;\n        // Fees are computed based on the committed amount of the perpetual\n        // The following reverts if fees are too big compared to the margin\n        netMargin = margin - haFeesDeposit;\n    }\n\n    /// @notice Gets the net amount to give to a HA (corrected from the fees) in case of a perpetual closing\n    /// @param committedAmount Committed amount in the perpetual\n    /// @param cashOutAmount The current cash out amount of the perpetual\n    /// @param ratio What's hedged divided by what's to hedge\n    /// @return netCashOutAmount Amount that will be distributed to the HA\n    /// @return feesPaid Amount of fees paid by the HA at perpetual closing\n    /// @dev This function is called by the `closePerpetual` and by the `forceClosePerpetuals`\n    /// function\n    /// @dev The amount of fees paid by the HA is used to compute the incentive given to HAs closing perpetuals\n    /// when too much is covered\n    function _getNetCashOutAmount(\n        uint256 cashOutAmount,\n        uint256 committedAmount,\n        uint64 ratio\n    ) internal view returns (uint256 netCashOutAmount, uint256 feesPaid) {\n        feesPaid = (haBonusMalusWithdraw * _piecewiseLinear(ratio, xHAFeesWithdraw, yHAFeesWithdraw)) / BASE_PARAMS;\n        // Rounding the fees at the protocol's advantage\n        feesPaid = committedAmount - (committedAmount * (BASE_PARAMS - feesPaid)) / BASE_PARAMS;\n        if (feesPaid >= cashOutAmount) {\n            netCashOutAmount = 0;\n            feesPaid = cashOutAmount;\n        } else {\n            netCashOutAmount = cashOutAmount - feesPaid;\n        }\n    }\n\n    // ========================= Reward Distribution ===============================\n\n    /// @notice View function to query the last timestamp at which a reward was distributed\n    /// @return Current timestamp if a reward is being distributed or the last timestamp\n    function _lastTimeRewardApplicable() internal view returns (uint256) {\n        uint256 returnValue = block.timestamp < periodFinish ? block.timestamp : periodFinish;\n        return returnValue;\n    }\n\n    /// @notice Used to actualize the `rewardPerTokenStored`\n    /// @dev It adds to the reward per token: the time elapsed since the `rewardPerTokenStored`\n    /// was last updated multiplied by the `rewardRate` divided by the number of tokens\n    /// @dev Specific attention should be placed on the base here: `rewardRate` is in the base of the reward token\n    /// and `totalHedgeAmount` is in `BASE_TOKENS` here: as this function concerns an amount of reward\n    /// tokens, the output of this function should be in the base of the reward token too\n    function _rewardPerToken() internal view returns (uint256) {\n        if (totalHedgeAmount == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            ((_lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * BASE_TOKENS) /\n            totalHedgeAmount;\n    }\n\n    /// @notice Allows a perpetual owner to withdraw rewards\n    /// @param perpetualID ID of the perpetual which accumulated tokens\n    /// @param hedge Perpetual commit amount times the entry rate\n    /// @dev Internal version of the `getReward` function\n    /// @dev In case where an approved address calls to close a perpetual, rewards are still going to get distributed\n    /// to the owner of the perpetual, and not necessarily to the address getting the proceeds of the perpetual\n    function _getReward(uint256 perpetualID, uint256 hedge) internal {\n        _updateReward(perpetualID, hedge);\n        uint256 reward = rewards[perpetualID];\n        if (reward > 0) {\n            rewards[perpetualID] = 0;\n            address owner = _owners[perpetualID];\n            // Attention here, there may be reentrancy attacks because of the following call\n            // to an external contract done before other things are modified. Yet since the `rewardToken`\n            // is mostly going to be a trusted contract controlled by governance (namely the ANGLE token), then\n            // there is no point in putting an expensive `nonReentrant` modifier in the functions in `PerpetualManagerFront`\n            // that allow indirect interactions with `_updateReward`. If new `rewardTokens` are set, we could think about\n            // upgrading the `PerpetualManagerFront` contract\n            rewardToken.safeTransfer(owner, reward);\n            emit RewardPaid(owner, reward);\n        }\n    }\n\n    /// @notice Allows to check the amount of gov tokens earned by a perpetual\n    /// @param perpetualID ID of the perpetual which accumulated tokens\n    /// @param hedge Perpetual commit amount times the entry rate\n    /// @return Amount of gov tokens earned by the perpetual\n    /// @dev A specific attention should be paid to have the base here: we consider that each HA stakes an amount\n    /// equal to `committedAmount * entryRate / _collatBase`, here as the `hedge` corresponds to `committedAmount * entryRate`,\n    /// we just need to divide by `_collatBase`\n    /// @dev HAs earn reward tokens which are in base `BASE_TOKENS`\n    function _earned(uint256 perpetualID, uint256 hedge) internal view returns (uint256) {\n        return\n            (hedge * (_rewardPerToken() - perpetualRewardPerTokenPaid[perpetualID])) /\n            BASE_TOKENS /\n            _collatBase +\n            rewards[perpetualID];\n    }\n\n    /// @notice Updates the amount of gov tokens earned by a perpetual\n    /// @param perpetualID of the perpetual which earns tokens\n    /// @param hedge Perpetual commit amount times the entry rate\n    /// @dev When this function is called in the code, it has already been checked that the `perpetualID`\n    /// exists\n    function _updateReward(uint256 perpetualID, uint256 hedge) internal {\n        rewardPerTokenStored = _rewardPerToken();\n        lastUpdateTime = _lastTimeRewardApplicable();\n        // No need to check if the `perpetualID` exists here, it has already been checked\n        // in the code before when this internal function is called\n        rewards[perpetualID] = _earned(perpetualID, hedge);\n        perpetualRewardPerTokenPaid[perpetualID] = rewardPerTokenStored;\n    }\n\n    // =============================== ERC721 Logic ================================\n\n    /// @notice Gets the owner of a perpetual\n    /// @param perpetualID ID of the concerned perpetual\n    /// @return owner Owner of the perpetual\n    function _ownerOf(uint256 perpetualID) internal view returns (address owner) {\n        owner = _owners[perpetualID];\n        require(owner != address(0), \"2\");\n    }\n\n    /// @notice Gets the addresses approved for a perpetual\n    /// @param perpetualID ID of the concerned perpetual\n    /// @return Address approved for this perpetual\n    function _getApproved(uint256 perpetualID) internal view returns (address) {\n        return _perpetualApprovals[perpetualID];\n    }\n\n    /// @notice Safely transfers `perpetualID` token from `from` to `to`, checking first that contract recipients\n    /// are aware of the ERC721 protocol to prevent tokens from being forever locked\n    /// @param perpetualID ID of the concerned perpetual\n    /// @param _data Additional data, it has no specified format and it is sent in call to `to`\n    /// @dev This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n    /// implement alternative mechanisms to perform token transfer, such as signature-based\n    /// @dev Requirements:\n    ///     - `from` cannot be the zero address.\n    ///     - `to` cannot be the zero address.\n    ///     - `perpetualID` token must exist and be owned by `from`.\n    ///     - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 perpetualID,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, perpetualID);\n        require(_checkOnERC721Received(from, to, perpetualID, _data), \"24\");\n    }\n\n    /// @notice Returns whether `perpetualID` exists\n    /// @dev Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}\n    /// @dev Tokens start existing when they are minted (`_mint`),\n    /// and stop existing when they are burned (`_burn`)\n    function _exists(uint256 perpetualID) internal view returns (bool) {\n        return _owners[perpetualID] != address(0);\n    }\n\n    /// @notice Returns whether `spender` is allowed to manage `perpetualID`\n    /// @dev `perpetualID` must exist\n    function _isApprovedOrOwner(address spender, uint256 perpetualID) internal view returns (bool) {\n        // The following checks if the perpetual exists\n        address owner = _ownerOf(perpetualID);\n        return (spender == owner || _getApproved(perpetualID) == spender || _operatorApprovals[owner][spender]);\n    }\n\n    /// @notice Mints `perpetualID` and transfers it to `to`\n    /// @dev This method is equivalent to the `_safeMint` method used in OpenZeppelin ERC721 contract\n    /// @dev `perpetualID` must not exist and `to` cannot be the zero address\n    /// @dev Before calling this function it is checked that the `perpetualID` does not exist as it\n    /// comes from a counter that has been incremented\n    /// @dev Emits a {Transfer} event\n    function _mint(address to, uint256 perpetualID) internal {\n        _balances[to] += 1;\n        _owners[perpetualID] = to;\n        emit Transfer(address(0), to, perpetualID);\n        require(_checkOnERC721Received(address(0), to, perpetualID, \"\"), \"24\");\n    }\n\n    /// @notice Destroys `perpetualID`\n    /// @dev `perpetualID` must exist\n    /// @dev Emits a {Transfer} event\n    function _burn(uint256 perpetualID) internal {\n        address owner = _ownerOf(perpetualID);\n\n        // Clear approvals\n        _approve(address(0), perpetualID);\n\n        _balances[owner] -= 1;\n        delete _owners[perpetualID];\n        delete perpetualData[perpetualID];\n\n        emit Transfer(owner, address(0), perpetualID);\n    }\n\n    /// @notice Transfers `perpetualID` from `from` to `to` as opposed to {transferFrom},\n    /// this imposes no restrictions on msg.sender\n    /// @dev `to` cannot be the zero address and `perpetualID` must be owned by `from`\n    /// @dev Emits a {Transfer} event\n    function _transfer(\n        address from,\n        address to,\n        uint256 perpetualID\n    ) internal {\n        require(_ownerOf(perpetualID) == from, \"1\");\n        require(to != address(0), \"26\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), perpetualID);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[perpetualID] = to;\n\n        emit Transfer(from, to, perpetualID);\n    }\n\n    /// @notice Approves `to` to operate on `perpetualID`\n    function _approve(address to, uint256 perpetualID) internal {\n        _perpetualApprovals[perpetualID] = to;\n        emit Approval(_ownerOf(perpetualID), to, perpetualID);\n    }\n\n    /// @notice Internal function to invoke {IERC721Receiver-onERC721Received} on a target address\n    /// The call is not executed if the target address is not a contract\n    /// @param from Address representing the previous owner of the given token ID\n    /// @param to Target address that will receive the tokens\n    /// @param perpetualID ID of the token to be transferred\n    /// @param _data Bytes optional data to send along with the call\n    /// @return Bool whether the call correctly returned the expected magic value\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 perpetualID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(msg.sender, from, perpetualID, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"24\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/perpetualManager/PerpetualManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PerpetualManagerInternal.sol\";\n\n/// @title PerpetualManager\n/// @author Angle Core Team\n/// @notice `PerpetualManager` is the contract handling all the Hedging Agents positions and perpetuals\n/// @dev There is one `PerpetualManager` contract per pair stablecoin/collateral in the protocol\n/// @dev This file contains the functions of the `PerpetualManager` that can be interacted with\n/// by `StableMaster`, by the `PoolManager`, by the `FeeManager` and by governance\ncontract PerpetualManager is\n    PerpetualManagerInternal,\n    IPerpetualManagerFunctions,\n    IStakingRewardsFunctions,\n    AccessControlUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for guardians, governors and `StableMaster`\n    /// Made for the `StableMaster` to be able to update some parameters\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for `PoolManager` only\n    bytes32 public constant POOLMANAGER_ROLE = keccak256(\"POOLMANAGER_ROLE\");\n\n    // ============================== Modifiers ====================================\n\n    /// @notice Checks if the person interacting with the perpetual with `perpetualID` is approved\n    /// @param caller Address of the person seeking to interact with the perpetual\n    /// @param perpetualID ID of the concerned perpetual\n    /// @dev Generally in `PerpetualManager`, perpetual owners should store the ID of the perpetuals\n    /// they are able to interact with\n    modifier onlyApprovedOrOwner(address caller, uint256 perpetualID) {\n        require(_isApprovedOrOwner(caller, perpetualID), \"21\");\n        _;\n    }\n\n    /// @notice Checks if the message sender is the rewards distribution address\n    modifier onlyRewardsDistribution() {\n        require(msg.sender == rewardsDistribution, \"1\");\n        _;\n    }\n\n    // =============================== Deployer ====================================\n\n    /// @notice Notifies the address of the `_feeManager` and of the `oracle`\n    /// to this contract and grants the correct roles\n    /// @param governorList List of governor addresses of the protocol\n    /// @param guardian Address of the guardian of the protocol\n    /// @param feeManager_ Reference to the `FeeManager` contract which will be able to update fees\n    /// @param oracle_ Reference to the `oracle` contract which will be able to update fees\n    /// @dev Called by the `PoolManager` contract when it is activated by the `StableMaster`\n    /// @dev The `governorList` and `guardian` here are those of the `Core` contract\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IFeeManager feeManager_,\n        IOracle oracle_\n    ) external override onlyRole(POOLMANAGER_ROLE) {\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _grantRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        // In the end guardian should be revoked by governance\n        _grantRole(GUARDIAN_ROLE, guardian);\n        _grantRole(GUARDIAN_ROLE, address(_stableMaster));\n        _feeManager = feeManager_;\n        oracle = oracle_;\n    }\n\n    // ========================== Rewards Distribution =============================\n\n    /// @notice Notifies the contract that rewards are going to be shared among HAs of this pool\n    /// @param reward Amount of governance tokens to be distributed to HAs\n    /// @dev Only the reward distributor contract is allowed to call this function which starts a staking cycle\n    /// @dev This function is the equivalent of the `notifyRewardAmount` function found in all staking contracts\n    function notifyRewardAmount(uint256 reward) external override onlyRewardsDistribution {\n        rewardPerTokenStored = _rewardPerToken();\n\n        if (block.timestamp >= periodFinish) {\n            // If the period is not done, then the reward rate changes\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            // If the period is not over, we compute the reward left and increase reward duration\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n        // Ensuring the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of `rewardRate` in the earned and `rewardsPerToken` functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardToken.balanceOf(address(this));\n\n        require(rewardRate <= balance / rewardsDuration, \"22\");\n\n        lastUpdateTime = block.timestamp;\n        // Change the duration\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    /// @notice Supports recovering LP Rewards from other systems such as BAL to be distributed to holders\n    /// or tokens that were mistakenly\n    /// @param tokenAddress Address of the token to transfer\n    /// @param to Address to give tokens to\n    /// @param tokenAmount Amount of tokens to transfer\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 tokenAmount\n    ) external override onlyRewardsDistribution {\n        require(tokenAddress != address(rewardToken), \"20\");\n        IERC20(tokenAddress).safeTransfer(to, tokenAmount);\n        emit Recovered(tokenAddress, to, tokenAmount);\n    }\n\n    /// @notice Changes the `rewardsDistribution` associated to this contract\n    /// @param _rewardsDistribution Address of the new rewards distributor contract\n    /// @dev This function is part of the staking rewards interface and it is used to propagate\n    /// a change of rewards distributor notified by the current `rewardsDistribution` address\n    /// @dev It has already been checked in the `RewardsDistributor` contract calling\n    /// this function that the `newRewardsDistributor` had a compatible reward token\n    /// @dev With this function, everything is as if `rewardsDistribution` was admin of its own role\n    function setNewRewardsDistribution(address _rewardsDistribution) external override onlyRewardsDistribution {\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(_rewardsDistribution);\n    }\n\n    // ================================= Keepers ===================================\n\n    /// @notice Updates all the fees not depending on individual HA conditions via keeper utils functions\n    /// @param feeDeposit New deposit global fees\n    /// @param feeWithdraw New withdraw global fees\n    /// @dev Governance may decide to incorporate a collateral ratio dependence in the fees for HAs,\n    /// in this case it will be done through the `FeeManager` contract\n    /// @dev This dependence can either be a bonus or a malus\n    function setFeeKeeper(uint64 feeDeposit, uint64 feeWithdraw) external override {\n        require(msg.sender == address(_feeManager), \"1\");\n        haBonusMalusDeposit = feeDeposit;\n        haBonusMalusWithdraw = feeWithdraw;\n    }\n\n    // ======== Governance - Guardian Functions - Staking and Pauses ===============\n\n    /// @notice Pauses the `getReward` method as well as the functions allowing to open, modify or close perpetuals\n    /// @dev After calling this function, it is going to be impossible for HAs to interact with their perpetuals\n    /// or claim their rewards on it\n    function pause() external override onlyRole(GUARDIAN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses HAs functions\n    function unpause() external override onlyRole(GUARDIAN_ROLE) {\n        _unpause();\n    }\n\n    /// @notice Sets the conditions and specifies the duration of the reward distribution\n    /// @param _rewardsDuration Duration for the rewards for this contract\n    /// @param _rewardsDistribution Address which will give the reward tokens\n    /// @dev It allows governance to directly change the rewards distribution contract and the conditions\n    /// at which this distribution is done\n    /// @dev The compatibility of the reward token is not checked here: it is checked\n    /// in the rewards distribution contract when activating this as a staking contract,\n    /// so if a reward distributor is set here but does not have a compatible reward token, then this reward\n    /// distributor will not be able to set this contract as a staking contract\n    function setRewardDistribution(uint256 _rewardsDuration, address _rewardsDistribution)\n        external\n        onlyRole(GUARDIAN_ROLE)\n        zeroCheck(_rewardsDistribution)\n    {\n        rewardsDuration = _rewardsDuration;\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionDurationUpdated(rewardsDuration, rewardsDistribution);\n    }\n\n    // ============ Governance - Guardian Functions - Parameters ===================\n\n    /// @notice Sets `baseURI` that is the URI to access ERC721 metadata\n    /// @param _baseURI New `baseURI` parameter\n    function setBaseURI(string memory _baseURI) external onlyRole(GUARDIAN_ROLE) {\n        baseURI = _baseURI;\n        emit BaseURIUpdated(_baseURI);\n    }\n\n    /// @notice Sets `lockTime` that is the minimum amount of time HAs have to stay within the protocol\n    /// @param _lockTime New `lockTime` parameter\n    /// @dev This parameter is used to prevent HAs from exiting before a certain amount of time and taking advantage\n    /// of insiders' information they may have due to oracle latency\n    function setLockTime(uint64 _lockTime) external override onlyRole(GUARDIAN_ROLE) {\n        lockTime = _lockTime;\n        emit LockTimeUpdated(_lockTime);\n    }\n\n    /// @notice Changes the maximum leverage authorized (commit/margin) and the maintenance margin under which\n    /// perpetuals can be liquidated\n    /// @param _maxLeverage New value of the maximum leverage allowed\n    /// @param _maintenanceMargin The new maintenance margin\n    /// @dev For a perpetual, the leverage is defined as the ratio between the committed amount and the margin\n    /// @dev For a perpetual, the maintenance margin is defined as the ratio between the margin ratio / the committed amount\n    function setBoundsPerpetual(uint64 _maxLeverage, uint64 _maintenanceMargin)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n        onlyCompatibleFees(_maintenanceMargin)\n    {\n        // Checking the compatibility of the parameters\n        require(BASE_PARAMS**2 > _maxLeverage * _maintenanceMargin, \"8\");\n        maxLeverage = _maxLeverage;\n        maintenanceMargin = _maintenanceMargin;\n        emit BoundsPerpetualUpdated(_maxLeverage, _maintenanceMargin);\n    }\n\n    /// @notice Sets `xHAFees` that is the thresholds of values of the ratio between what's covered (hedged)\n    /// divided by what's to hedge with HAs at which fees will change as well as\n    /// `yHAFees` that is the value of the deposit or withdraw fees at threshold\n    /// @param _xHAFees Array of the x-axis value for the fees (deposit or withdraw)\n    /// @param _yHAFees Array of the y-axis value for the fees (deposit or withdraw)\n    /// @param deposit Whether deposit or withdraw fees should be updated\n    /// @dev Evolution of the fees is linear between two values of thresholds\n    /// @dev These x values should be ranked in ascending order\n    /// @dev For deposit fees, the higher the x that is the ratio between what's to hedge and what's hedged\n    /// the higher y should be (the more expensive it should be for HAs to come in)\n    /// @dev For withdraw fees, evolution should follow an opposite logic\n    function setHAFees(\n        uint64[] memory _xHAFees,\n        uint64[] memory _yHAFees,\n        uint8 deposit\n    ) external override onlyRole(GUARDIAN_ROLE) onlyCompatibleInputArrays(_xHAFees, _yHAFees) {\n        if (deposit == 1) {\n            xHAFeesDeposit = _xHAFees;\n            yHAFeesDeposit = _yHAFees;\n        } else {\n            xHAFeesWithdraw = _xHAFees;\n            yHAFeesWithdraw = _yHAFees;\n        }\n        emit HAFeesUpdated(_xHAFees, _yHAFees, deposit);\n    }\n\n    /// @notice Sets the target and limit proportions of collateral from users that can be insured by HAs\n    /// @param _targetHAHedge Proportion of collateral from users that HAs should hedge\n    /// @param _limitHAHedge Proportion of collateral from users above which HAs can see their perpetuals\n    /// cashed out\n    /// @dev `targetHAHedge` equal to `BASE_PARAMS` means that all the collateral from users should be insured by HAs\n    /// @dev `targetHAHedge` equal to 0 means HA should not cover (hedge) anything\n    function setTargetAndLimitHAHedge(uint64 _targetHAHedge, uint64 _limitHAHedge)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n        onlyCompatibleFees(_targetHAHedge)\n        onlyCompatibleFees(_limitHAHedge)\n    {\n        require(_targetHAHedge <= _limitHAHedge, \"8\");\n        limitHAHedge = _limitHAHedge;\n        targetHAHedge = _targetHAHedge;\n        // Updating the value in the `stableMaster` contract\n        _stableMaster.setTargetHAHedge(_targetHAHedge);\n        emit TargetAndLimitHAHedgeUpdated(_targetHAHedge, _limitHAHedge);\n    }\n\n    /// @notice Sets the portion of the leftover cash out amount of liquidated perpetuals that go to keepers\n    /// @param _keeperFeesLiquidationRatio Proportion to keepers\n    /// @dev This proportion should be inferior to `BASE_PARAMS`\n    function setKeeperFeesLiquidationRatio(uint64 _keeperFeesLiquidationRatio)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n        onlyCompatibleFees(_keeperFeesLiquidationRatio)\n    {\n        keeperFeesLiquidationRatio = _keeperFeesLiquidationRatio;\n        emit KeeperFeesLiquidationRatioUpdated(keeperFeesLiquidationRatio);\n    }\n\n    /// @notice Sets the maximum amounts going to the keepers when closing perpetuals\n    /// because too much was hedged by HAs or when liquidating a perpetual\n    /// @param _keeperFeesLiquidationCap Maximum reward going to the keeper liquidating a perpetual\n    /// @param _keeperFeesClosingCap Maximum reward going to the keeper forcing the closing of an ensemble\n    /// of perpetuals\n    function setKeeperFeesCap(uint256 _keeperFeesLiquidationCap, uint256 _keeperFeesClosingCap)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n    {\n        keeperFeesLiquidationCap = _keeperFeesLiquidationCap;\n        keeperFeesClosingCap = _keeperFeesClosingCap;\n        emit KeeperFeesCapUpdated(keeperFeesLiquidationCap, keeperFeesClosingCap);\n    }\n\n    /// @notice Sets the x-array (ie thresholds) for `FeeManager` when closing perpetuals and the y-array that is the\n    /// value of the proportions of the fees going to keepers closing perpetuals\n    /// @param _xKeeperFeesClosing Thresholds for closing fees\n    /// @param _yKeeperFeesClosing Value of the fees at the different threshold values specified in `xKeeperFeesClosing`\n    /// @dev The x thresholds correspond to values of the hedge ratio divided by two\n    /// @dev `xKeeperFeesClosing` and `yKeeperFeesClosing` should have the same length\n    function setKeeperFeesClosing(uint64[] memory _xKeeperFeesClosing, uint64[] memory _yKeeperFeesClosing)\n        external\n        override\n        onlyRole(GUARDIAN_ROLE)\n        onlyCompatibleInputArrays(_xKeeperFeesClosing, _yKeeperFeesClosing)\n    {\n        xKeeperFeesClosing = _xKeeperFeesClosing;\n        yKeeperFeesClosing = _yKeeperFeesClosing;\n        emit KeeperFeesClosingUpdated(xKeeperFeesClosing, yKeeperFeesClosing);\n    }\n\n    // ================ Governance - `PoolManager` Functions =======================\n\n    /// @notice Changes the reference to the `FeeManager` contract\n    /// @param feeManager_ New `FeeManager` contract\n    /// @dev This allows the `PoolManager` contract to propagate changes to the `PerpetualManager`\n    /// @dev This is the only place where the `_feeManager` can be changed, it is as if there was\n    /// a `FEEMANAGER_ROLE` for which `PoolManager` was the admin\n    function setFeeManager(IFeeManager feeManager_) external override onlyRole(POOLMANAGER_ROLE) {\n        _feeManager = feeManager_;\n    }\n\n    // ======================= `StableMaster` Function =============================\n\n    /// @notice Changes the oracle contract used to compute collateral price with respect to the stablecoin's price\n    /// @param oracle_ Oracle contract\n    /// @dev The collateral `PoolManager` does not store a reference to an oracle, the value of the oracle\n    /// is hence directly set by the `StableMaster`\n    function setOracle(IOracle oracle_) external override {\n        require(msg.sender == address(_stableMaster), \"1\");\n        oracle = oracle_;\n    }\n}\n"
    },
    "contracts/poolManager/PoolManagerStorageV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PoolManagerEvents.sol\";\n\n/// @title PoolManagerStorageV1\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains most of the variables and parameters stored for this contract. It does not contain all\n/// as the storage file has been split into multiple files to avoid clashes when upgrading the smart contract\ncontract PoolManagerStorageV1 is PoolManagerEvents, FunctionUtils {\n    // ================ References to contracts that cannot be modified ============\n\n    /// @notice Interface for the underlying token accepted by this contract\n    IERC20 public token;\n\n    /// @notice Reference to the `PerpetualManager` for this collateral/stablecoin pair\n    /// `PerpetualManager` is an upgradeable contract, there is therefore no need to be able to update this reference\n    IPerpetualManager public perpetualManager;\n\n    /// @notice Reference to the `StableMaster` contract corresponding to this `PoolManager`\n    IStableMaster public stableMaster;\n\n    // ============== References to contracts that can be modified =================\n\n    /// @notice FeeManager contract for this collateral/stablecoin pair\n    /// This reference can be updated by the `StableMaster` and change is going to be propagated\n    /// to the `PerpetualManager` from this contract\n    IFeeManager public feeManager;\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Funds currently given to strategies\n    uint256 public totalDebt;\n\n    /// @notice Proportion of the funds managed dedicated to strategies\n    /// Has to be between 0 and `BASE_PARAMS`\n    uint256 public debtRatio;\n\n    /// The struct `StrategyParams` is defined in the interface `IPoolManager`\n    /// @notice Mapping between the address of a strategy contract and its corresponding details\n    mapping(address => StrategyParams) public strategies;\n\n    /// @notice List of the current strategies\n    address[] public strategyList;\n}\n"
    },
    "contracts/poolManager/PoolManagerStorageV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PoolManagerStorageV1.sol\";\n\n/// @title PoolManagerStorageV2\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file imports the `AccessControlUpgradeable`\ncontract PoolManagerStorageV2 is PoolManagerStorageV1, AccessControlUpgradeable {\n\n}\n"
    },
    "contracts/poolManager/PoolManagerStorageV3.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PoolManagerStorageV2.sol\";\n\n/// @title PoolManagerStorageV3\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains the last variables and parameters stored for this contract. The reason for not storing them\n/// directly in `PoolManagerStorageV1` is that theywere introduced after a first deployment and may have introduced a\n/// storage clash when upgrading\ncontract PoolManagerStorageV3 is PoolManagerStorageV2 {\n    /// @notice Address of the surplus distributor allowed to distribute rewards\n    address public surplusConverter;\n\n    /// @notice Share of the interests going to surplus and share going to SLPs\n    uint64 public interestsForSurplus;\n\n    /// @notice Interests accumulated by the protocol and to be distributed through ANGLE or veANGLE\n    /// token holders\n    uint256 public interestsAccumulated;\n\n    /// @notice Debt that must be paid by admins after a loss on a strategy\n    uint256 public adminDebt;\n}\n"
    },
    "contracts/poolManager/PoolManagerInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PoolManagerStorageV3.sol\";\n\n/// @title PoolManagerInternal\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains all the internal functions of the `PoolManager` contract\ncontract PoolManagerInternal is PoolManagerStorageV3 {\n    using SafeERC20 for IERC20;\n\n    // Roles need to be defined here because there are some internal access control functions\n    // in the `PoolManagerInternal` file\n\n    /// @notice Role for `StableMaster` only\n    bytes32 public constant STABLEMASTER_ROLE = keccak256(\"STABLEMASTER_ROLE\");\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for `Strategy` only\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    // ======================= Access Control and Governance =======================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    function _addGuardian(address _guardian) internal {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        perpetualManager.grantRole(GUARDIAN_ROLE, _guardian);\n        feeManager.grantRole(GUARDIAN_ROLE, _guardian);\n        uint256 strategyListLength = strategyList.length;\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).addGuardian(_guardian);\n        }\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function _revokeGuardian(address guardian) internal {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n        perpetualManager.revokeRole(GUARDIAN_ROLE, guardian);\n        feeManager.revokeRole(GUARDIAN_ROLE, guardian);\n        uint256 strategyListLength = strategyList.length;\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).revokeGuardian(guardian);\n        }\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Internal version of `updateStrategyDebtRatio`\n    /// @dev Updates the debt ratio for a strategy\n    function _updateStrategyDebtRatio(address strategy, uint256 _debtRatio) internal {\n        StrategyParams storage params = strategies[strategy];\n        require(params.lastReport != 0, \"78\");\n        debtRatio = debtRatio + _debtRatio - params.debtRatio;\n        require(debtRatio <= BASE_PARAMS, \"76\");\n        params.debtRatio = _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n    }\n\n    // ============================ Utils ==========================================\n\n    /// @notice Returns this `PoolManager`'s reserve of collateral (not including what has been lent)\n    function _getBalance() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns the amount of assets owned by this `PoolManager`\n    /// @dev This sums the current balance of the contract to what has been given to strategies\n    /// @dev This amount can be manipulated by flash loans\n    function _getTotalAsset() internal view returns (uint256) {\n        return _getBalance() + totalDebt;\n    }\n}\n"
    },
    "contracts/poolManager/PoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./PoolManagerInternal.sol\";\n\n/// @title PoolManager\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains the functions that are callable by governance or by other contracts of the protocol\n/// @dev References to this contract are called `PoolManager`\ncontract PoolManager is PoolManagerInternal, IPoolManagerFunctions {\n    using SafeERC20 for IERC20;\n\n    // ============================ Constructor ====================================\n\n    /// @notice Constructor of the `PoolManager` contract\n    /// @param _token Address of the collateral\n    /// @param _stableMaster Reference to the master stablecoin (`StableMaster`) interface\n    function initialize(address _token, IStableMaster _stableMaster)\n        external\n        initializer\n        zeroCheck(_token)\n        zeroCheck(address(_stableMaster))\n    {\n        __AccessControl_init();\n\n        // Creating the correct references\n        stableMaster = _stableMaster;\n        token = IERC20(_token);\n\n        // Access Control\n        // The roles in this contract can only be modified from the `StableMaster`\n        // For the moment `StableMaster` never uses the `GOVERNOR_ROLE`\n        _setupRole(STABLEMASTER_ROLE, address(stableMaster));\n        _setRoleAdmin(STABLEMASTER_ROLE, STABLEMASTER_ROLE);\n        _setRoleAdmin(GOVERNOR_ROLE, STABLEMASTER_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, STABLEMASTER_ROLE);\n        // No admin is set for `STRATEGY_ROLE`, checks are made in the appropriate functions\n        // `addStrategy` and `revokeStrategy`\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================= `StableMaster` Functions ==========================\n\n    /// @notice Changes the references to contracts from this protocol with which this collateral `PoolManager` interacts\n    /// and propagates some references to the `perpetualManager` and `feeManager` contracts\n    /// @param governorList List of the governor addresses of protocol\n    /// @param guardian Address of the guardian of the protocol (it can be revoked)\n    /// @param _perpetualManager New reference to the `PerpetualManager` contract containing all the logic for HAs\n    /// @param _feeManager Reference to the `FeeManager` contract that will serve for the `PerpetualManager` contract\n    /// @param _oracle Reference to the `Oracle` contract that will serve for the `PerpetualManager` contract\n    function deployCollateral(\n        address[] memory governorList,\n        address guardian,\n        IPerpetualManager _perpetualManager,\n        IFeeManager _feeManager,\n        IOracle _oracle\n    ) external override onlyRole(STABLEMASTER_ROLE) {\n        // These references need to be stored to be able to propagate changes and maintain\n        // the protocol's integrity when changes are posted from the `StableMaster`\n        perpetualManager = _perpetualManager;\n        feeManager = _feeManager;\n\n        // Access control\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _grantRole(GOVERNOR_ROLE, governorList[i]);\n            _grantRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _grantRole(GUARDIAN_ROLE, guardian);\n\n        // Propagates the changes to the other involved contracts\n        perpetualManager.deployCollateral(governorList, guardian, _feeManager, _oracle);\n        _feeManager.deployCollateral(governorList, guardian, address(_perpetualManager));\n\n        // `StableMaster` and `PerpetualManager` need to have approval to directly transfer some of\n        // this contract's tokens\n        token.safeIncreaseAllowance(address(stableMaster), type(uint256).max);\n        token.safeIncreaseAllowance(address(_perpetualManager), type(uint256).max);\n    }\n\n    /// @notice Adds a new governor address and echoes it to other contracts\n    /// @param _governor New governor address\n    function addGovernor(address _governor) external override onlyRole(STABLEMASTER_ROLE) {\n        // Access control for this contract\n        _grantRole(GOVERNOR_ROLE, _governor);\n        // Echoes the change to other contracts interacting with this collateral `PoolManager`\n        // Since the other contracts interacting with this `PoolManager` do not have governor roles,\n        // we just need it to set the new governor as guardian in these contracts\n        _addGuardian(_governor);\n    }\n\n    /// @notice Removes a governor address and echoes it to other contracts\n    /// @param _governor Governor address to remove\n    function removeGovernor(address _governor) external override onlyRole(STABLEMASTER_ROLE) {\n        // Access control for this contract\n        _revokeRole(GOVERNOR_ROLE, _governor);\n        _revokeGuardian(_governor);\n    }\n\n    /// @notice Changes the guardian address and echoes it to other contracts that interact with this `PoolManager`\n    /// @param _guardian New guardian address\n    /// @param guardian Old guardian address to revoke\n    function setGuardian(address _guardian, address guardian) external override onlyRole(STABLEMASTER_ROLE) {\n        _revokeGuardian(guardian);\n        _addGuardian(_guardian);\n    }\n\n    /// @notice Revokes the guardian address and echoes the change to other contracts that interact with this `PoolManager`\n    /// @param guardian Address of the guardian to revoke\n    function revokeGuardian(address guardian) external override onlyRole(STABLEMASTER_ROLE) {\n        _revokeGuardian(guardian);\n    }\n\n    /// @notice Allows to propagate the change of keeper for the collateral/stablecoin pair\n    /// @param _feeManager New `FeeManager` contract\n    function setFeeManager(IFeeManager _feeManager) external override onlyRole(STABLEMASTER_ROLE) {\n        // Changing the reference in the `PerpetualManager` contract where keepers are involved\n        feeManager = _feeManager;\n        perpetualManager.setFeeManager(_feeManager);\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Provides an estimated Annual Percentage Rate for SLPs based on lending to other protocols\n    /// @dev This function is an estimation and is made for external use only\n    /// @dev This does not take into account transaction fees which accrue to SLPs too\n    /// @dev This can be manipulated by a flash loan attack (SLP deposit/ withdraw) via `_getTotalAsset`\n    /// when entering you should make sure this hasn't be called by a flash loan and look\n    /// at a mean of past APR.\n    function estimatedAPR() external view returns (uint256 apr) {\n        apr = 0;\n        (, ISanToken sanTokenForAPR, , , , uint256 sanRate, , SLPData memory slpData, ) = stableMaster.collateralMap(\n            IPoolManager(address(this))\n        );\n        uint256 supply = sanTokenForAPR.totalSupply();\n\n        // `sanRate` should never be equal to 0\n        if (supply == 0) return type(uint256).max;\n\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            apr =\n                apr +\n                (strategies[strategyList[i]].debtRatio * IStrategy(strategyList[i]).estimatedAPR()) /\n                BASE_PARAMS;\n        }\n        apr = (apr * slpData.interestsForSLPs * _getTotalAsset()) / sanRate / supply;\n    }\n\n    /// @notice Tells a strategy how much it can borrow from this `PoolManager`\n    /// @return Amount of token a strategy has access to as a credit line\n    /// @dev Since this function is a view function, there is no need to have an access control logic\n    /// even though it will just be relevant for a strategy\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function creditAvailable() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target < params.totalStrategyDebt) return 0;\n\n        return Math.min(target - params.totalStrategyDebt, _getBalance());\n    }\n\n    /// @notice Tells a strategy how much it owes to this `PoolManager`\n    /// @return Amount of token a strategy has to reimburse\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function debtOutstanding() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target > params.totalStrategyDebt) return 0;\n\n        return (params.totalStrategyDebt - target);\n    }\n\n    /// @notice Reports the gains or loss made by a strategy\n    /// @param gain Amount strategy has realized as a gain on its investment since its\n    /// last report, and is free to be given back to `PoolManager` as earnings\n    /// @param loss Amount strategy has realized as a loss on its investment since its\n    /// last report, and should be accounted for on the `PoolManager`'s balance sheet.\n    /// The loss will reduce the `debtRatio`. The next time the strategy will harvest,\n    /// it will pay back the debt in an attempt to adjust to the new debt limit.\n    /// @param debtPayment Amount strategy has made available to cover outstanding debt\n    /// @dev This is the main contact point where the strategy interacts with the `PoolManager`\n    /// @dev The strategy reports back what it has free, then the `PoolManager` contract \"decides\"\n    /// whether to take some back or give it more. Note that the most it can\n    /// take is `gain + _debtPayment`, and the most it can give is all of the\n    /// remaining reserves. Anything outside of those bounds is abnormal behavior.\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external override onlyRole(STRATEGY_ROLE) {\n        require(token.balanceOf(msg.sender) >= gain + debtPayment, \"72\");\n\n        StrategyParams storage params = strategies[msg.sender];\n        // Updating parameters in the `perpetualManager`\n        // This needs to be done now because it has implications in `_getTotalAsset()`\n        params.totalStrategyDebt = params.totalStrategyDebt + gain - loss;\n        totalDebt = totalDebt + gain - loss;\n        params.lastReport = block.timestamp;\n\n        // Warning: `_getTotalAsset` could be manipulated by flashloan attacks.\n        // It may allow external users to transfer funds into strategy or remove funds\n        // from the strategy. Yet, as it does not impact the profit or loss and as attackers\n        // have no interest in making such txs to have a direct profit, we let it as is.\n        // The only issue is if the strategy is compromised; in this case governance\n        // should revoke the strategy\n        uint256 target = ((_getTotalAsset()) * params.debtRatio) / BASE_PARAMS;\n        if (target > params.totalStrategyDebt) {\n            // If the strategy has some credit left, tokens can be transferred to this strategy\n            uint256 available = Math.min(target - params.totalStrategyDebt, _getBalance());\n            params.totalStrategyDebt = params.totalStrategyDebt + available;\n            totalDebt = totalDebt + available;\n            if (available > 0) {\n                token.safeTransfer(msg.sender, available);\n            }\n        } else {\n            uint256 available = Math.min(params.totalStrategyDebt - target, debtPayment + gain);\n            params.totalStrategyDebt = params.totalStrategyDebt - available;\n            totalDebt = totalDebt - available;\n            if (available > 0) {\n                token.safeTransferFrom(msg.sender, address(this), available);\n            }\n        }\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, params.totalStrategyDebt);\n\n        // Handle gains before losses\n        if (gain > 0) {\n            uint256 gainForSurplus = (gain * interestsForSurplus) / BASE_PARAMS;\n            uint256 adminDebtPre = adminDebt;\n            // Depending on the current admin debt distribute the necessary gain from the strategies\n            if (adminDebtPre == 0) interestsAccumulated += gainForSurplus;\n            else if (adminDebtPre <= gainForSurplus) {\n                interestsAccumulated += gainForSurplus - adminDebtPre;\n                adminDebt = 0;\n            } else adminDebt -= gainForSurplus;\n            stableMaster.accumulateInterest(gain - gainForSurplus);\n            emit FeesDistributed(gain);\n        }\n\n        // Handle eventual losses\n        if (loss > 0) {\n            uint256 lossForSurplus = (loss * interestsForSurplus) / BASE_PARAMS;\n            uint256 interestsAccumulatedPreLoss = interestsAccumulated;\n            // If the loss can not be entirely soaked by the interests to be distributed then\n            // the protocol keeps track of the debt\n            if (lossForSurplus > interestsAccumulatedPreLoss) {\n                interestsAccumulated = 0;\n                adminDebt += lossForSurplus - interestsAccumulatedPreLoss;\n            } else interestsAccumulated -= lossForSurplus;\n            // The rest is incurred to SLPs\n            stableMaster.signalLoss(loss - lossForSurplus);\n        }\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Allows to recover any ERC20 token, including the token handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev As this function can be used to transfer funds to another contract, it has to be a `GOVERNOR` function\n    /// @dev In case the concerned token is the specific token handled by this contract, this function checks that the\n    /// amount entered is not too big and approximates the surplus of the protocol\n    /// @dev To esimate the amount of user claims on the concerned collateral, this function uses the `stocksUsers` for\n    /// this collateral, but this is just an approximation as users can claim the collateral of their choice provided\n    /// that they own a stablecoin\n    /// @dev The sanity check excludes the HA claims: to get a sense of it, this function would need to compute the cash out\n    /// amount of all the perpetuals, and this cannot be done on-chain in a cheap manner\n    /// @dev Overall, even though there is a sanity check, this function relies on the fact that governance is not corrupted\n    /// in this protocol and will not try to withdraw too much funds\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (tokenAddress == address(token)) {\n            // Fetching info from the `StableMaster`\n            (\n                ,\n                ISanToken sanToken,\n                ,\n                IOracle oracle,\n                uint256 stocksUsers,\n                uint256 sanRate,\n                uint256 collatBase,\n                ,\n\n            ) = IStableMaster(stableMaster).collateralMap(IPoolManager(address(this)));\n\n            // Checking if there are enough reserves for the amount to withdraw\n            require(\n                _getTotalAsset() >=\n                    amountToRecover +\n                        (sanToken.totalSupply() * sanRate) /\n                        BASE_TOKENS +\n                        (stocksUsers * collatBase) /\n                        oracle.readUpper() +\n                        interestsAccumulated,\n                \"66\"\n            );\n\n            token.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Adds a strategy to the `PoolManager`\n    /// @param strategy The address of the strategy to add\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev Multiple checks are made. For instance, the contract must not already belong to the `PoolManager`\n    /// and the underlying token of the strategy has to be consistent with the `PoolManager` contracts\n    /// @dev This function is a `governor` function and not a `guardian` one because a `guardian` could add a strategy\n    /// enabling the withdraw of the funds of the protocol\n    /// @dev The `_debtRatio` should be expressed in `BASE_PARAMS`\n    function addStrategy(address strategy, uint256 _debtRatio) external onlyRole(GOVERNOR_ROLE) zeroCheck(strategy) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.lastReport == 0, \"73\");\n        require(address(this) == IStrategy(strategy).poolManager(), \"74\");\n        // Using current code, this condition should always be verified as in the constructor\n        // of the strategy the `want()` is set to the token of this `PoolManager`\n        require(address(token) == IStrategy(strategy).want(), \"75\");\n        require(debtRatio + _debtRatio <= BASE_PARAMS, \"76\");\n\n        // Add strategy to approved strategies\n        params.lastReport = 1;\n        params.totalStrategyDebt = 0;\n        params.debtRatio = _debtRatio;\n\n        _grantRole(STRATEGY_ROLE, strategy);\n\n        // Update global parameters\n        debtRatio += _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n\n        strategyList.push(strategy);\n    }\n\n    // =========================== Guardian Functions ==============================\n\n    /// @notice Sets a new surplus distributor to which surplus from the protocol will be pushed\n    /// @param newSurplusConverter Address to which the role needs to be granted\n    /// @dev It is as if the `GUARDIAN_ROLE` was admin of the `SURPLUS_DISTRIBUTOR_ROLE`\n    /// @dev The address can be the zero address in case the protocol revokes the `surplusConverter`\n    function setSurplusConverter(address newSurplusConverter) external onlyRole(GUARDIAN_ROLE) {\n        address oldSurplusConverter = surplusConverter;\n        surplusConverter = newSurplusConverter;\n        emit SurplusConverterUpdated(newSurplusConverter, oldSurplusConverter);\n    }\n\n    /// @notice Sets the share of the interests going directly to the surplus\n    /// @param _interestsForSurplus New value of the interests going directly to the surplus for buybacks\n    /// @dev Guardian should make sure the incentives for SLPs are still high enough for them to enter the protocol\n    function setInterestsForSurplus(uint64 _interestsForSurplus)\n        external\n        onlyRole(GUARDIAN_ROLE)\n        onlyCompatibleFees(_interestsForSurplus)\n    {\n        interestsForSurplus = _interestsForSurplus;\n        emit InterestsForSurplusUpdated(_interestsForSurplus);\n    }\n\n    /// @notice Modifies the funds a strategy has access to\n    /// @param strategy The address of the Strategy\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev The update has to be such that the `debtRatio` does not exceeds the 100% threshold\n    /// as this `PoolManager` cannot lend collateral that it doesn't not own.\n    /// @dev `_debtRatio` is stored as a uint256 but as any parameter of the protocol, it should be expressed\n    /// in `BASE_PARAMS`\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, _debtRatio);\n    }\n\n    /// @notice Triggers an emergency exit for a strategy and then harvests it to fetch all the funds\n    /// @param strategy The address of the `Strategy`\n    function setStrategyEmergencyExit(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, 0);\n        IStrategy(strategy).setEmergencyExit();\n        IStrategy(strategy).harvest();\n    }\n\n    /// @notice Revokes a strategy\n    /// @param strategy The address of the strategy to revoke\n    /// @dev This should only be called after the following happened in order: the `strategy.debtRatio` has been set to 0,\n    /// `harvest` has been called enough times to recover all capital gain/losses.\n    function revokeStrategy(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.debtRatio == 0, \"77\");\n        require(params.totalStrategyDebt == 0, \"77\");\n        uint256 strategyListLength = strategyList.length;\n        require(params.lastReport != 0 && strategyListLength >= 1, \"78\");\n        // It has already been checked whether the strategy was a valid strategy\n        for (uint256 i = 0; i < strategyListLength - 1; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyListLength - 1];\n                break;\n            }\n        }\n\n        strategyList.pop();\n\n        // Update global parameters\n        debtRatio -= params.debtRatio;\n        delete strategies[strategy];\n\n        _revokeRole(STRATEGY_ROLE, strategy);\n\n        emit StrategyRevoked(strategy);\n    }\n\n    /// @notice Withdraws a given amount from a strategy\n    /// @param strategy The address of the strategy\n    /// @param amount The amount to withdraw\n    /// @dev This function tries to recover `amount` from the strategy, but it may not go through\n    /// as we may not be able to withdraw from the lending protocol the full amount\n    /// @dev In this last case we only update the parameters by setting the loss as the gap between\n    /// what has been asked and what has been returned.\n    function withdrawFromStrategy(IStrategy strategy, uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[address(strategy)];\n        require(params.lastReport != 0, \"78\");\n\n        uint256 loss;\n        (amount, loss) = strategy.withdraw(amount);\n\n        // Handling eventual losses\n        params.totalStrategyDebt = params.totalStrategyDebt - loss - amount;\n        totalDebt = totalDebt - loss - amount;\n\n        emit StrategyReported(address(strategy), 0, loss, amount - loss, params.totalStrategyDebt);\n\n        // Handle eventual losses\n        // With the strategy we are using in current tests, it is going to be impossible to have\n        // a positive loss by calling strategy.withdraw, this function indeed calls _liquidatePosition\n        // which output value is always zero\n        if (loss > 0) stableMaster.signalLoss(loss);\n    }\n\n    // =================== Surplus Distributor Function ============================\n\n    /// @notice Allows to push interests revenue accumulated by the protocol to the `surplusConverter` to do buybacks\n    ///  or another form of redistribution to ANGLE or veANGLE token holders\n    /// @dev This function is permissionless and anyone can transfer the `interestsAccumulated` by the protocol\n    /// to the `surplusConverter`\n    function pushSurplus() external {\n        // If the `surplusConverter` has not been initialized, surplus should not be distributed\n        // Storing the `surplusConverter` in an intermediate variable to avoid multiple reads in\n        // storage\n        address surplusConverterMem = surplusConverter;\n        require(surplusConverterMem != address(0), \"0\");\n        uint256 amount = interestsAccumulated;\n        interestsAccumulated = 0;\n        // Storing the `token` in memory to avoid duplicate reads in storage\n        IERC20 tokenMem = token;\n        tokenMem.safeTransfer(surplusConverterMem, amount);\n        emit Recovered(address(tokenMem), surplusConverterMem, amount);\n    }\n\n    // ======================== Getters - View Functions ===========================\n\n    /// @notice Gets the current balance of this `PoolManager` contract\n    /// @return The amount of the underlying collateral that the contract currently owns\n    /// @dev This balance does not take into account what has been lent to strategies\n    function getBalance() external view override returns (uint256) {\n        return _getBalance();\n    }\n\n    /// @notice Gets the total amount of collateral that is controlled by this `PoolManager` contract\n    /// @return The amount of collateral owned by this contract plus the amount that has been lent to strategies\n    /// @dev This is the value that is used to compute the debt ratio for a given strategy\n    function getTotalAsset() external view override returns (uint256) {\n        return _getTotalAsset();\n    }\n}\n"
    },
    "contracts/stableMaster/StableMasterStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./StableMasterEvents.sol\";\n\n/// @title StableMasterStorage\n/// @author Angle Core Team\n/// @notice `StableMaster` is the contract handling all the collateral types accepted for a given stablecoin\n/// It does all the accounting and is the point of entry in the protocol for stable holders and seekers as well as SLPs\n/// @dev This file contains all the variables and parameters used in the `StableMaster` contract\ncontract StableMasterStorage is StableMasterEvents, FunctionUtils {\n    // All the details about a collateral that are going to be stored in `StableMaster`\n    struct Collateral {\n        // Interface for the token accepted by the underlying `PoolManager` contract\n        IERC20 token;\n        // Reference to the `SanToken` for the pool\n        ISanToken sanToken;\n        // Reference to the `PerpetualManager` for the pool\n        IPerpetualManager perpetualManager;\n        // Adress of the oracle for the change rate between\n        // collateral and the corresponding stablecoin\n        IOracle oracle;\n        // Amount of collateral in the reserves that comes from users\n        // converted in stablecoin value. Updated at minting and burning.\n        // A `stocksUsers` of 10 for a collateral type means that overall the balance of the collateral from users\n        // that minted/burnt stablecoins using this collateral is worth 10 of stablecoins\n        uint256 stocksUsers;\n        // Exchange rate between sanToken and collateral\n        uint256 sanRate;\n        // Base used in the collateral implementation (ERC20 decimal)\n        uint256 collatBase;\n        // Parameters for SLPs and update of the `sanRate`\n        SLPData slpData;\n        // All the fees parameters\n        MintBurnData feeData;\n    }\n\n    // ============================ Variables and References =====================================\n\n    /// @notice Maps a `PoolManager` contract handling a collateral for this stablecoin to the properties of the struct above\n    mapping(IPoolManager => Collateral) public collateralMap;\n\n    /// @notice Reference to the `AgToken` used in this `StableMaster`\n    /// This reference cannot be changed\n    IAgToken public agToken;\n\n    // Maps a contract to an address corresponding to the `IPoolManager` address\n    // It is typically used to avoid passing in parameters the address of the `PerpetualManager` when `PerpetualManager`\n    // is calling `StableMaster` to get information\n    // It is the Access Control equivalent for the `SanToken`, `PoolManager`, `PerpetualManager` and `FeeManager`\n    // contracts associated to this `StableMaster`\n    mapping(address => IPoolManager) internal _contractMap;\n\n    // List of all collateral managers\n    IPoolManager[] internal _managerList;\n\n    // Reference to the `Core` contract of the protocol\n    ICore internal _core;\n}\n"
    },
    "contracts/stableMaster/StableMasterInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./StableMasterStorage.sol\";\n\n/// @title StableMasterInternal\n/// @author Angle Core Team\n/// @notice `StableMaster` is the contract handling all the collateral types accepted for a given stablecoin\n/// It does all the accounting and is the point of entry in the protocol for stable holders and seekers as well as SLPs\n/// @dev This file contains all the internal function of the `StableMaster` contract\ncontract StableMasterInternal is StableMasterStorage, PausableMapUpgradeable {\n    /// @notice Checks if the `msg.sender` calling the contract has the right to do it\n    /// @param col Struct for the collateral associated to the caller address\n    /// @dev Since the `StableMaster` contract uses a `contractMap` that stores addresses of some verified\n    /// protocol's contracts in it, and since the roles corresponding to these addresses are never admin roles\n    /// it is cheaper not to use for these contracts OpenZeppelin's access control logic\n    /// @dev A non null associated token address is what is used to check if a `PoolManager` has well been initialized\n    /// @dev We could set `PERPETUALMANAGER_ROLE`, `POOLMANAGER_ROLE` and `FEEMANAGER_ROLE` for this\n    /// contract, but this would actually be inefficient\n    function _contractMapCheck(Collateral storage col) internal view {\n        require(address(col.token) != address(0), \"3\");\n    }\n\n    /// @notice Checks if the protocol has been paused for an agent and for a given collateral type for this\n    /// stablecoin\n    /// @param agent Name of the agent to check, it is either going to be `STABLE` or `SLP`\n    /// @param poolManager `PoolManager` contract for which to check pauses\n    function _whenNotPaused(bytes32 agent, address poolManager) internal view {\n        require(!paused[keccak256(abi.encodePacked(agent, poolManager))], \"18\");\n    }\n\n    /// @notice Updates the `sanRate` that is the exchange rate between sanTokens given to SLPs and collateral or\n    /// accumulates fees to be distributed to SLPs before doing it at next block\n    /// @param toShare Amount of interests that needs to be redistributed to the SLPs through the `sanRate`\n    /// @param col Struct for the collateral of interest here which values are going to be updated\n    /// @dev This function can only increase the `sanRate` and is not used to take into account a loss made through\n    /// lending or another yield farming strategy: this is done in the `signalLoss` function\n    /// @dev The `sanRate` is only be updated from the fees accumulated from previous blocks and the fees to share to SLPs\n    /// are just accumulated to be distributed at next block\n    /// @dev A flashloan attack could consist in seeing fees to be distributed, deposit, increase the `sanRate` and then\n    /// withdraw: what is done with the `lockedInterests` parameter is a way to mitigate that\n    /// @dev Another solution against flash loans would be to have a non null `slippage` at all times: this is far from ideal\n    /// for SLPs in the first place\n    function _updateSanRate(uint256 toShare, Collateral storage col) internal {\n        uint256 _lockedInterests = col.slpData.lockedInterests;\n        // Checking if the `sanRate` has been updated in the current block using past block fees\n        // This is a way to prevent flash loans attacks when an important amount of fees are going to be distributed\n        // in a block: fees are stored but will just be distributed to SLPs who will be here during next blocks\n        if (block.timestamp != col.slpData.lastBlockUpdated && _lockedInterests > 0) {\n            uint256 sanMint = col.sanToken.totalSupply();\n            if (sanMint != 0) {\n                // Checking if the update is too important and should be made in multiple blocks\n                if (_lockedInterests > col.slpData.maxInterestsDistributed) {\n                    // `sanRate` is expressed in `BASE_TOKENS`\n                    col.sanRate += (col.slpData.maxInterestsDistributed * BASE_TOKENS) / sanMint;\n                    _lockedInterests -= col.slpData.maxInterestsDistributed;\n                } else {\n                    col.sanRate += (_lockedInterests * BASE_TOKENS) / sanMint;\n                    _lockedInterests = 0;\n                }\n                emit SanRateUpdated(address(col.token), col.sanRate);\n            } else {\n                _lockedInterests = 0;\n            }\n        }\n        // Adding the fees to be distributed at next block\n        if (toShare != 0) {\n            if ((col.slpData.slippageFee == 0) && (col.slpData.feesAside != 0)) {\n                // If the collateral ratio is big enough, all the fees or gains will be used to update the `sanRate`\n                // If there were fees or lending gains that had been put aside, they will be added in this case to the\n                // update of the `sanRate`\n                toShare += col.slpData.feesAside;\n                col.slpData.feesAside = 0;\n            } else if (col.slpData.slippageFee != 0) {\n                // Computing the fraction of fees and gains that should be left aside if the collateral ratio is too small\n                uint256 aside = (toShare * col.slpData.slippageFee) / BASE_PARAMS;\n                toShare -= aside;\n                // The amount of fees left aside should be rounded above\n                col.slpData.feesAside += aside;\n            }\n            // Updating the amount of fees to be distributed next block\n            _lockedInterests += toShare;\n        }\n        col.slpData.lockedInterests = _lockedInterests;\n        col.slpData.lastBlockUpdated = block.timestamp;\n    }\n\n    /// @notice Computes the current fees to be taken when minting using `amount` of collateral\n    /// @param amount Amount of collateral in the transaction to get stablecoins\n    /// @param col Struct for the collateral of interest\n    /// @return feeMint Mint Fees taken to users expressed in collateral\n    /// @dev Fees depend on the hedge ratio that is the ratio between what is hedged by HAs and what should be hedged\n    /// @dev The more is hedged by HAs, the smaller fees are expected to be\n    /// @dev Fees are also corrected by the `bonusMalusMint` parameter which induces a dependence in collateral ratio\n    function _computeFeeMint(uint256 amount, Collateral storage col) internal view returns (uint256 feeMint) {\n        uint64 feeMint64;\n        if (col.feeData.xFeeMint.length == 1) {\n            // This is done to avoid an external call in the case where the fees are constant regardless of the collateral\n            // ratio\n            feeMint64 = col.feeData.yFeeMint[0];\n        } else {\n            uint64 hedgeRatio = _computeHedgeRatio(amount + col.stocksUsers, col);\n            // Computing the fees based on the spread\n            feeMint64 = _piecewiseLinear(hedgeRatio, col.feeData.xFeeMint, col.feeData.yFeeMint);\n        }\n        // Fees could in some occasions depend on other factors like collateral ratio\n        // Keepers are the ones updating this part of the fees\n        feeMint = (feeMint64 * col.feeData.bonusMalusMint) / BASE_PARAMS;\n    }\n\n    /// @notice Computes the current fees to be taken when burning stablecoins\n    /// @param amount Amount of collateral corresponding to the stablecoins burnt in the transaction\n    /// @param col Struct for the collateral of interest\n    /// @return feeBurn Burn fees taken to users expressed in collateral\n    /// @dev The amount is obtained after the amount of agTokens sent is converted in collateral\n    /// @dev Fees depend on the hedge ratio that is the ratio between what is hedged by HAs and what should be hedged\n    /// @dev The more is hedged by HAs, the higher fees are expected to be\n    /// @dev Fees are also corrected by the `bonusMalusBurn` parameter which induces a dependence in collateral ratio\n    function _computeFeeBurn(uint256 amount, Collateral storage col) internal view returns (uint256 feeBurn) {\n        uint64 feeBurn64;\n        if (col.feeData.xFeeBurn.length == 1) {\n            // Avoiding an external call if fees are constant\n            feeBurn64 = col.feeData.yFeeBurn[0];\n        } else {\n            uint64 hedgeRatio = _computeHedgeRatio(col.stocksUsers - amount, col);\n            // Computing the fees based on the spread\n            feeBurn64 = _piecewiseLinear(hedgeRatio, col.feeData.xFeeBurn, col.feeData.yFeeBurn);\n        }\n        // Fees could in some occasions depend on other factors like collateral ratio\n        // Keepers are the ones updating this part of the fees\n        feeBurn = (feeBurn64 * col.feeData.bonusMalusBurn) / BASE_PARAMS;\n    }\n\n    /// @notice Computes the hedge ratio that is the ratio between the amount of collateral hedged by HAs\n    /// divided by the amount that should be hedged\n    /// @param newStocksUsers Value of the collateral from users to hedge\n    /// @param col Struct for the collateral of interest\n    /// @return ratio Ratio between what's hedged divided what's to hedge\n    /// @dev This function is typically called to compute mint or burn fees\n    /// @dev It seeks from the `PerpetualManager` contract associated to the collateral the total amount\n    /// already hedged by HAs and compares it to the amount to hedge\n    function _computeHedgeRatio(uint256 newStocksUsers, Collateral storage col) internal view returns (uint64 ratio) {\n        // Fetching the amount hedged by HAs from the corresponding `perpetualManager` contract\n        uint256 totalHedgeAmount = col.perpetualManager.totalHedgeAmount();\n        newStocksUsers = (col.feeData.targetHAHedge * newStocksUsers) / BASE_PARAMS;\n        if (newStocksUsers > totalHedgeAmount) ratio = uint64((totalHedgeAmount * BASE_PARAMS) / newStocksUsers);\n        else ratio = uint64(BASE_PARAMS);\n    }\n}\n"
    },
    "contracts/stableMaster/StableMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./StableMasterInternal.sol\";\n\n/// @title StableMaster\n/// @author Angle Core Team\n/// @notice `StableMaster` is the contract handling all the collateral types accepted for a given stablecoin\n/// It does all the accounting and is the point of entry in the protocol for stable holders and seekers as well as SLPs\n/// @dev This file contains the core functions of the `StableMaster` contract\ncontract StableMaster is StableMasterInternal, IStableMasterFunctions, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for `Core` only, used to propagate guardian and governors\n    bytes32 public constant CORE_ROLE = keccak256(\"CORE_ROLE\");\n\n    bytes32 public constant STABLE = keccak256(\"STABLE\");\n    bytes32 public constant SLP = keccak256(\"SLP\");\n\n    // ============================ DEPLOYER =======================================\n\n    /// @notice Creates the access control logic for the governor and guardian addresses\n    /// @param governorList List of the governor addresses of the protocol\n    /// @param guardian Guardian address of the protocol\n    /// @param _agToken Reference to the `AgToken`, that is the ERC20 token handled by the `StableMaster`\n    /// @dev This function is called by the `Core` when a stablecoin is deployed to maintain consistency\n    /// across the governor and guardian roles\n    /// @dev When this function is called by the `Core`, it has already been checked that the `stableMaster`\n    /// corresponding to the `agToken` was this `stableMaster`\n    function deploy(\n        address[] memory governorList,\n        address guardian,\n        address _agToken\n    ) external override onlyRole(CORE_ROLE) {\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _grantRole(GOVERNOR_ROLE, governorList[i]);\n            _grantRole(GUARDIAN_ROLE, governorList[i]);\n        }\n        _grantRole(GUARDIAN_ROLE, guardian);\n        agToken = IAgToken(_agToken);\n        // Since there is only one address that can be the `AgToken`, and since `AgToken`\n        // is not to be admin of any role, we do not define any access control role for it\n    }\n\n    // ============================ STRATEGIES =====================================\n\n    /// @notice Takes into account the gains made while lending and distributes it to SLPs by updating the `sanRate`\n    /// @param gain Interests accumulated from lending\n    /// @dev This function is called by a `PoolManager` contract having some yield farming strategies associated\n    /// @dev To prevent flash loans, the `sanRate` is not directly updated, it is updated at the blocks that follow\n    function accumulateInterest(uint256 gain) external override {\n        // Searching collateral data\n        Collateral storage col = collateralMap[IPoolManager(msg.sender)];\n        _contractMapCheck(col);\n        // A part of the gain goes to SLPs, the rest to the surplus of the protocol\n        _updateSanRate((gain * col.slpData.interestsForSLPs) / BASE_PARAMS, col);\n    }\n\n    /// @notice Takes into account a loss made by a yield farming strategy\n    /// @param loss Loss made by the yield farming strategy\n    /// @dev This function is called by a `PoolManager` contract having some yield farming strategies associated\n    /// @dev Fees are not accumulated for this function before being distributed: everything is directly used to\n    /// update the `sanRate`\n    function signalLoss(uint256 loss) external override {\n        // Searching collateral data\n        IPoolManager poolManager = IPoolManager(msg.sender);\n        Collateral storage col = collateralMap[poolManager];\n        _contractMapCheck(col);\n        uint256 sanMint = col.sanToken.totalSupply();\n        if (sanMint != 0) {\n            // Updating the `sanRate` and the `lockedInterests` by taking into account a loss\n            if (col.sanRate * sanMint + col.slpData.lockedInterests * BASE_TOKENS > loss * BASE_TOKENS) {\n                // The loss is first taken from the `lockedInterests`\n                uint256 withdrawFromLoss = col.slpData.lockedInterests;\n\n                if (withdrawFromLoss >= loss) {\n                    withdrawFromLoss = loss;\n                }\n\n                col.slpData.lockedInterests -= withdrawFromLoss;\n                col.sanRate -= ((loss - withdrawFromLoss) * BASE_TOKENS) / sanMint;\n            } else {\n                // Normally it should be set to 0, but this would imply that no SLP can enter afterwards\n                // we therefore set it to 1 (equivalent to 10**(-18))\n                col.sanRate = 1;\n                col.slpData.lockedInterests = 0;\n                // As it is a critical time, governance pauses SLPs to solve the situation\n                _pause(keccak256(abi.encodePacked(SLP, address(poolManager))));\n            }\n            emit SanRateUpdated(address(col.token), col.sanRate);\n        }\n    }\n\n    // ============================== HAs ==========================================\n\n    /// @notice Transforms a HA position into a SLP Position\n    /// @param amount The amount to transform\n    /// @param user Address to mint sanTokens to\n    /// @dev Can only be called by a `PerpetualManager` contract\n    /// @dev This is typically useful when a HA wishes to cash out but there is not enough collateral\n    /// in reserves\n    function convertToSLP(uint256 amount, address user) external override {\n        // Data about the `PerpetualManager` calling the function is fetched using the `contractMap`\n        IPoolManager poolManager = _contractMap[msg.sender];\n        Collateral storage col = collateralMap[poolManager];\n        _contractMapCheck(col);\n        // If SLPs are paused, in this situation, then this transaction should revert\n        // In this extremely rare case, governance should take action and also pause HAs\n        _whenNotPaused(SLP, address(poolManager));\n        _updateSanRate(0, col);\n        col.sanToken.mint(user, (amount * BASE_TOKENS) / col.sanRate);\n    }\n\n    /// @notice Sets the proportion of `stocksUsers` available for perpetuals\n    /// @param _targetHAHedge New value of the hedge ratio that the protocol wants to arrive to\n    /// @dev Can only be called by the `PerpetualManager`\n    function setTargetHAHedge(uint64 _targetHAHedge) external override {\n        // Data about the `PerpetualManager` calling the function is fetched using the `contractMap`\n        IPoolManager poolManager = _contractMap[msg.sender];\n        Collateral storage col = collateralMap[poolManager];\n        _contractMapCheck(col);\n        col.feeData.targetHAHedge = _targetHAHedge;\n        // No need to issue an event here, one has already been issued by the corresponding `PerpetualManager`\n    }\n\n    // ============================ VIEW FUNCTIONS =================================\n\n    /// @notice Transmits to the `PerpetualManager` the max amount of collateral (in stablecoin value) HAs can hedge\n    /// @return _stocksUsers All stablecoins currently assigned to the pool of the caller\n    /// @dev This function will not return something relevant if it is not called by a `PerpetualManager`\n    function getStocksUsers() external view override returns (uint256 _stocksUsers) {\n        _stocksUsers = collateralMap[_contractMap[msg.sender]].stocksUsers;\n    }\n\n    /// @notice Returns the collateral ratio for this stablecoin\n    /// @dev The ratio returned is scaled by `BASE_PARAMS` since the value is used to\n    /// in the `FeeManager` contrat to be compared with the values in `xArrays` expressed in `BASE_PARAMS`\n    function getCollateralRatio() external view override returns (uint256) {\n        uint256 mints = agToken.totalSupply();\n        if (mints == 0) {\n            // If nothing has been minted, the collateral ratio is infinity\n            return type(uint256).max;\n        }\n        uint256 val;\n        for (uint256 i = 0; i < _managerList.length; i++) {\n            // Oracle needs to be called for each collateral to compute the collateral ratio\n            val += collateralMap[_managerList[i]].oracle.readQuote(_managerList[i].getTotalAsset());\n        }\n        return (val * BASE_PARAMS) / mints;\n    }\n\n    // ============================== KEEPERS ======================================\n\n    /// @notice Updates all the fees not depending on personal agents inputs via a keeper calling the corresponding\n    /// function in the `FeeManager` contract\n    /// @param _bonusMalusMint New corrector of user mint fees for this collateral. These fees will correct\n    /// the mint fees from users that just depend on the hedge curve by HAs by introducing other dependencies.\n    /// In normal times they will be equal to `BASE_PARAMS` meaning fees will just depend on the hedge ratio\n    /// @param _bonusMalusBurn New corrector of user burn fees, depending on collateral ratio\n    /// @param _slippage New global slippage (the SLP fees from withdrawing) factor\n    /// @param _slippageFee New global slippage fee (the non distributed accumulated fees) factor\n    function setFeeKeeper(\n        uint64 _bonusMalusMint,\n        uint64 _bonusMalusBurn,\n        uint64 _slippage,\n        uint64 _slippageFee\n    ) external override {\n        // Fetching data about the `FeeManager` contract calling this function\n        // It is stored in the `_contractMap`\n        Collateral storage col = collateralMap[_contractMap[msg.sender]];\n        _contractMapCheck(col);\n\n        col.feeData.bonusMalusMint = _bonusMalusMint;\n        col.feeData.bonusMalusBurn = _bonusMalusBurn;\n        col.slpData.slippage = _slippage;\n        col.slpData.slippageFee = _slippageFee;\n        // An event is already emitted in the `FeeManager` contract\n    }\n\n    // ============================== AgToken ======================================\n\n    /// @notice Allows the `agToken` contract to update the `stocksUsers` for a given collateral after a burn\n    /// with no redeem\n    /// @param amount Amount by which `stocksUsers` should decrease\n    /// @param poolManager Reference to `PoolManager` for which `stocksUsers` needs to be updated\n    /// @dev This function can be called by the `agToken` contract after a burn of agTokens for which no collateral has been\n    /// redeemed\n    function updateStocksUsers(uint256 amount, address poolManager) external override {\n        require(msg.sender == address(agToken), \"3\");\n        Collateral storage col = collateralMap[IPoolManager(poolManager)];\n        _contractMapCheck(col);\n        require(col.stocksUsers >= amount, \"4\");\n        col.stocksUsers -= amount;\n        emit StocksUsersUpdated(address(col.token), col.stocksUsers);\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    // =============================== Core Functions ==============================\n\n    /// @notice Changes the `Core` contract\n    /// @param newCore New core address\n    /// @dev This function can only be called by the `Core` contract\n    function setCore(address newCore) external override onlyRole(CORE_ROLE) {\n        // Access control for this contract\n        _revokeRole(CORE_ROLE, address(_core));\n        _grantRole(CORE_ROLE, newCore);\n        _core = ICore(newCore);\n    }\n\n    /// @notice Adds a new governor address\n    /// @param governor New governor address\n    /// @dev This function propagates changes from `Core` to other contracts\n    /// @dev Propagating changes like that allows to maintain the protocol's integrity\n    function addGovernor(address governor) external override onlyRole(CORE_ROLE) {\n        // Access control for this contract\n        _grantRole(GOVERNOR_ROLE, governor);\n        _grantRole(GUARDIAN_ROLE, governor);\n\n        for (uint256 i = 0; i < _managerList.length; i++) {\n            // The `PoolManager` will echo the changes across all the corresponding contracts\n            _managerList[i].addGovernor(governor);\n        }\n    }\n\n    /// @notice Removes a governor address which loses its role\n    /// @param governor Governor address to remove\n    /// @dev This function propagates changes from `Core` to other contracts\n    /// @dev Propagating changes like that allows to maintain the protocol's integrity\n    /// @dev It has already been checked in the `Core` that this address could be removed\n    /// and that it would not put the protocol in a situation with no governor at all\n    function removeGovernor(address governor) external override onlyRole(CORE_ROLE) {\n        // Access control for this contract\n        _revokeRole(GOVERNOR_ROLE, governor);\n        _revokeRole(GUARDIAN_ROLE, governor);\n\n        for (uint256 i = 0; i < _managerList.length; i++) {\n            // The `PoolManager` will echo the changes across all the corresponding contracts\n            _managerList[i].removeGovernor(governor);\n        }\n    }\n\n    /// @notice Changes the guardian address\n    /// @param newGuardian New guardian address\n    /// @param oldGuardian Old guardian address\n    /// @dev This function propagates changes from `Core` to other contracts\n    /// @dev The zero check for the guardian address has already been performed by the `Core`\n    /// contract\n    function setGuardian(address newGuardian, address oldGuardian) external override onlyRole(CORE_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, oldGuardian);\n        _grantRole(GUARDIAN_ROLE, newGuardian);\n\n        for (uint256 i = 0; i < _managerList.length; i++) {\n            _managerList[i].setGuardian(newGuardian, oldGuardian);\n        }\n    }\n\n    /// @notice Revokes the guardian address\n    /// @param oldGuardian Guardian address to revoke\n    /// @dev This function propagates changes from `Core` to other contracts\n    function revokeGuardian(address oldGuardian) external override onlyRole(CORE_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, oldGuardian);\n        for (uint256 i = 0; i < _managerList.length; i++) {\n            _managerList[i].revokeGuardian(oldGuardian);\n        }\n    }\n\n    // ============================= Governor Functions ============================\n\n    /// @notice Deploys a new collateral by creating the correct references in the corresponding contracts\n    /// @param poolManager Contract managing and storing this collateral for this stablecoin\n    /// @param perpetualManager Contract managing HA perpetuals for this stablecoin\n    /// @param oracle Reference to the oracle that will give the price of the collateral with respect to the stablecoin\n    /// @param sanToken Reference to the sanTokens associated to the collateral\n    /// @dev All the references in parameters should correspond to contracts that have already been deployed and\n    /// initialized with appropriate references\n    /// @dev After calling this function, governance should initialize all parameters corresponding to this new collateral\n    function deployCollateral(\n        IPoolManager poolManager,\n        IPerpetualManager perpetualManager,\n        IFeeManager feeManager,\n        IOracle oracle,\n        ISanToken sanToken\n    ) external onlyRole(GOVERNOR_ROLE) {\n        // If the `sanToken`, `poolManager`, `perpetualManager` and `feeManager` were zero\n        // addresses, the following require would fail\n        // The only elements that are checked here are those that are defined in the constructors/initializers\n        // of the concerned contracts\n        require(\n            sanToken.stableMaster() == address(this) &&\n                sanToken.poolManager() == address(poolManager) &&\n                poolManager.stableMaster() == address(this) &&\n                perpetualManager.poolManager() == address(poolManager) &&\n                // If the `feeManager` is not initialized with the correct `poolManager` then this function\n                // will revert when `poolManager.deployCollateral` will be executed\n                feeManager.stableMaster() == address(this),\n            \"9\"\n        );\n        // Checking if the base of the tokens and of the oracle are not similar with one another\n        address token = poolManager.token();\n        uint256 collatBase = 10**(IERC20Metadata(token).decimals());\n        // If the address of the oracle was the zero address, the following would revert\n        require(oracle.inBase() == collatBase, \"11\");\n        // Checking if the collateral has not already been deployed\n        Collateral storage col = collateralMap[poolManager];\n        require(address(col.token) == address(0), \"13\");\n\n        // Creating the correct references\n        col.token = IERC20(token);\n        col.sanToken = sanToken;\n        col.perpetualManager = perpetualManager;\n        col.oracle = oracle;\n        // Initializing with the correct values\n        col.sanRate = BASE_TOKENS;\n        col.collatBase = collatBase;\n\n        // Adding the correct references in the `contractMap` we use in order not to have to pass addresses when\n        // calling the `StableMaster` from the `PerpetualManager` contract, or the `FeeManager` contract\n        // This is equivalent to granting Access Control roles for these contracts\n        _contractMap[address(perpetualManager)] = poolManager;\n        _contractMap[address(feeManager)] = poolManager;\n        _managerList.push(poolManager);\n\n        // Pausing agents at deployment to leave governance time to set parameters\n        // The `PerpetualManager` contract is automatically paused after being initialized, so HAs will not be able to\n        // interact with the protocol\n        _pause(keccak256(abi.encodePacked(SLP, address(poolManager))));\n        _pause(keccak256(abi.encodePacked(STABLE, address(poolManager))));\n\n        // Fetching the governor list and the guardian to initialize the `poolManager` correctly\n        address[] memory governorList = _core.governorList();\n        address guardian = _core.guardian();\n\n        // Propagating the deployment and passing references to the corresponding contracts\n        poolManager.deployCollateral(governorList, guardian, perpetualManager, feeManager, oracle);\n        emit CollateralDeployed(address(poolManager), address(perpetualManager), address(sanToken), address(oracle));\n    }\n\n    /// @notice Removes a collateral from the list of accepted collateral types and pauses all actions associated\n    /// to this collateral\n    /// @param poolManager Reference to the contract managing this collateral for this stablecoin in the protocol\n    /// @param settlementContract Settlement contract that will be used to close everyone's positions and to let\n    /// users, SLPs and HAs redeem if not all a portion of their claim\n    /// @dev Since this function has the ability to transfer the contract's funds to another contract, it should\n    /// only be accessible to the governor\n    /// @dev Before calling this function, governance should make sure that all the collateral lent to strategies\n    /// has been withdrawn\n    function revokeCollateral(IPoolManager poolManager, ICollateralSettler settlementContract)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        // Checking if the `poolManager` given here is well in the list of managers and taking advantage of that to remove\n        // the `poolManager` from the list\n        uint256 indexMet;\n        uint256 managerListLength = _managerList.length;\n        require(managerListLength >= 1, \"10\");\n        for (uint256 i = 0; i < managerListLength - 1; i++) {\n            if (_managerList[i] == poolManager) {\n                indexMet = 1;\n                _managerList[i] = _managerList[managerListLength - 1];\n                break;\n            }\n        }\n        require(indexMet == 1 || _managerList[managerListLength - 1] == poolManager, \"10\");\n        _managerList.pop();\n        Collateral memory col = collateralMap[poolManager];\n\n        // Deleting the references of the associated contracts: `perpetualManager` and `keeper` in the\n        // `_contractMap` and `poolManager` from the `collateralMap`\n        delete _contractMap[poolManager.feeManager()];\n        delete _contractMap[address(col.perpetualManager)];\n        delete collateralMap[poolManager];\n        emit CollateralRevoked(address(poolManager));\n\n        // Pausing entry (and exits for HAs)\n        col.perpetualManager.pause();\n        // No need to pause `SLP` and `STABLE_HOLDERS` as deleting the entry associated to the `poolManager`\n        // in the `collateralMap` will make everything revert\n\n        // Transferring the whole balance to global settlement\n        uint256 balance = col.token.balanceOf(address(poolManager));\n        col.token.safeTransferFrom(address(poolManager), address(settlementContract), balance);\n\n        // Settlement works with a fixed oracle value for HAs, it needs to be computed here\n        uint256 oracleValue = col.oracle.readLower();\n        // Notifying the global settlement contract with the properties of the contract to settle\n        // In case of global shutdown, there would be one settlement contract per collateral type\n        // Not using the `lockedInterests` to update the value of the sanRate\n        settlementContract.triggerSettlement(oracleValue, col.sanRate, col.stocksUsers);\n    }\n\n    // ============================= Guardian Functions ============================\n\n    /// @notice Pauses an agent's actions within this contract for a given collateral type for this stablecoin\n    /// @param agent Bytes representing the agent (`SLP` or `STABLE`) and the collateral type that is going to\n    /// be paused. To get the `bytes32` from a string, we use in Solidity a `keccak256` function\n    /// @param poolManager Reference to the contract managing this collateral for this stablecoin in the protocol and\n    /// for which `agent` needs to be paused\n    /// @dev If agent is `STABLE`, it is going to be impossible for users to mint stablecoins using collateral or to burn\n    /// their stablecoins\n    /// @dev If agent is `SLP`, it is going to be impossible for SLPs to deposit collateral and receive\n    /// sanTokens in exchange, or to withdraw collateral from their sanTokens\n    function pause(bytes32 agent, IPoolManager poolManager) external override onlyRole(GUARDIAN_ROLE) {\n        Collateral storage col = collateralMap[poolManager];\n        // Checking for the `poolManager`\n        _contractMapCheck(col);\n        _pause(keccak256(abi.encodePacked(agent, address(poolManager))));\n    }\n\n    /// @notice Unpauses an agent's action for a given collateral type for this stablecoin\n    /// @param agent Agent (`SLP` or `STABLE`) to unpause the action of\n    /// @param poolManager Reference to the associated `PoolManager`\n    /// @dev Before calling this function, the agent should have been paused for this collateral\n    function unpause(bytes32 agent, IPoolManager poolManager) external override onlyRole(GUARDIAN_ROLE) {\n        Collateral storage col = collateralMap[poolManager];\n        // Checking for the `poolManager`\n        _contractMapCheck(col);\n        _unpause(keccak256(abi.encodePacked(agent, address(poolManager))));\n    }\n\n    /// @notice Updates the `stocksUsers` for a given pair of collateral\n    /// @param amount Amount of `stocksUsers` to transfer from a pool to another\n    /// @param poolManagerUp Reference to `PoolManager` for which `stocksUsers` needs to increase\n    /// @param poolManagerDown Reference to `PoolManager` for which `stocksUsers` needs to decrease\n    /// @dev This function can be called in case where the reserves of the protocol for each collateral do not exactly\n    /// match what is stored in the `stocksUsers` because of increases or decreases in collateral prices at times\n    /// in which the protocol was not fully hedged by HAs\n    /// @dev With this function, governance can allow/prevent more HAs coming in a pool while preventing/allowing HAs\n    /// from other pools because the accounting variable of `stocksUsers` does not really match\n    function rebalanceStocksUsers(\n        uint256 amount,\n        IPoolManager poolManagerUp,\n        IPoolManager poolManagerDown\n    ) external onlyRole(GUARDIAN_ROLE) {\n        Collateral storage colUp = collateralMap[poolManagerUp];\n        Collateral storage colDown = collateralMap[poolManagerDown];\n        // Checking for the `poolManager`\n        _contractMapCheck(colUp);\n        _contractMapCheck(colDown);\n        // The invariant `col.stocksUsers <= col.capOnStableMinted` should remain true even after a\n        // governance update\n        require(colUp.stocksUsers + amount <= colUp.feeData.capOnStableMinted, \"8\");\n        colDown.stocksUsers -= amount;\n        colUp.stocksUsers += amount;\n        emit StocksUsersUpdated(address(colUp.token), colUp.stocksUsers);\n        emit StocksUsersUpdated(address(colDown.token), colDown.stocksUsers);\n    }\n\n    /// @notice Propagates the change of oracle for one collateral to all the contracts which need to have\n    /// the correct oracle reference\n    /// @param _oracle New oracle contract for the pair collateral/stablecoin\n    /// @param poolManager Reference to the `PoolManager` contract associated to the collateral\n    function setOracle(IOracle _oracle, IPoolManager poolManager)\n        external\n        onlyRole(GOVERNOR_ROLE)\n        zeroCheck(address(_oracle))\n    {\n        Collateral storage col = collateralMap[poolManager];\n        // Checking for the `poolManager`\n        _contractMapCheck(col);\n        require(col.oracle != _oracle, \"12\");\n        // The `inBase` of the new oracle should be the same as the `_collatBase` stored for this collateral\n        require(col.collatBase == _oracle.inBase(), \"11\");\n        col.oracle = _oracle;\n        emit OracleUpdated(address(poolManager), address(_oracle));\n        col.perpetualManager.setOracle(_oracle);\n    }\n\n    /// @notice Changes the parameters to cap the number of stablecoins you can issue using one\n    /// collateral type and the maximum interests you can distribute to SLPs in a sanRate update\n    /// in a block\n    /// @param _capOnStableMinted New value of the cap\n    /// @param _maxInterestsDistributed Maximum amount of interests distributed to SLPs in a block\n    /// @param poolManager Reference to the `PoolManager` contract associated to the collateral\n    function setCapOnStableAndMaxInterests(\n        uint256 _capOnStableMinted,\n        uint256 _maxInterestsDistributed,\n        IPoolManager poolManager\n    ) external override onlyRole(GUARDIAN_ROLE) {\n        Collateral storage col = collateralMap[poolManager];\n        // Checking for the `poolManager`\n        _contractMapCheck(col);\n        // The invariant `col.stocksUsers <= col.capOnStableMinted` should remain true even after a\n        // governance update\n        require(_capOnStableMinted >= col.stocksUsers, \"8\");\n        col.feeData.capOnStableMinted = _capOnStableMinted;\n        col.slpData.maxInterestsDistributed = _maxInterestsDistributed;\n        emit CapOnStableAndMaxInterestsUpdated(address(poolManager), _capOnStableMinted, _maxInterestsDistributed);\n    }\n\n    /// @notice Sets a new `FeeManager` contract and removes the old one which becomes useless\n    /// @param newFeeManager New `FeeManager` contract\n    /// @param oldFeeManager Old `FeeManager` contract\n    /// @param poolManager Reference to the contract managing this collateral for this stablecoin in the protocol\n    /// and associated to the `FeeManager` to update\n    function setFeeManager(\n        address newFeeManager,\n        address oldFeeManager,\n        IPoolManager poolManager\n    ) external onlyRole(GUARDIAN_ROLE) zeroCheck(newFeeManager) {\n        Collateral storage col = collateralMap[poolManager];\n        // Checking for the `poolManager`\n        _contractMapCheck(col);\n        require(_contractMap[oldFeeManager] == poolManager, \"10\");\n        require(newFeeManager != oldFeeManager, \"14\");\n        delete _contractMap[oldFeeManager];\n        _contractMap[newFeeManager] = poolManager;\n        emit FeeManagerUpdated(address(poolManager), newFeeManager);\n        poolManager.setFeeManager(IFeeManager(newFeeManager));\n    }\n\n    /// @notice Sets the proportion of fees from burn/mint of users and the proportion\n    /// of lending interests going to SLPs\n    /// @param _feesForSLPs New proportion of mint/burn fees going to SLPs\n    /// @param _interestsForSLPs New proportion of interests from lending going to SLPs\n    /// @dev The higher these proportions the bigger the APY for SLPs\n    /// @dev These proportions should be inferior to `BASE_PARAMS`\n    function setIncentivesForSLPs(\n        uint64 _feesForSLPs,\n        uint64 _interestsForSLPs,\n        IPoolManager poolManager\n    ) external override onlyRole(GUARDIAN_ROLE) onlyCompatibleFees(_feesForSLPs) onlyCompatibleFees(_interestsForSLPs) {\n        Collateral storage col = collateralMap[poolManager];\n        _contractMapCheck(col);\n        col.slpData.feesForSLPs = _feesForSLPs;\n        col.slpData.interestsForSLPs = _interestsForSLPs;\n        emit SLPsIncentivesUpdated(address(poolManager), _feesForSLPs, _interestsForSLPs);\n    }\n\n    /// @notice Sets the x array (ie ratios between amount hedged by HAs and amount to hedge)\n    /// and the y array (ie values of fees at thresholds) used to compute mint and burn fees for users\n    /// @param poolManager Reference to the `PoolManager` handling the collateral\n    /// @param _xFee Thresholds of hedge ratios\n    /// @param _yFee Values of the fees at thresholds\n    /// @param _mint Whether mint fees or burn fees should be updated\n    /// @dev The evolution of the fees between two thresholds is linear\n    /// @dev The length of the two arrays should be the same\n    /// @dev The values of `_xFee` should be in ascending order\n    /// @dev For mint fees, values in the y-array below should normally be decreasing: the higher the `x` the cheaper\n    /// it should be for stable seekers to come in as a high `x` corresponds to a high demand for volatility and hence\n    /// to a situation where all the collateral can be hedged\n    /// @dev For burn fees, values in the array below should normally be decreasing: the lower the `x` the cheaper it should\n    /// be for stable seekers to go out, as a low `x` corresponds to low demand for volatility and hence\n    /// to a situation where the protocol has a hard time covering its collateral\n    function setUserFees(\n        IPoolManager poolManager,\n        uint64[] memory _xFee,\n        uint64[] memory _yFee,\n        uint8 _mint\n    ) external override onlyRole(GUARDIAN_ROLE) onlyCompatibleInputArrays(_xFee, _yFee) {\n        Collateral storage col = collateralMap[poolManager];\n        _contractMapCheck(col);\n        if (_mint > 0) {\n            col.feeData.xFeeMint = _xFee;\n            col.feeData.yFeeMint = _yFee;\n        } else {\n            col.feeData.xFeeBurn = _xFee;\n            col.feeData.yFeeBurn = _yFee;\n        }\n        emit FeeArrayUpdated(address(poolManager), _xFee, _yFee, _mint);\n    }\n}\n"
    },
    "contracts/mock/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IPoolManager.sol\";\n\ncontract MockStrategy {\n    address public poolManager;\n\n    address public want;\n\n    constructor(address _poolManager, address _want) {\n        poolManager = _poolManager;\n        want = _want;\n    }\n\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external {\n        IPoolManager(poolManager).report(gain, loss, debtPayment);\n    }\n\n    function withdraw(uint256 amount) external pure returns (uint256, uint256) {\n        return (amount, 1);\n    }\n\n    function creditAvailable() external view returns (uint256 credit) {\n        credit = IPoolManager(poolManager).creditAvailable();\n    }\n}\n"
    },
    "contracts/orchestrator/OrchestratorOwnable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\nimport \"../interfaces/IStableMaster.sol\";\n\npragma solidity ^0.8.7;\n\nstruct PoolParameters {\n    uint64[] xFeeMint;\n    uint64[] yFeeMint;\n    uint64[] xFeeBurn;\n    uint64[] yFeeBurn;\n    uint64[] xHAFeesDeposit;\n    uint64[] yHAFeesDeposit;\n    uint64[] xHAFeesWithdraw;\n    uint64[] yHAFeesWithdraw;\n    uint256[] xSlippageFee;\n    uint64[] ySlippageFee;\n    uint256[] xSlippage;\n    uint64[] ySlippage;\n    uint256[] xBonusMalusMint;\n    uint64[] yBonusMalusMint;\n    uint256[] xBonusMalusBurn;\n    uint64[] yBonusMalusBurn;\n    uint64[] xKeeperFeesClosing;\n    uint64[] yKeeperFeesClosing;\n    uint64 haFeeDeposit;\n    uint64 haFeeWithdraw;\n    uint256 capOnStableMinted;\n    uint256 maxInterestsDistributed;\n    uint64 feesForSLPs;\n    uint64 interestsForSLPs;\n    uint64 targetHAHedge;\n    uint64 limitHAHedge;\n    uint64 maxLeverage;\n    uint64 maintenanceMargin;\n    uint64 lockTime;\n    uint64 keeperFeesLiquidationRatio;\n    uint256 keeperFeesLiquidationCap;\n    uint256 keeperFeesClosingCap;\n}\n\n/// @title OrchestratorOwnable\n/// @author Angle Core Team\n/// @notice Contract that is used to facilitate the deployment of a given collateral on mainnet\ncontract OrchestratorOwnable {\n    /// @notice Address that is allowed to call the `initCollateral` function\n    address public owner;\n\n    /// @notice Initializes the `owner` of the contract\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    /// @notice Changes the owner of a contract\n    /// @param _newOwner New owner of the contract\n    /// @dev With this function the timelock can be given the ownership of the contract\n    function setOwner(address _newOwner) external {\n        require(msg.sender == owner, \"79\");\n        owner = _newOwner;\n    }\n\n    /// @notice Initializes a pool\n    /// @param p List of all the parameters with which to initialize the pool\n    /// @dev Only the `owner` can call this function\n\n    function initCollateral(\n        IStableMaster stableMaster,\n        IPoolManager poolManager,\n        IPerpetualManager perpetualManager,\n        IFeeManager feeManager,\n        PoolParameters memory p\n    ) external {\n        require(msg.sender == owner, \"79\");\n        stableMaster.setUserFees(poolManager, p.xFeeMint, p.yFeeMint, 1);\n        stableMaster.setUserFees(poolManager, p.xFeeBurn, p.yFeeBurn, 0);\n\n        perpetualManager.setHAFees(p.xHAFeesDeposit, p.yHAFeesDeposit, 1);\n        perpetualManager.setHAFees(p.xHAFeesWithdraw, p.yHAFeesWithdraw, 0);\n\n        feeManager.setFees(p.xSlippageFee, p.ySlippageFee, 0);\n        feeManager.setFees(p.xBonusMalusMint, p.yBonusMalusMint, 1);\n        feeManager.setFees(p.xBonusMalusBurn, p.yBonusMalusBurn, 2);\n        feeManager.setFees(p.xSlippage, p.ySlippage, 3);\n\n        feeManager.setHAFees(p.haFeeDeposit, p.haFeeWithdraw);\n\n        stableMaster.setCapOnStableAndMaxInterests(p.capOnStableMinted, p.maxInterestsDistributed, poolManager);\n        stableMaster.setIncentivesForSLPs(p.feesForSLPs, p.interestsForSLPs, poolManager);\n\n        perpetualManager.setTargetAndLimitHAHedge(p.targetHAHedge, p.limitHAHedge);\n        perpetualManager.setBoundsPerpetual(p.maxLeverage, p.maintenanceMargin);\n        perpetualManager.setLockTime(p.lockTime);\n        perpetualManager.setKeeperFeesLiquidationRatio(p.keeperFeesLiquidationRatio);\n        perpetualManager.setKeeperFeesCap(p.keeperFeesLiquidationCap, p.keeperFeesClosingCap);\n        perpetualManager.setKeeperFeesClosing(p.xKeeperFeesClosing, p.yKeeperFeesClosing);\n\n        feeManager.updateHA();\n        feeManager.updateUsersSLP();\n\n        stableMaster.unpause(keccak256(\"STABLE\"), poolManager);\n        stableMaster.unpause(keccak256(\"SLP\"), poolManager);\n        perpetualManager.unpause();\n    }\n}\n"
    },
    "contracts/orchestrator/Orchestrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\nimport \"../interfaces/IStableMaster.sol\";\nimport \"./OrchestratorOwnable.sol\";\n\npragma solidity ^0.8.7;\n\n/// @title Orchestrator\n/// @author Angle Core Team\n/// @notice Contract that is used to facilitate the deployment of a given collateral on mainnet\ncontract Orchestrator {\n    /// @notice Deployer address that is allowed to call the `initCollateral` function\n    address public owner;\n\n    /// @notice Initializes the `owner`\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @notice Initializes a pool\n    /// @param p List of all the parameters with which to initialize the pool\n    /// @dev Only the `owner` can call this function\n    /// @dev The `PoolParameters` struct is defined in the `OrchestratorOwnable` file\n    function initCollateral(\n        IStableMaster stableMaster,\n        IPoolManager poolManager,\n        IPerpetualManager perpetualManager,\n        IFeeManager feeManager,\n        PoolParameters memory p\n    ) external {\n        require(msg.sender == owner, \"79\");\n        stableMaster.setUserFees(poolManager, p.xFeeMint, p.yFeeMint, 1);\n        stableMaster.setUserFees(poolManager, p.xFeeBurn, p.yFeeBurn, 0);\n\n        perpetualManager.setHAFees(p.xHAFeesDeposit, p.yHAFeesDeposit, 1);\n        perpetualManager.setHAFees(p.xHAFeesWithdraw, p.yHAFeesWithdraw, 0);\n\n        feeManager.setFees(p.xSlippageFee, p.ySlippageFee, 0);\n        feeManager.setFees(p.xBonusMalusMint, p.yBonusMalusMint, 1);\n        feeManager.setFees(p.xBonusMalusBurn, p.yBonusMalusBurn, 2);\n        feeManager.setFees(p.xSlippage, p.ySlippage, 3);\n\n        feeManager.setHAFees(p.haFeeDeposit, p.haFeeWithdraw);\n\n        stableMaster.setCapOnStableAndMaxInterests(p.capOnStableMinted, p.maxInterestsDistributed, poolManager);\n        stableMaster.setIncentivesForSLPs(p.feesForSLPs, p.interestsForSLPs, poolManager);\n\n        perpetualManager.setTargetAndLimitHAHedge(p.targetHAHedge, p.limitHAHedge);\n        perpetualManager.setBoundsPerpetual(p.maxLeverage, p.maintenanceMargin);\n        perpetualManager.setLockTime(p.lockTime);\n        perpetualManager.setKeeperFeesLiquidationRatio(p.keeperFeesLiquidationRatio);\n        perpetualManager.setKeeperFeesCap(p.keeperFeesLiquidationCap, p.keeperFeesClosingCap);\n        perpetualManager.setKeeperFeesClosing(p.xKeeperFeesClosing, p.yKeeperFeesClosing);\n\n        feeManager.updateHA();\n        feeManager.updateUsersSLP();\n\n        stableMaster.unpause(keccak256(\"STABLE\"), poolManager);\n        stableMaster.unpause(keccak256(\"SLP\"), poolManager);\n        perpetualManager.unpause();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
